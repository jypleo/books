<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>刘云露</title>
    <meta name="description" content="一些有意思的东西">
    <meta name="generator" content="VitePress v1.3.1">
    <link rel="preload stylesheet" href="/books/assets/style.BoxccS-0.css" as="style">
    
    <script type="module" src="/books/assets/app.MGbGTwrK.js"></script>
    <link rel="preload" href="/books/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/books/assets/chunks/framework.D8Prfz4N.js">
    <link rel="modulepreload" href="/books/assets/chunks/theme.CHiTq8XS.js">
    <link rel="modulepreload" href="/books/assets/pamphlet_防御式 CSS 精讲_16 Web 图片：你不应该遗忘的 CSS 技巧.md.CVkShDQu.lean.js">
    <meta name="referrer" content="no-referrer">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-fa9c8703><!--[--><!--]--><!--[--><span tabindex="-1" data-v-243700a8></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-243700a8> Skip to content </a><!--]--><!----><header class="VPNav" data-v-fa9c8703 data-v-9ecd24f1><div class="VPNavBar has-sidebar top" data-v-9ecd24f1 data-v-8be259f3><div class="wrapper" data-v-8be259f3><div class="container" data-v-8be259f3><div class="title" data-v-8be259f3><div class="VPNavBarTitle has-sidebar" data-v-8be259f3 data-v-d4781334><a class="title" href="/books/" data-v-d4781334><!--[--><!--]--><!----><span data-v-d4781334>刘云露</span><!--[--><!--]--></a></div></div><div class="content" data-v-8be259f3><div class="content-body" data-v-8be259f3><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8be259f3><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8be259f3 data-v-2f005d11><span id="main-nav-aria-label" class="visually-hidden" data-v-2f005d11> Main Navigation </span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-2f005d11 data-v-823b819b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-823b819b><span class="text" data-v-823b819b><!----><span data-v-823b819b>小册</span><span class="vpi-chevron-down text-icon" data-v-823b819b></span></span></button><div class="menu" data-v-823b819b><div class="VPMenu" data-v-823b819b data-v-cc2a57f1><div class="items" data-v-cc2a57f1><!--[--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/webpack5/1%20%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%20Webpack%EF%BC%9A%E6%97%A7%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A0%B4%E5%B1%80%E8%80%85.html" data-v-d12d4856><!--[-->Webpack5 核心原理与应用实践<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/advanced-guide-to-mastering-typeScript/1.%E5%BC%80%E7%AF%87%EF%BC%9A%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%20TypeScript.html" data-v-d12d4856><!--[-->TypeScript全面进阶指南<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E7%8E%A9%E8%BD%ACcss%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/1.%E5%87%86%E5%A4%87%E7%AF%87%EF%BC%9A%E5%AD%A6%E5%89%8D%E5%87%86%E5%A4%87.html" data-v-d12d4856><!--[-->玩转css艺术之美<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/1%20%E6%8E%A8%E8%8D%90%E5%BA%8F%EF%BD%9C%E5%85%8B%E5%86%9B%EF%BC%9A%E5%86%99%E5%A5%BD%20CSS%20%E6%98%AF%E9%9C%80%E8%A6%81%E7%BB%8F%E9%AA%8C%E7%9A%84.html" data-v-d12d4856><!--[-->防御式 CSS 精讲<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E5%9F%BA%E4%BA%8E%20Vite%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E6%88%98/1%20%E5%BC%80%E7%AF%87%E8%AF%8D%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B0%B1%E4%BB%8E%E6%90%AD%E5%BB%BA%E7%BB%84%E4%BB%B6%E5%BA%93%E5%BC%80%E5%A7%8B.html" data-v-d12d4856><!--[-->基于 Vite 的组件库工程化实战<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/1%20%E9%9D%A2%E8%AF%95%E6%80%BB%E6%9C%89%E5%A5%97%E8%B7%AF%EF%BC%8C%E7%AE%97%E6%B3%95%E4%B8%8D%E6%98%AF%E7%8E%84%E5%AD%A6%E2%80%94%E2%80%94%E5%86%99%E7%BB%99%E6%99%AE%E9%80%9A%E4%BA%BA%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5.html" data-v-d12d4856><!--[-->前端算法与数据结构面试：底层逻辑解读与大厂真题训练<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/1%20Babel%20%E7%9A%84%E4%BB%8B%E7%BB%8D.html" data-v-d12d4856><!--[-->Babel 插件通关秘籍<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/1%20%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%20---%20%E8%AE%A4%E8%AF%86%20WebGL.html" data-v-d12d4856><!--[-->WebGL 入门与实践<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8be259f3 data-v-0ac8ed3b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-0ac8ed3b data-v-8ca151db data-v-b8d94da6><span class="check" data-v-b8d94da6><span class="icon" data-v-b8d94da6><!--[--><span class="vpi-sun sun" data-v-8ca151db></span><span class="vpi-moon moon" data-v-8ca151db></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8be259f3 data-v-a68b78fa data-v-7d9d8cc4><!--[--><a class="VPSocialLink no-icon" href="https://github.com/jypleo/books" aria-label="github" target="_blank" rel="noopener" data-v-7d9d8cc4 data-v-4c6ec8e5><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8be259f3 data-v-de89d543 data-v-823b819b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-823b819b><span class="vpi-more-horizontal icon" data-v-823b819b></span></button><div class="menu" data-v-823b819b><div class="VPMenu" data-v-823b819b data-v-cc2a57f1><!----><!--[--><!--[--><!----><div class="group" data-v-de89d543><div class="item appearance" data-v-de89d543><p class="label" data-v-de89d543>Appearance</p><div class="appearance-action" data-v-de89d543><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-de89d543 data-v-8ca151db data-v-b8d94da6><span class="check" data-v-b8d94da6><span class="icon" data-v-b8d94da6><!--[--><span class="vpi-sun sun" data-v-8ca151db></span><span class="vpi-moon moon" data-v-8ca151db></span><!--]--></span></span></button></div></div></div><div class="group" data-v-de89d543><div class="item social-links" data-v-de89d543><div class="VPSocialLinks social-links-list" data-v-de89d543 data-v-7d9d8cc4><!--[--><a class="VPSocialLink no-icon" href="https://github.com/jypleo/books" aria-label="github" target="_blank" rel="noopener" data-v-7d9d8cc4 data-v-4c6ec8e5><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8be259f3 data-v-89220f3a><span class="container" data-v-89220f3a><span class="top" data-v-89220f3a></span><span class="middle" data-v-89220f3a></span><span class="bottom" data-v-89220f3a></span></span></button></div></div></div></div><div class="divider" data-v-8be259f3><div class="divider-line" data-v-8be259f3></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-fa9c8703 data-v-3e43048a><div class="container" data-v-3e43048a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-3e43048a><span class="vpi-align-left menu-icon" data-v-3e43048a></span><span class="menu-text" data-v-3e43048a>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-3e43048a data-v-394bc835><button data-v-394bc835>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-fa9c8703 data-v-a8e7572a><div class="curtain" data-v-a8e7572a></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-a8e7572a><span class="visually-hidden" id="sidebar-aria-label" data-v-a8e7572a> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-630655c8><section class="VPSidebarItem level-0 has-active" data-v-630655c8 data-v-1396c9b9><!----><div class="items" data-v-1396c9b9><!--[--><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/1%20%E6%8E%A8%E8%8D%90%E5%BA%8F%EF%BD%9C%E5%85%8B%E5%86%9B%EF%BC%9A%E5%86%99%E5%A5%BD%20CSS%20%E6%98%AF%E9%9C%80%E8%A6%81%E7%BB%8F%E9%AA%8C%E7%9A%84.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>1 推荐序｜克军：写好 CSS 是需要经验的</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/2%20%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%20UI%20%E5%BD%A2%E5%BC%8F%E9%80%89%E6%8B%A9%E8%A7%86%E8%A7%89%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%9F.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>2 如何根据 UI 形式选择视觉盒模型？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/3%20Flexbox%20%E5%92%8C%20Grid%20%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>3 Flexbox 和 Grid 中的换行</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/4%20Flexbox%20%E5%92%8C%20Grid%20%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%86%85%E5%AE%B9%E5%B0%BA%E5%AF%B8.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>4 Flexbox 和 Grid 中的最小内容尺寸</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/5%20%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E6%BB%9A%E5%8A%A8%E5%A4%B1%E6%95%88%E5%92%8C%E9%BB%98%E8%AE%A4%E6%8B%89%E4%BC%B8.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>5 布局中的滚动失效和默认拉伸</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/6%20%E5%9B%BA%E5%AE%9A%E7%BD%91%E6%A0%BC%E8%BD%A8%E9%81%93%E5%B0%BA%E5%AF%B8%E7%BB%99%20Web%20%E5%B8%83%E5%B1%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>6 固定网格轨道尺寸给 Web 布局带来的局限性</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/7%20%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D%EF%BC%9F.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>7 如何灵活设置元素之间的间距？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/8%20position%20sticky%20%E5%A4%B1%E6%95%88%E4%B8%8E%E4%BF%AE%E5%A4%8D.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>8 position sticky 失效与修复</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/9%20%20z-index%20%E5%A4%B1%E6%95%88%E4%B8%8E%E4%BF%AE%E5%A4%8D.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>9  z-index 失效与修复</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/10%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20border-radius.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>10 你不知道的 border-radius</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/11%20Web%20%E4%B8%AD%E7%9A%84%E9%98%B4%E5%BD%B1.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>11 Web 中的阴影</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/12%20Web%20%E4%B8%AD%E7%9A%84%E8%BE%B9%E6%A1%86.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>12 Web 中的边框</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/13%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E7%89%87%EF%BC%9A%E9%98%B2%E6%AD%A2%E5%9B%BE%E7%89%87%E7%9A%84%E6%8B%89%E4%BC%B8%E6%88%96%E6%8C%A4%E5%8E%8B.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>13 响应式图片：防止图片的拉伸或挤压</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/14%20%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%9B%BE%E7%89%87%E4%B8%8A%E6%96%87%E6%9C%AC%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7%EF%BC%9F.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>14 如何提高图片上文本的可读性？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/15%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20CSS%20%E6%B8%90%E5%8F%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>15 你不知道的 CSS 渐变</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/16%20Web%20%E5%9B%BE%E7%89%87%EF%BC%9A%E4%BD%A0%E4%B8%8D%E5%BA%94%E8%AF%A5%E9%81%97%E5%BF%98%E7%9A%84%20CSS%20%E6%8A%80%E5%B7%A7.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>16 Web 图片：你不应该遗忘的 CSS 技巧</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/17%20%E5%9B%BE%E7%89%87%E7%9A%84%E8%A3%81%E5%89%AA%E6%9C%AF.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>17 图片的裁剪术</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/18%20%20%E9%87%8D%E6%96%B0%E6%80%9D%E8%80%83%20Web%20%E4%B8%AD%E7%9A%84%E8%A3%81%E5%89%AA%EF%BC%9ACSS%20%E8%BF%98%E6%98%AF%20SVG%EF%BC%9F.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>18  重新思考 Web 中的裁剪：CSS 还是 SVG？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/19%20CSS%20%E5%A6%82%E4%BD%95%E6%94%B9%E5%96%84%E6%BB%9A%E5%8A%A8%E4%BD%93%E9%AA%8C.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>19 CSS 如何改善滚动体验</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/20%20%E7%BE%8E%E5%8C%96%E6%BB%9A%E5%8A%A8%E6%9D%A1%20UI%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%20UI.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>20 美化滚动条 UI：自定义滚动条 UI</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/21%20CSS%20%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%8D%95%E6%8D%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>21 CSS 的滚动捕捉</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/22%20%E6%BA%A2%E5%87%BA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8E%92%E6%9F%A5.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>22 溢出常见问题与排查</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/23%20%E6%98%93%E7%A2%8E%E7%9A%84%E5%AE%B9%E5%99%A8%E7%9B%92%E5%AD%90%EF%BC%9A%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%9B%BA%E5%AE%9A%E5%B0%BA%E5%AF%B8%E5%92%8C%E9%95%BF%E5%86%85%E5%AE%B9%E8%AE%BE%E7%BD%AE.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>23 易碎的容器盒子：避免使用固定尺寸和长内容设置</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/24%20%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E6%9D%A5%E6%9B%BF%E4%BB%A3%E7%89%A9%E7%90%86%E5%B1%9E%E6%80%A7.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>24 使用逻辑属性来替代物理属性</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/25%20%E5%A4%9A%E8%AF%AD%E8%A8%80%20Web%20%E5%BA%94%E7%94%A8%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>25 多语言 Web 应用需要注意的细节</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/26%20%E6%9D%A1%E4%BB%B6%20CSS%20%E4%B9%8B%20@%E8%A7%84%E5%88%99%E5%92%8C%20CSS%20%E9%80%89%E6%8B%A9%E5%99%A8.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>26 条件 CSS 之 @规则和 CSS 选择器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/27%20%E6%9D%A1%E4%BB%B6%20CSS%20%E4%B9%8B%20CSS%20%E5%B1%9E%E6%80%A7%E5%80%BC%E5%92%8C%20CSS%20%E5%87%BD%E6%95%B0.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>27 条件 CSS 之 CSS 属性值和 CSS 函数</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/28%20CSS%20%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>28 CSS 的黑魔法</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-fa9c8703 data-v-f34757bc><div class="VPDoc has-sidebar has-aside" data-v-f34757bc data-v-2a8ae8ad><!--[--><!--]--><div class="container" data-v-2a8ae8ad><div class="aside" data-v-2a8ae8ad><div class="aside-curtain" data-v-2a8ae8ad></div><div class="aside-container" data-v-2a8ae8ad><div class="aside-content" data-v-2a8ae8ad><div class="VPDocAside" data-v-2a8ae8ad data-v-5e1f76ae><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-5e1f76ae data-v-381c8800><div class="content" data-v-381c8800><div class="outline-marker" data-v-381c8800></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-381c8800>On this page</div><ul class="VPDocOutlineItem root" data-v-381c8800 data-v-b5df0154><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-5e1f76ae></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-2a8ae8ad><div class="content-container" data-v-2a8ae8ad><!--[--><!--]--><main class="main" data-v-2a8ae8ad><div style="position:relative;" class="vp-doc _books_pamphlet_%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2_16%20Web%20%E5%9B%BE%E7%89%87%EF%BC%9A%E4%BD%A0%E4%B8%8D%E5%BA%94%E8%AF%A5%E9%81%97%E5%BF%98%E7%9A%84%20CSS%20%E6%8A%80%E5%B7%A7" data-v-2a8ae8ad><div><p>我们已经花了几节课的篇幅围绕着 Web 图片展开了阐述，但 Web 中使用图片还有很多 CSS 技巧，这些技巧可以帮助 Web 开发者用好图片，给用户更好的体验。在这节课中，我们来聊聊一些很容易被你忽略的可用于 Web 图片的技巧。</p><h2 id="不要忘了-repeat" tabindex="-1">不要忘了 *-repeat <a class="header-anchor" href="#不要忘了-repeat" aria-label="Permalink to &quot;不要忘了 *-repeat&quot;">​</a></h2><blockquote><p><strong>这里的</strong> <strong><code>*-repeat</code></strong> <strong>指的是 CSS 中的</strong> <strong><code>background-repeat</code></strong> <strong>和</strong> <strong><code>mask-repeat</code></strong> ！</p></blockquote><p>在 CSS 中，可以通过 <code>background-image</code> 给一个元素引入一张或多张背景图片；也可以通过 <code>mask-image</code> 给一个元素引入一张或多张遮罩图片。它们分别是 <code>background</code> 和 <code>mask</code> 属性的一个子属性，而 <code>background-repeat</code> 和 <code>mask-repeat</code> 也是 <code>background</code> 和 <code>mask</code> 的子属性之一，用来控制背景图片和遮罩图片的平铺方式。</p><p>就拿背景图片为例吧。<code>background-repeat</code> 取值不同时，背景在容器中的平铺方式也将不同，取得的效果也将不同。</p><p>简单地说，在元素的背景层设置背景图片时，默认情况下，背景图片会沿着容器的水平和垂直方向重复平铺，以填充整个背景层：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465d32c142ef4ac7bde1c36c065d5b5d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>我们可以显式调整 <code>background-repeat</code> 值来改变背景图片在容器背景层中的平铺方式：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc69420ec114033b9cbb3f863bfe353~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/abajagw" target="_blank" rel="noreferrer">https://codepen.io/airen/full/abajagw</a></p></blockquote><p>接下来，花点时间来看每个不同值所起的作用以及差异。</p><h3 id="repeat" tabindex="-1">repeat <a class="header-anchor" href="#repeat" aria-label="Permalink to &quot;repeat&quot;">​</a></h3><p><code>background-repeat</code> 取值为 <code>repeat</code> 时，相当于是 <code>repeat repeat</code> ，表示背景图片会沿着元素背景层的水平方向（<code>x</code> 轴）和垂直方向（<code>y</code> 轴）重复平铺，直到铺满整个背景层的空间。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d08bffe445b4da3bb5ae9b33b6b7197~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>设置 <code>repeat</code> 值时，如果背景图片的尺寸和元素背景层空间不是倍数比例时，背景图片在最右侧和（或）最底部会被裁剪掉：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00044582ba6248fd9aff8296eb5a04c1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>从上图中你可能已经发现了，如果值为 <code>repeat</code> 时，背景图片在平铺时，会铺满整个背景层的空间，而且背景图片剪切会一直延伸到元素的 <code>&lt;border-box&gt;</code>（延伸到边框的外边缘）。如果你不希望图片按这样的方式来对背景图片裁剪，可以通过 <code>background-clip</code> 来改变。</p><h3 id="repeat-x-和-repeat-y" tabindex="-1">repeat-x 和 repeat-y <a class="header-anchor" href="#repeat-x-和-repeat-y" aria-label="Permalink to &quot;repeat-x 和 repeat-y&quot;">​</a></h3><p><code>repeat</code> 可以根据平铺的方向分为 <code>repeat-x</code> 和 <code>repeat-y</code> ：</p><ul><li>当 <code>background-repeat</code> 只显式设置 <code>repeat-x</code> 时，它相当于 <code>repeat no-repeat</code>，只会让背景图片在元素背景层中沿着 <code>x</code>轴进行重复平铺；</li><li>当 <code>background-repeat</code> 只显式设置 <code>repeat-y</code> 时，它相当于 <code>no-repeat repeat</code> ，只会让背景图片在元素背景层中沿着 <code>y</code> 轴进行重复平铺。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/672c08fffa4846f1b36d80b685b55dcd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="no-repeat" tabindex="-1">no-repeat <a class="header-anchor" href="#no-repeat" aria-label="Permalink to &quot;no-repeat&quot;">​</a></h3><p><code>no-repeat</code> 刚好和 <code>repeat</code> 相反，表示背景图片在元素背景层中不会被重复平铺：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a599b825f034a019f1ee393d9ac99a8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><code>background-repeat</code> 值为 <code>no-repeat</code> 时，如果背景图片尺寸小于容器背景层尺寸的话，那么背景图片无法填满整个背景层，在没有显式设置 <code>background-color</code> 值（它的初始值为 <code>transparent</code>）时，那么位于元素底部的内容就会被透出：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd689255d82c45fe95c0ebc5ac3ae189~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>反之，如果背景图片尺寸大于或等于容器背景层尺寸时，背景图片会填满整个背景层；当大于容器背景层尺寸时，背景图片还会被裁切掉：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b638d55b2a048b8b2680a6eca315f43~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>也就是说，<code>background-repeat</code> 取值为 <code>repeat-x</code>、<code>repeat-y</code> 和 <code>no-repeat</code> 时，背景图片都有可能不会（背景图片尺寸小于背景层尺寸）填满元素背景层。在这种情景中，它的位置是由 <code>background-position</code> 来决定的（默认是<code>0 0</code>位置）。</p><p>换句话说，<code>background-position</code> 的值会调整背景图片在背景层的位置，其实它也会影响 <code>background-repeat</code> 属性的其他值，包括接下来要介绍的 <code>space</code> 和 <code>round</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d0aef3dc4c457ea645fddb975a7815~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="space-和-round" tabindex="-1">space 和 round <a class="header-anchor" href="#space-和-round" aria-label="Permalink to &quot;space 和 round&quot;">​</a></h3><p><code>space</code> 和 <code>round</code> 是 <code>background-repeat</code> 新增的两个属性值，我想大多数开发者对它们并不了解，甚至从未使用过（其实我自己也很少用到它们），但它们的功能还是很有用处的。这里我们先来看 <code>space</code>。</p><p><code>background-repeat</code> 取值为 <code>space</code> 时，背景图片在容器的背景层重复平铺的方式看上去像 <code>repeat</code>，但它有一个最大的特色，即<strong>背景图片不会因为背景层的尺寸（空间）不匹配而被裁切</strong>。换句话说，<code>space</code> 会让背景图片按整数倍（<code>n</code>）沿着容器背景层的 <code>x</code> 和 <code>y</code> 轴重复平铺。</p><ul><li><p>如果背景层的宽度刚好是背景图片宽度的 <code>n</code> 倍，那么背景层的 <code>x</code> 轴方向有 <code>n</code> 张背景图重复平铺。</p></li><li><p>如果背景层的宽度不是背景图片宽度的 <code>n</code> 倍，那么浏览器会确保第一张和最后一张背景图固定在背景层 <code>x</code> 轴的最两端，同时每两张背景图之间会有一个空白的间距，这个空白的间距相等的，即 <code>(容器背景层宽度 - n × 背景图片宽度 ) ÷ (n - 1)</code>。</p><ul><li>假设元素背景层的宽度是 <code>570px</code>，背景图片宽度是 <code>100px</code>，在背景层 <code>x</code> 轴最多可以平铺 <code>5</code> 张背景图（因为 <code>6</code> 张需要 <code>6 x 100px = 600px</code>，无法容纳下），这样一来，相应的 <code>n</code> 就等于 <code>5</code>，根据相应的公式，可以计算出背景图片之间的间距是：<code>(570px - 5 × 100px) ÷ (5 - 1) = 17.5px</code>。</li></ul></li><li><p>如果背景层的高度刚好是背景图片高度的 <code>n</code> 倍，那么背景层的 <code>y</code> 轴方向会有 <code>n</code> 张背景图平铺。</p></li><li><p>如果背景层的高度不是背景图片高度的 <code>n</code> 倍，那么浏览器同样会确保第一张和最后一张背景图固定在背景层 <code>y</code> 轴的两端，同时每两张背景图之间会有一个空间的间距，这个空白的间距也是相等的，即 <code>(容器背景层高度 - n x 背景图片高度) ÷ (n - 1)</code>。</p><p>假设元素背景层的高度是 <code>246px</code>，背景图片高度是 <code>100px</code>，在背景层 <code>y</code> 轴最多可以平铺 <code>2</code> 张背景图（因为 <code>3</code> 张需要 <code>3 x 100px = 300px</code>，无法容纳下），这样一来，相应的 <code>n</code> 就等于 <code>2</code>，根据相应的公式，可以计算出背景图片之间的间距是：<code>(246px - 2 × 100px) ÷ (2 - 1) = 46px</code>。</p></li></ul><p>上述示例中提到的效果，就会像下图所示这样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09db37623401444293984b3a0c278c51~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在 <code>background-repeat</code> 中显式设置一个 <code>space</code> 值时，它相当于 <code>space space</code> 。</p><p>前面我们提到过，<code>background-position</code> 的取值对 <code>background-repeat</code> 的平铺是有一定影响的，不过有一个细节需要注意的是，当 <code>background-repeat</code> 取值为 <code>space</code>，只有一个图片（或单行，或单列）无裁切地显示时，才会受 <code>background-position</code> 影响，否则 <code>background-position</code> 属性会被忽视。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/648fa0b20c14404db42cf0baf7a7b37b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>另外，当 <code>background-repeat</code> 值为 <code>space</code> 时，只在一种情况下裁剪会发生，那就是图片太大了以至于没有足够的空间来完整显示一个图片。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83674a5b6a3b412f83511978b3c0350d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>从渲染的结果上来看，<code>round</code> 是最接近 <code>repeat</code> 的。如果 <code>background-repeat</code> 取值为 <code>round</code> 时，背景图片会沿着元素背景层的 <code>x</code> 轴和 <code>y</code> 轴重复平铺，直到铺满整个背景层。它和 <code>repeat</code> 最大的差异<strong>是</strong> <strong><code>round</code></strong>* <em>会根据元素背景层尺寸和背景图的尺寸做一个自适应处理</em>*。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f7b94396f7e443eb67a4c0443e44834~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>随着允许的空间在尺寸上的增长，被重复平铺的背景图片会伸展（不会像 <code>space</code> 留有空隙），直到有足够的空间来添加一个图片。当下一个图片被添加后，当前所有的图片会被压缩来腾出空间。</p><p>简单地说，<code>round</code> 会根据元素容器层尺寸和背景图片尺寸（以 <code>background-size</code> 设置的为准，如果未显式设置 <code>background-size</code>，将会以背景图片的原始尺寸为准）做取整计算，类似 JavaScript 的 <code>Math.floor()</code> 函数，向下取整。</p><p>来看一个简单的示例，当元素背景层的尺寸为 <code>624px x 277px</code>，背景图片的尺寸为 <code>100px x 100px</code>（显式使用 <code>background-size: 100px 100px</code> 重置背景图片尺寸），那么：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// » x轴 » 沿着元素背景层 x 轴方向（水平方向） </span></span>
<span class="line"><span>624 ÷ 100 = 6.24 » Math.floor(624 / 100) = 6 </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// » y轴 » 沿着元素背景层 y 轴方向（垂直方向） </span></span>
<span class="line"><span>277 ÷ 100 = 2.77 » Math.floor(277 / 100) = 2</span></span></code></pre></div><p>即水平方向（<code>x</code>）会铺放 <code>6</code> 张；垂直方向（<code>y</code>）会铺放 <code>2</code> 张，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7177eb2d468144f3808c79cda75e4472~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>注意，平铺之后的背景图尺寸不再是 <code>100px x 100px</code>（<code>background-size</code> 显式设置的值），因为浏览器的渲染引擎会重新计算背景图片的尺寸（根据 <code>background-size</code> 的计算规则计算出来的）。</p><p>就我们这个示例而言，相当于 <code>background-size: calc(100% / 6) calc(100% / 2)</code>。此时，重新计算尺寸之后的背景图片有可能会扭曲变形（宽高比例不一致）。要是观察仔细的话，上图中的背景图片就有点挤压变形了。</p><p>更有意思的是，当背景图片尺寸大于元素背景层尺寸，并且没有显式使用 <code>background-size</code> 重置背景图片尺寸（初始尺寸）时，<code>round</code> 依旧会让背景图片重新计算尺寸来填满元素背景层，确保背景图不会被裁剪。<strong><code>round</code></strong> <strong>始终能确保背景图在平铺过程中不被裁剪，即使只有一张的时候也是如此</strong>！</p><p>不过，<code>round</code> 并不是说，完全会让背景图片填充满整个背景层，在某些情况之下，是会留白的，它的表现形为有点类似于 <code>background-size</code> 的 <code>contain</code> 行为。这并不能说这种现象是错误的，反而能说它的表现行为是对的。因为 <code>round</code> 值在计算的时候，就是按照 <code>background-size</code> 规则计算的。</p><blockquote><p>注意，上述运用于 <code>background-repeat</code> 的值表现，同样也适用于 <code>mask-repeat</code> ！</p></blockquote><p>现在，我想你对 <code>background-repeat</code> （或 <code>mask-repeat</code>）有了一定的认识。但在 Web 开发的过程当中，我们有的时候并不知道使用的背景图片尺寸（它的尺寸有可能大于背景层尺寸，也有可能小于背景层尺寸）。</p><p>而且，大部分 Web 开发者都没有习惯去查看背景图片运用于大容器背景层中的结果。比如，当你使用尺寸比较大的图片作为背景图片时，你不会习惯性地去检查一下页面在大屏幕上的展示效果。如此一来，就很有可能留下一个坑。</p><p>通过上面的内容，我们都知道，<code>background-repeat</code> 的默认值是 <code>repeat</code>，即<strong>默认情况之下，背景图片会在容器背景层中沿着</strong> <strong><code>x</code></strong> <strong>轴和</strong> <strong><code>y</code></strong> <strong>轴进行平铺</strong>。由于笔记本电脑的屏幕较小（造成容器背景层尺寸较小），背景图片重复平铺的概率就很小；但在更大屏幕上，元素的尺寸可能随之变大，此时背景图片就有可能会在容器背景层重复平铺：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/190e886dc5b84ff589fae265a2c2475d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>为了避免这种情况，我们需要显式设置 <code>background-repeat</code> 的值为 <code>no-repeat</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.hero { </span></span>
<span class="line"><span>    background-image: url(&#39;..&#39;); </span></span>
<span class="line"><span>    background-repeat: no-repeat; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>注意，如果你在开发过程中，使用 CSS 的 <code>mask</code> 属性，那么这样的现象也会出现在 <code>mask-repeat</code> 上，需要将其设置为 <code>no-repeat</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.hero { </span></span>
<span class="line"><span>    mask-image: url(&#39;..&#39;); </span></span>
<span class="line"><span>    mask-repeat: no-repeat; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这样做虽然消除了背景平铺的现象，但也可能引来新的现象，比如背景图片无法填满整个容器的背景层。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7db90b47965846b1a8db08e6727f4f9b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>因此，为了不影响 Web 应用（或页面）的美感，你应该还需要考虑使用 <code>background-size</code> 和（或）<code>background-position</code> 来调整背景图片尺寸和位置：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element {</span></span>
<span class="line"><span>    background: url(&#39;...&#39;) no-repeat;</span></span>
<span class="line"><span>    background-position: center; /* 背景图片在容器背景层中心位置，在容器背景层中水平垂直居中 */</span></span>
<span class="line"><span>    background-size: cover;      /* 背景图片保留固定比例，并覆盖整个容器的背景层 */</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="背景图片吸附的黑魔法" tabindex="-1">背景图片吸附的黑魔法 <a class="header-anchor" href="#背景图片吸附的黑魔法" aria-label="Permalink to &quot;背景图片吸附的黑魔法&quot;">​</a></h2><p>这里所说的背景图片吸附指的是 <code>background-attachment</code> 如何控制背景图片（背景图层的背景图片）固定位置的行为。</p><p>在 CSS 中，如果显式使用 <code>background-image</code> 指定了背景图片（<code>&lt;image&gt;</code>），那么 <code>background-attachment</code> 属性将指定它们是相对于视口固定（<code>fixed</code>）还是随元素滚动（<code>scroll</code>）或相对于元素的内容是固定的（<code>local</code>）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1e86e70494744309577f82ceb571726~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/eYLjPxV" target="_blank" rel="noreferrer">https://codepen.io/airen/full/eYLjPxV</a></p></blockquote><p>相对而言，<code>fixed</code> 使用的频率要更少。除此之外，有很多平台至今都对 <code>background-attachment: fixed</code> 不支持，尤其是在移动端上。这是因为，<strong>固定背景导致重绘的成本很高，并且滚动表现也不尽人意，所以在一些移动端是被禁止的</strong>。</p><p>虽然 <code>background-attachment</code> 属性很少运用 <code>fixed</code> 值，但当 <code>background-attachment</code> 取值为 <code>fixed</code> 时，可以帮助我们构建一些有创意的 Web 效果，比如视差滚动效果。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;section class=&quot;fixed-background img-1&quot;&gt; </span></span>
<span class="line"><span>    &lt;div class=&quot;content&quot;&gt; </span></span>
<span class="line"><span>        &lt;h2&gt;Title here&lt;/h2&gt; </span></span>
<span class="line"><span>        &lt;p&gt;Lorem ipsum dolor sit amet, ...&lt;/p&gt; </span></span>
<span class="line"><span>    &lt;/div&gt; </span></span>
<span class="line"><span>&lt;/section&gt; </span></span>
<span class="line"><span>&lt;section class=&quot;fixed-background img-2&quot;&gt; </span></span>
<span class="line"><span>    &lt;!-- ... --&gt; </span></span>
<span class="line"><span>&lt;/section&gt;</span></span>
<span class="line"><span>.fixed-background { </span></span>
<span class="line"><span>    --bg-image: url(&quot;https://picsum.photos/2016/1642?image=10&quot;); </span></span>
<span class="line"><span>    --start-color: #09f; </span></span>
<span class="line"><span>    --stop-color: #90f; </span></span>
<span class="line"><span>    background-position: center; </span></span>
<span class="line"><span>    background-size: cover; </span></span>
<span class="line"><span>    background-image: linear-gradient( to bottom, var(--start-color), var(--stop-color) ), var(--bg-image); </span></span>
<span class="line"><span>    background-attachment: fixed; </span></span>
<span class="line"><span>    background-blend-mode: overlay, exclusion; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.img-1 { </span></span>
<span class="line"><span>    --start-color: #00deff; </span></span>
<span class="line"><span>    --stop-color: #ff8c00; </span></span>
<span class="line"><span>    --bg-image: url(&quot;https://picsum.photos/2016/1642?image=10&quot;); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.img-2 { </span></span>
<span class="line"><span>    --start-color: #111340; </span></span>
<span class="line"><span>    --stop-color: #4800ff; </span></span>
<span class="line"><span>    --bg-image: url(&quot;https://picsum.photos/2016/1642?image=20&quot;); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.img-3 { </span></span>
<span class="line"><span>    --start-color: #7c87a8; </span></span>
<span class="line"><span>    --stop-color: #ff0028; </span></span>
<span class="line"><span>    --bg-image: url(&quot;https://picsum.photos/2016/1642?image=30&quot;); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.img-4 { </span></span>
<span class="line"><span>    --start-color: #84a87c; </span></span>
<span class="line"><span>    --stop-color: #1b6571; </span></span>
<span class="line"><span>    --bg-image: url(&quot;https://picsum.photos/2016/1642?image=40&quot;); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.img-5 { </span></span>
<span class="line"><span>    --start-color: #5d4012; </span></span>
<span class="line"><span>    --stop-color: #5d912a; </span></span>
<span class="line"><span>    --bg-image: url(&quot;https://picsum.photos/2016/1642?image=50&quot;); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e94a12356fa405ab4bdf7f4bcd53ff7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/qBMyJGg" target="_blank" rel="noreferrer">https://codepen.io/airen/full/qBMyJGg</a></p></blockquote><p><strong>用</strong> <strong><code>background-attachment:fixed</code></strong> <strong>并不受欢迎</strong> 。</p><p><a href="https://twitter.com/murtuza_surti" target="_blank" rel="noreferrer">@Murtuzaali Surti </a>在 CSS-TRICKS 上发表过关于这个话题的一篇博文《<a href="https://css-tricks.com/the-fixed-background-attachment-hack/" target="_blank" rel="noreferrer">The Fixed Background Attachment Hack</a>》。详细地阐述了为什么 <code>background-attachment:fixed</code> 在移动端上渲染的时候存在问题以及如何使用CSS 黑魔法来实现类似 <code>background-attachment:fixed</code> 的效果。</p><p>@Murtuzaali Surti 在文中录制了相关的视频，向大家展示 <code>background-attachment:fixed</code> 在移动端渲染时的效果（并不是我们想要的）：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2cb7efbcd7c4919ac3c8815ffa822c1~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p><strong>渐变只是与其他内容一起滚动然后跳回来</strong> ！</p></blockquote><p>另一个需要注意的有趣的事情是，当 <code>background-attachment: fixed</code> 应用时，<strong>即使我们明确指定了高度，它也会被忽略</strong>。这是因为 <code>background-attachment</code> 计算固定背景的位置是相对于视口计算。 即使在 <code>body</code> 上显式设置 <code>height</code> 为 <code>100vh</code>，<code>background-attachment: fixed</code> 渲染出来的效果也不完全符合。</p><p>其中原委并不知。但有这样的一种观点：“<strong>也许原因是</strong> <strong><code>background-attachment: fixed</code></strong> <strong>依赖于最小的视口，而元素依赖于最大的视口</strong> ”。</p><p><a href="https://developer.chrome.com/blog/url-bar-resizing/" target="_blank" rel="noreferrer">@David Bokan</a> 曾经这样说过：</p><blockquote><p>Lengths defined in viewport units (i.e. vh) will not resize in response to the URL bar being shown or hidden. Instead, vh units will be sized to the viewport height as if the URL bar is always hidden. That is, vh units will be sized to the “largest possible viewport”. This means 100vh will be larger than the visible height when the URL bar is shown.</p></blockquote><p>大致意思是，“以视口单位（即 <code>vh</code>）定义的长度不会响应 URL 栏的显示或隐藏。相反， <code>vh</code> 单位将根据视口高度调整大小，就好像 URL 栏始终处于隐藏状态一样。也就是说， <code>vh</code> 单位将被调整为“最大可能的视口”。这意味着 <code>100vh</code> 将大于显示 URL 栏时的可见高度。”</p><p>其实<a href="https://caniuse.com/background-attachment" target="_blank" rel="noreferrer">这些问题在 Caniuse 上也有相应的描述</a>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40df73e61d0546299036069b97bd4a69~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>如果你碰到这个问题，在业务场景中又需要这样的效果，那么我们可以考虑下面这样的 Hack 手段来实现类似 <code>background-attachment:fixed</code> 的效果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;div class=&quot;bg&quot;&gt;&lt;/div&gt; </span></span>
<span class="line"><span>&lt;div class=&quot;content&quot;&gt;&lt;/div&gt; </span></span>
<span class="line"><span>.bg { </span></span>
<span class="line"><span>    background: linear-gradient(335deg, rgba(255,140,107,1) 0%, rgba(255,228,168,1) 100%); </span></span>
<span class="line"><span>    background-repeat: no-repeat; </span></span>
<span class="line"><span>    background-position: center; </span></span>
<span class="line"><span>    height: 100vh; </span></span>
<span class="line"><span>    width: 100vw; </span></span>
<span class="line"><span>    position: fixed; </span></span>
<span class="line"><span>    z-index: -1; /* 可选项 */ </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.content{ </span></span>
<span class="line"><span>    position: absolute; </span></span>
<span class="line"><span>    margin-top: 5rem; </span></span>
<span class="line"><span>    left: 50%; </span></span>
<span class="line"><span>    transform: translateX(-50%); </span></span>
<span class="line"><span>    width: 80%; </span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>注意，这段代码来自 <a href="https://css-tricks.com/the-fixed-background-attachment-hack/" target="_blank" rel="noreferrer">@Murtuzaali Surti</a>。</p></blockquote><p>最终效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b7288021526443bbf0cb18970626060~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>效果已经很完美了。但上面的 CSS 代码我们还可以进一步的优化，我们可以使用伪元素 <code>::before</code> 或 <code>::after</code> 来替代 <code>.bg</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span>.content { </span></span>
<span class="line"><span>    width: 80%; </span></span>
<span class="line"><span>    margin: auto; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>body { </span></span>
<span class="line"><span>    position: relative; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>body::before { </span></span>
<span class="line"><span>    content: &#39;&#39;; </span></span>
<span class="line"><span>    background: linear-gradient(335deg, rgba(255,140,107,1) 0%, rgba(255,228,168,1) 100%); </span></span>
<span class="line"><span>    background-repeat: no-repeat; </span></span>
<span class="line"><span>    background-position: center; </span></span>
<span class="line"><span>    height: 100vh; </span></span>
<span class="line"><span>    width: 100vw; </span></span>
<span class="line"><span>    position: fixed; </span></span>
<span class="line"><span>    z-index: -1;</span></span>
<span class="line"><span> }</span></span></code></pre></div><p>上面代码还可以进一步优化，只在移动端上使用伪元素定位：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>body{ </span></span>
<span class="line"><span>    background-image: url(image.png); </span></span>
<span class="line"><span>    background-size:cover; </span></span>
<span class="line"><span>    background-attachment:fixed; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>/* 移动端响应*/ </span></span>
<span class="line"><span>@media screen and (max-width:767px){ </span></span>
<span class="line"><span>    body{ </span></span>
<span class="line"><span>        background-position: -99999px -99999px; /* 移出可视区，也可以将其background-size设置为0 */ </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    body::before { </span></span>
<span class="line"><span>        content: &quot;&quot;; </span></span>
<span class="line"><span>        background-image: inherit; </span></span>
<span class="line"><span>        position: fixed; </span></span>
<span class="line"><span>        inset:0; </span></span>
<span class="line"><span>        height: 100vh; </span></span>
<span class="line"><span>        width: 100vw; </span></span>
<span class="line"><span>        background-size: cover; </span></span>
<span class="line"><span>        z-index: -1; </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d311b26dc36048fda03ee43fa2003d1f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/BaOPGKp" target="_blank" rel="noreferrer">https://codepen.io/airen/full/BaOPGKp</a></p></blockquote><p>简单地说，你在实际开发过程中，需要使用背景图片吸附时，建议使用伪元素的固定定位来替代，这样实现出来的效果更具兼容性。</p><h2 id="为什么背景定位需要新特性" tabindex="-1">为什么背景定位需要新特性？ <a class="header-anchor" href="#为什么背景定位需要新特性" aria-label="Permalink to &quot;为什么背景定位需要新特性？&quot;">​</a></h2><p>在 CSS 中，我们可以使用 <code>background-position</code> 属性来指定背景图片在容器背景层的起始位置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8fa31cfb6ca4921b01abd9a4ce42ead~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>大部分 Web 开发者只习惯（或只知道）于 <code>background-position</code> 属性设置一个或两个值：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e17ec3789b3b498dafcfbea2db396e0f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/wvExQqe" target="_blank" rel="noreferrer">https://codepen.io/airen/full/wvExQqe</a></p></blockquote><p>事实上，<code>background-position</code> 属性还可以指定三个值或四个值。当 <code>background-position</code> 属性指定三个值或四个值时，和前面所介绍的一个值或两个值还是有很大差异的。</p><p>我们首先来看 <code>background-position</code> 属性指定三个值。</p><p><code>background-position</code> 同时使用三个关键词时，会被浏览器视为无效的 CSS 声明，比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> /* 无效样式规则 */ </span></span>
<span class="line"><span> .element { </span></span>
<span class="line"><span>     background-position: left top center; </span></span>
<span class="line"><span> }</span></span></code></pre></div><p><code>background-position</code> 使用三个值时，往往是将 <code>&lt;length-percentage&gt;</code> 和两个关键词组合在一起使用：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: &lt;keyword&gt; &lt;length-percentage&gt; &lt;keyword&gt;; </span></span>
<span class="line"><span>    background-position: &lt;keyword&gt; &lt;keyword&gt; &lt;length-percentage&gt;; </span></span>
<span class="line"><span> } </span></span>
<span class="line"><span> </span></span>
<span class="line"><span> &lt;keyword&gt; = top | right | bottom | left</span></span></code></pre></div><p>即：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: left 30% top; </span></span>
<span class="line"><span>    background-position: right 30% bottom; </span></span>
<span class="line"><span>    background-position: left top 30%; </span></span>
<span class="line"><span>    background-position: right bottom 30%; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>也就是说，当 <code>&lt;length-percentage&gt;</code> 是 <code>background-position</code> 的第二个值时，它表示第一个值的偏移量，也就是水平方向（<code>x</code> 轴）的偏移：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: left 30% top; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>示例中的 <code>30%</code> 表示背景图片最左侧边缘距离背景层最左侧边缘的距离是 <code>30%</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> .element { </span></span>
<span class="line"><span>     background-position: right 300px bottom; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>示例中的 <code>300px</code> 表示背景图片最右边距离背景层最右侧边缘的距离是 <code>300px</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13aa8e7251234b3891cd98c6c19bc5b6~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>当 <code>&lt;length-percentage&gt;</code> 是 <code>background-position</code> 的第三个值时，它表示第二个值的偏移量，也就是垂直方向（<code>y</code>轴）的偏移：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> .element { </span></span>
<span class="line"><span>     background-position: left top 30%; </span></span>
<span class="line"><span> }</span></span></code></pre></div><p>示例中的 <code>30%</code> 表示背景图片顶部边缘距离背景层顶部边缘的距离是 <code>30%</code>。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: right bottom 300px; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>示例中的 <code>300px</code> 表示背景图片最底部边缘距离背景层底部边缘的距离是 <code>300px</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d9b277446634cfaaef3c0dd1b9b8ec0~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><code>background-position</code> 属性取两个关键词和一个 <code>&lt;length-percentage&gt;</code> 组合时，<code>&lt;length-percentage&gt;</code> 不要置于关键词前面，否则会被视为无效值：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> /* 无效 CSS 规则 */</span></span>
<span class="line"><span> .element { </span></span>
<span class="line"><span>     background-position: &lt;length-percentage&gt; &lt;keyword&gt; &lt;keyword&gt; </span></span>
<span class="line"><span> } </span></span>
<span class="line"><span> </span></span>
<span class="line"><span> &lt;keyword&gt; = top | right | bottom | left</span></span></code></pre></div><p>例如，浏览器将会视下面这个样式规则为无效的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* 无效 CSS 规则 */</span></span>
<span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: 40em left top; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>上面所示的示例用到的关键词都是围绕着 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 展开的。除了这四个关键词之外，还有 <code>center</code> 关键词。<code>background-position</code> 取三个值时，其中使用到关键词 <code>center</code> 时，后面不能紧跟 <code>&lt;length-percentage&gt;</code>，不然该规则也会被视为无效：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* 无效 CSS 规则 */ </span></span>
<span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: center &lt;length-percentage&gt; &lt;top | center | bottom&gt;; </span></span>
<span class="line"><span>    background-position: &lt;left | center | right&gt; center &lt;length-percentage&gt;; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>但像下面这样使用是有效的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: &lt;top | right | bottom | left&gt;  &lt;length-percentage&gt; center; </span></span>
<span class="line"><span>    background-position: center &lt;top | right | bottom | left&gt; &lt;length-percentage&gt; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: center right 30%;  /* x » right 30%, y » center */ </span></span>
<span class="line"><span>    background-position: center left 30%;   /* x » left 30%, y » center */ </span></span>
<span class="line"><span>    background-position: center bottom 30%; /* » center, y » bottom 30% */ </span></span>
<span class="line"><span>    background-position: center top 30%;    /* x » center, y » top 30% */ </span></span>
<span class="line"><span>    background-position: bottom 30% center; /* x » center, y » bottom 30% */ </span></span>
<span class="line"><span>    background-position: top 30% center;    /* x » center, y »  top 30% */ </span></span>
<span class="line"><span>    background-position: right 30% center;  /* x » right 30%, y » center */ </span></span>
<span class="line"><span>    background-position: left 30% center;   /* x » left 30%, y » center */ </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>简单地说，<code>background-position</code> 属性取三个值时，在关键词 <code>center</code> 之后不能紧跟 <code>&lt;length-percentage&gt;</code>值，否则会被视为无效声明！ 前面说了，<code>background-position</code> 属性使用三个值时，如果三个都是关键词，那么它将是一个无效声明，除此之外，一个关键词和两个 <code>&lt;length-percentage&gt;</code> 值组合也会被视为无效声明：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> .element { </span></span>
<span class="line"><span>     background-position: &lt;length-percentage&gt; &lt;keyword&gt; &lt;length-percentage&gt;; </span></span>
<span class="line"><span>     background-position: &lt;keyword&gt; &lt;length-percentage&gt; &lt;length-percentage&gt;; </span></span>
<span class="line"><span>     background-position: &lt;length-percentage&gt; &lt;length-percentage&gt; &lt;keyword&gt;; </span></span>
<span class="line"><span> }</span></span></code></pre></div><p>这样一来，<code>background-position</code> 取三个值时，像下面这样使用的话，都会被浏览器视为无效样式规则：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    /* 三个值都是关键词组合 */ </span></span>
<span class="line"><span>    background-position: &lt;keyword&gt; &lt;keyword&gt; &lt;keyword&gt;; </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    /* &lt;length-percentage&gt; 不能置于两个关键词的前面 */ </span></span>
<span class="line"><span>    background-position: &lt;length-percentage&gt; &lt;keyword&gt; &lt;keyword&gt;; </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    /* center关键词后面不能紧跟&lt;length-percentage&gt;值 */ </span></span>
<span class="line"><span>    background-position: center &lt;length-percentage&gt; &lt;keyword&gt;; </span></span>
<span class="line"><span>    background-position: &lt;keyword&gt; center &lt;length-percentage&gt;; </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    /* 一个关键词和两个&lt;length-percentage&gt;值组合 */ </span></span>
<span class="line"><span>    background-position: &lt;length-percentage&gt; &lt;keyword&gt; &lt;length-percentage&gt;; </span></span>
<span class="line"><span>    background-position: &lt;keyword&gt; &lt;length-percentage&gt; &lt;length-percentage&gt;; </span></span>
<span class="line"><span>    background-position: &lt;length-percentage&gt; &lt;length-percentage&gt; &lt;keyword&gt;; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21c3144c988648cea0add6ef5c2ec5a7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/wvExQEP" target="_blank" rel="noreferrer">https://codepen.io/airen/full/wvExQEP</a></p></blockquote><p><code>background-position</code> 指定四个值时要比指定三个值简单得多。<code>background-position</code> 在设置四个值的时候，一般是两个关键词与两个 <code>&lt;length-percentage&gt;</code> 值组合在一起使用。比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: &lt;keyword&gt; &lt;length-percentage&gt; &lt;keyword&gt; &lt;length-percentage&gt; </span></span>
<span class="line"><span> } </span></span>
<span class="line"><span> </span></span>
<span class="line"><span> &lt;keyword&gt; = top | right | bottom | left</span></span></code></pre></div><p>例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: top 30px right 50px;   /* x » right 50px, y » top 30px */ </span></span>
<span class="line"><span>    background-position: top 30% left 50%;      /* x » left 50%,   y » top 30% */ </span></span>
<span class="line"><span>    background-position: bottom 30px right 40vh;/* x » right 40vh, y » bottom 30px */ </span></span>
<span class="line"><span>    background-position: bottom 30vh left 40%;  /* x » left 40%,   y » bottom 30vh */ </span></span>
<span class="line"><span>    background-position: left 40px top 50%;     /* x » left 40px,  y » top 50% */ </span></span>
<span class="line"><span>    background-position: left 40vh bottom 50px; /* x » left 40vh,  y » bottom 50px */ </span></span>
<span class="line"><span>    background-position: right 50px top 30%;    /* x » right 50px, y » top 30% */ </span></span>
<span class="line"><span>    background-position: right 40% bottom 20px; /* x » right 40%, y » bottom 20px */ </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>第一个值和第三个值是关键词 <code>top</code> 、 <code>right</code> 、<code>bottom</code> 和 <code>left</code> 之一，第二个和第四个值是 <code>&lt;length-percentage&gt;</code>，其中第二个值 <code>&lt;length-percentage&gt;</code> 是用来设置第一个值偏移量的，第四个值是用来设置第三个值的偏移量。</p><p>在使用关键词时，不能同时出现同一方向的值，比如 <code>left</code> 和 <code>right</code> ，或者 <code>top</code> 和 <code>bottom</code> 同时出现，否则样式规则会被视为无效规则：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* 无效 CSS 规则 */</span></span>
<span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: top 50px bottom 30px; </span></span>
<span class="line"><span>    background-position: left 50% right 10px; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>另外，<code>background-position</code> 取四个值时，关键词不能是 <code>center</code>，否则也会被视为无效样式规则：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* 无效 CSS 规则*/</span></span>
<span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: center 50px top 50px; </span></span>
<span class="line"><span>    background-position: center 50% bottom 30px; </span></span>
<span class="line"><span>    background-position: left 30px center 40px; </span></span>
<span class="line"><span>    background-position: right 30px center 40%; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p><code>background-position</code> 取四个值时，<code>&lt;length-percentage&gt;</code> 一定是跟随在 <code>&lt;keyword&gt;</code> 关键词之后，如果 <code>&lt;length-percentage&gt;</code> 放置在 <code>&lt;keyword&gt;</code> 之前，那么样式规则同样会被视为无效规则：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* 无效 CSS 规则 */</span></span>
<span class="line"><span> .element { </span></span>
<span class="line"><span>     background-position: &lt;length-percentage&gt; &lt;keyword&gt; &lt;length-percentage&gt; &lt;keyword&gt; </span></span>
<span class="line"><span> } </span></span>
<span class="line"><span> </span></span>
<span class="line"><span> &lt;keyword&gt; = top | right | bottom | left</span></span></code></pre></div><p>比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> /* 无效 CSS 规则*/</span></span>
<span class="line"><span> .element { </span></span>
<span class="line"><span>     background-position: 20px left 40% top; </span></span>
<span class="line"><span> }</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1d9b2555e4344d7b5d1afa1fa0843c5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/oNPMQRL" target="_blank" rel="noreferrer">https://codepen.io/airen/full/oNPMQRL</a></p></blockquote><p>你可能会感到好奇，<code>background-position</code> 指定一个值或两个值就可以很好地设置背景图片在容器背景层中的位置了。那么，为什么还需要新增三个值和四个值的新特性呢？或者说，Web 开发者应该在什么时候使用三个值或四个值？</p><p>解答这个疑惑也并不难。CSS 的 <code>background-position</code> 属性最初只提供了一个值或两个值的语法规则，不管是一个值还是两个值，它们的作用都是用来设置背景图片在背景层中的位置。而且都是以左上角为相对计算的起始点。</p><p>也就是说，元素背景层有一个左顶点（<code>0 0</code> 位置），背景图片也有一个原始点，默认也是 <code>0 0</code> 位置，两个顶部之间产生的间距就是背景图片在元素背景层中的位置（<code>x</code> 和 <code>y</code> 轴的偏移值）。比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: 100px 200px; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>示例代码告诉我们，背景图片原点距离元素容器层原点，水平方向（<code>x</code> 轴）是 <code>100px</code>，垂直方向（<code>y</code> 轴）是 <code>200px</code>，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07acd735fafc4bfbaf75e74d70c716f3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>相当于背景图片从最左侧向右移了 <code>100px</code>，同时从最顶部向下移了 <code>200px</code> 。这对于距离左侧和距离顶部定位背景图片是很方便的。</p><p>不过，在实际开发中，很多时候，我们除了希望除距离左顶点来定位背景图片之外，还希望能根据其他几个顶点来定位背景图片，比如容器背景层的右上角、右下角和左下角等。比如下面这样的一个场景，我们希望背景图片最右侧边缘和最底部边缘距元素背景层右侧边缘和底部边缘分别是 <code>100px</code> 和 <code>200px</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8736f4cad5c42cfa932ec527e7ae58c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>以往要实现这样的背景定位是有点让人头痛的。最早期 CSS 的 <code>calc()</code> 还未得到浏览器支持的时候，开发者需要知道元素大小、背景图片大小，然后根据这些尺寸去计算出背景图片距离左侧边缘和距离顶部边缘的大小。有了 <code>calc()</code> 之后，事情稍微变得简单些。</p><p>从 <code>background-position</code> 的基础知识中我们可以知道，背景图片在定位的时候，可以使用 <code>100% 100%</code> 或 <code>right bottom</code> 将背景图片放在背景层的右下角，这个时候，使用 <code>calc()</code> 函数，从中减去需要偏移的量，即：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: calc(100% - 100px) calc(100% - 200px); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>使用 <code>background-position</code> 新特性，可以更简单地实现上面的效果，我们可以使用 <code>right 100px</code> 和 <code>bottom 200px</code> 来告诉浏览器，背景图片需要从背景层最右侧边缘向左偏移 <code>100px</code>，最底部边缘向上偏移 <code>200px</code>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-position: right 100px bottom 200px </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>相当于移动了定位的坐标，从开始的左上角变成了右下角：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003c44917801447ba0e464963e510e0a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这也意味着，<code>background-position</code> 新特性，开发者可以根据需要，指定背景图片另一侧边缘与背景层相应边缘之间的偏移量，比如：</p><ul><li><code>top &lt;length-percentage&gt;</code>，背景图片顶部边缘与背景层顶部边缘之间的偏移量是 <code>&lt;length-percentage&gt;</code>；</li><li><code>right &lt;length-percentage&gt;</code>，背景图片右侧边缘与背景层右侧边缘之间的偏移量是 <code>&lt;length-percentage&gt;</code>；</li><li><code>bottom &lt;length-percentage&gt;</code>，背景图片底部边缘与背景层底部边缘之间的偏移量是 <code>&lt;length-percentage&gt;</code>；</li><li><code>left &lt;length-percentage&gt;</code>，背景图片左侧边缘与背景层左侧边缘之间的偏移量是 <code>&lt;length-percentage&gt;</code>。</li></ul><p>换句话说，在新特性中，运用于 <code>background-position</code> 属性中的关键词（<code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code>）不再仅仅是用来计算背景图片的定位位置信息（坐标点），还可以用来指定背景图片的偏移原点，比如上面示例中 <code>right 100px bottom 200px</code>，就把偏移原点变成了右下角。</p><p>那么，这些关键词具体的含义和所起的作用应该根据其使用的场景来决定。</p><ul><li><code>top</code>：如果给出一个值或两个值，则用于计算背景图片的位置（垂直距离），计算值为 <code>0%</code>，比如 <code>background-position: top</code> 或 <code>background-position: left top</code>；否则将顶部边缘指定为下一个偏移的原点，比如 <code>background-position: left top 20%</code> 或 <code>background-position: left 20px top 200px</code>。</li><li><code>right</code>：如果给出一个或两个值，则用于计算背景图片的位置（水平距离），计算值为 <code>100%</code>，比如 <code>background-position: right</code> 或 <code>background-position: right top</code>；否则将右边缘指定为下一个偏移的原点，比如 <code>background-position: right 100px top</code> 或 <code>background-position: right 100px bottom 200px</code>。</li><li><code>bottom</code>：如果给出一个或两个值，则用于计算背景图片的位置（垂直距离），计算值为 <code>100%</code>，比如 <code>background-position: bottom</code> 或 <code>background-position: right bottom</code>；否则将底部边缘指定为下一个偏移的原点，比如 <code>background-position: left bottom 100px</code> 或 <code>background-position: left 10% bottom 30vh</code>。</li><li><code>left</code>：如果给出一个或两个值，则用于计算背景图片的位置（水平距离），计算值为 <code>0%</code>，比如 <code>background-position: left</code> 或 <code>background-position: left bottom</code>；否则将左边缘指定为下一个偏移的原点，比如 <code>background-position: left 20px bottom</code> 或 <code>background-position: left 20vw top 30%</code>。</li></ul><p>简单地说，关键词 <code>top</code>、<code>right</code>、<code>bottom</code> 和 <code>left</code> 用于 <code>background-position</code> 时，如果 <code>background-position</code> 只有一个值或两个值，那么它们则用于计算图片的位置；反之，<code>background-position</code> 有两个以上（三个或四个）值时，它们则用于指定偏移原点，不被计算为 <code>0%</code> 或 <code>100%</code>。</p><p>注意，<code>center</code> 关键词与它们不一样，它只能被用于计算位置，计算值为 <code>50%</code>，而且当 <code>background-position</code> 的值为 <code>center</code> 或 <code>center center</code>时，表示背景图片在背景层中是垂直居中的，此时，背景图片的中心原点和背景层的中心原点是重叠的。</p><p>既然和大家聊到了 <code>background-position</code> 属性，那么这里再多提一嘴，即 <code>background-position</code> 取百分比（<code>%</code>）值的计算方式。<code>background-position</code> 取百分比值时，会同时考虑容器的尺寸和背景图片的尺寸，即相对于两者尺寸做计算。</p><p><a href="https://www.w3.org/TR/css3-background/#the-background-origin" target="_blank" rel="noreferrer">W3C规范中是这样描述的</a>：</p><blockquote><p>A percentage for the horizontal offset is relative to (width of background positioning area - width of background image). A percentage for the vertical offset is relative to (height of background positioning area - height of background image), where the size of the image is the size given by ‘background-size’.</p></blockquote><p>简单地说，当背景图片尺寸（<code>background-size</code>）不做任何的重置（也就是<code>100% 100%</code>）时，水平百分比的值等于容器宽度百分比值减去背景图片宽度百分比值。垂直百分比的值等于容器高度百分比值减去背景图片高度百分比值。</p><p>即 <code>background-position</code> 取值为百分比值（<code>%</code>）时，它会先从相应的容器尺寸中减去背景图片尺寸，然后将结果值的百分比用作距左边界（或顶部）的直接偏移量。相应的计算公式如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(容器宽度 - 背景图片宽度) x (background-position-x设置的百分比值) = background-position-x 的计算值 </span></span>
<span class="line"><span>(容器高度 - 背景图片高度) x (background-position-y设置的百分比值) = background-position-y 的计算值</span></span></code></pre></div><p>即：</p><ul><li>水平方向（<code>x</code> 轴），即 <code>background-position-x</code> 的 <code>%</code> 值是相对于元素的 <code>width</code> 与背景图片的 <code>width</code> 差计算；</li><li>垂直方向（<code>y</code> 轴），即 <code>background-position-y</code> 的 <code>%</code> 值是相对于元素的 <code>height</code> 与背景图片的 <code>height</code> 差计算。</li></ul><p>特别声明，背景图片的大小将会受 <code>background-size</code> 值的影响，上面提到的图片的尺寸是指 <code>background-size</code> 的值为 <code>auto</code> 的情景下的尺寸，即背景图片的初始尺寸（原始尺寸）。 比如下面这个示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    width: 500px; </span></span>
<span class="line"><span>    height: 300px; </span></span>
<span class="line"><span>    background-position: 70% 30% </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在 <code>.element</code> 中使用像下面这样的一张背景图（图片原始尺寸：<code>280px x 180px</code>）：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dce1ceb41a6a4fa6b8f5fe7bfa18508e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>按照上面所说的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>background-position-x: 70% ⇒ (500px - 280px) x 70% = 154px </span></span>
<span class="line"><span>background-position-y: 30% ⇒ (300px - 180px) x 30% = 36px</span></span></code></pre></div><p>效果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85891baadb994d1ebe40f89617fb3e5a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/RwYBEoj" target="_blank" rel="noreferrer">https://codepen.io/airen/full/RwYBEoj</a></p></blockquote><h2 id="border-radius-对背景绘制区域的影响" tabindex="-1">border-radius 对背景绘制区域的影响 <a class="header-anchor" href="#border-radius-对背景绘制区域的影响" aria-label="Permalink to &quot;border-radius 对背景绘制区域的影响&quot;">​</a></h2><p>从《<a href="https://juejin.cn/book/7199571709102391328/section/7199845563389444099" target="_blank" rel="noreferrer">你不知道的 border-radius </a>》一节课中，我们可以获知，当元素设置了边框（<code>border-width</code>）和内距（<code>padding</code>）时，会触发嵌套圆角（<code>border-radius</code>）的现象。它会产生外圆和内圆角：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66b62fc7b51846688a4d31519d62743f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>你可以给任何一个元素的每个方向设置不同的边框和内距尺寸，如果 <code>border-radius</code> 和它们产生的差值大于 <code>0</code> 就会产生内部圆角，而且圆角的半径就等于其差值。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/352b2647e6964b9f929f5a277b12664f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>我们已然知道，背景图片可以绘制在边框区域（<code>&lt;border-box&gt;</code>）和内距区域（<code>&lt;padding-box&gt;</code> ）以及内容区域（<code>&lt;content-box&gt;</code>）。正如上图所示，当元素显式设置了 <code>border-radius</code> 时，就有可能会对背景的绘制区域产生相应的影响。</p><p>众所周知，圆角是由 <code>border-radius</code> 决定的（外圆角），而内距区域（<code>&lt;padding-box&gt;</code>）的圆角（内圆角）是由 <code>border-width</code> 和 <code>border-radius</code> 差值决定的。<a href="https://codepen.io/thebabydino/full/ZNeRbZ" target="_blank" rel="noreferrer">@Ana Tudor 在 Codepen 上制作了一个 Demo</a>，可以通过平面和3D状态来查看 <code>border-radius</code> 在这三种盒子框中，半径是如何计算的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a5e97ce2cce4e188deabc61b5ebc401~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/NWLBege" target="_blank" rel="noreferrer">https://codepen.io/airen/full/NWLBege</a></p></blockquote><p>如果将背景运用进来，并且调整同不同的 <code>border-width</code>、<code>padding</code> 和 <code>border-radius</code>，<code>background-clip</code> 在不同盒子框中的绘制效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46bd9f5e54a247d7a513ac0e515a9655~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/NWLBeve" target="_blank" rel="noreferrer">https://codepen.io/airen/full/NWLBeve</a></p></blockquote><h2 id="多背景的堆叠顺序" tabindex="-1">多背景的堆叠顺序 <a class="header-anchor" href="#多背景的堆叠顺序" aria-label="Permalink to &quot;多背景的堆叠顺序&quot;">​</a></h2><p>熟悉 CSS 层叠上下文的同学都知道，当元素触发了层叠上下文时，<a href="https://juejin.cn/book/7199571709102391328/section/7204402059225858052" target="_blank" rel="noreferrer">可以使用 z-index 来控制它的层叠顺序</a>。在同一个元素使用多背景时，它也会发生堆叠，只不过它的顺序不能使用 <code>z-index</code> 来控制，或者有一个类似 <code>background-index</code> 这样的属性。</p><p>多背景中的堆叠顺序是依赖于背景层出现的先后顺序来决定的，越早出现越在上面。或者说根据向右原则来判断，越靠左的越在上面，越靠右则越在下面。比如上面的示例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> body { </span></span>
<span class="line"><span>     background: </span></span>
<span class="line"><span>         var(--cake) center bottom 55vh / 20vh auto no-repeat, </span></span>
<span class="line"><span>         #557 var(--desk) center bottom / 80vh 80vh no-repeat; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>最先出现的是 <code>--cake</code>（蛋糕）背景层，接着是 <code>--desk</code>（桌子）背景层，因此“蛋糕”（<code>--desk</code>）背景层是在“桌子”（<code>--desk</code>）背景层上面，最底下则是背景颜色（如果有的话）：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1306a452f2ce40db921d3441ea2c7f30~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>反过来，把上面的代码调整一下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> body { </span></span>
<span class="line"><span>     background: </span></span>
<span class="line"><span>         var(--desk) center bottom / 80vh 80vh no-repeat, </span></span>
<span class="line"><span>         #557 var(--cake) center bottom 55vh / 20vh auto no-repeat; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>现在最先出现的是 <code>--desk</code>（桌子）背景层，接着是 <code>--cake</code>（蛋糕）背景层，因此“桌子”（<code>--desk</code>）背景层是在“蛋糕”（<code>--cake</code>）背景层上面，最底下则是背景颜色 <code>#557</code> 层：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe03e42b9fe548cbb863ae302b2db572~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>也就是说，多背景的堆叠顺序是像下图这样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50347b7a094242f19758ed6b87a794b9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>使用多背景时，如果多个背景的大小相同，位置也相同，则其中一个将覆盖另一个背景；如果第一个背景图片尺寸大于或等于容器尺寸，则会覆盖其他背景，在整个容器中只能看到一个背景。</p><blockquote><p>注意，在 <code>mask</code> 中也可以使用多个遮罩图片，在使用多个遮罩图时，它的堆叠顺序和 <code>background</code> 是相似的。</p></blockquote><h2 id="可用于-background-image-的新函数" tabindex="-1">可用于 background-image 的新函数 <a class="header-anchor" href="#可用于-background-image-的新函数" aria-label="Permalink to &quot;可用于 background-image 的新函数&quot;">​</a></h2><p>可用于 <code>background-image</code> 属性上，除了 <code>url()</code> 和 <code>&lt;gradient&gt;</code> （<a href="https://juejin.cn/book/7199571709102391328/section/7199845781149810727" target="_blank" rel="noreferrer">渐变图片</a>）之外，还可以使用 <code>image()</code> 、<code>element()</code> 和 <code>cross-fade()</code> 函数。这些新函数将会给 <code>background-image</code> 带来你所不熟悉的作用。</p><h3 id="image-函数" tabindex="-1">image() 函数 <a class="header-anchor" href="#image-函数" aria-label="Permalink to &quot;image() 函数&quot;">​</a></h3><p><code>image()</code> 函数除了可以像 <code>url()</code> 一样给 <code>background-image</code> 设置值之外，还有着自己特殊的能力，比如：</p><ul><li><strong>双向感知</strong> ：指定图片的方向性，<a href="https://juejin.cn/book/7161370789680250917/section/7161625525763440647" target="_blank" rel="noreferrer">类似于 HTML 元素的 dir 或 CSS 的 direction 特性</a> ；</li><li><strong>图片片段</strong> ：能够将媒体片段标识符添加到图片源上，只显示源图片的一部分，模仿 CSS Sprites（雪碧图）的方式 ；</li><li><strong>颜色回退</strong> ：指定一个纯色作为回退，以防图片加载失败或没有图片可渲染；</li><li><strong>图片类型查询</strong> ：根据浏览器的支持加载不同的类型的图片，类似于 <code>image-set()</code> 函数中的 <code>type()</code> 功能。</li></ul><p>先来看双向感知。</p><p>Web 排版（或者说布局）时会因为语言不同，其阅读方式也会有所不同，常见的有 <code>ltr</code> （英文，中文）或 <code>rtl</code>（阿拉伯文或希伯来语）。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;ul&gt; </span></span>
<span class="line"><span>    &lt;li dir=&quot;ltr&quot; lang=&quot;en&quot;&gt;Bullet is a right facing arrow on the left&lt;/li&gt; </span></span>
<span class="line"><span>    &lt;li dir=&quot;rtl&quot; lang=&quot;ar&quot;&gt;الرمز النقطي هو سهم مواجه ↢ لليمين على اليسار&lt;/li&gt; </span></span>
<span class="line"><span>&lt;/ul&gt;</span></span></code></pre></div><p>如果给 <code>li</code> 添加标识符（可以使用 <code>list-style-image</code>，也可以使用 <code>background-image</code>，还可以使用伪元素 <code>::marker</code> 来设置），这里我们使用 <code>background-image</code> 。它的效果可能像下图这样：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a32e13678fe44e5a982fcd4bedddd47~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>以往要实现上图这样的效果，可能会使用两张图片：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>li[dir=&quot;ltr&quot;] { </span></span>
<span class="line"><span>    background-image: url(ltr-arrow.png); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>li[dir=&quot;rtl&quot;] { </span></span>
<span class="line"><span>    background-image: url(rtl-arrow.png); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>或者基于伪元素 <code>::before</code>、<code>::after</code> 或 <code>::marker</code> 做水平翻转：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>li::before { </span></span>
<span class="line"><span>    content: &quot;↣&quot;; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>li[dir=&quot;rtl&quot;]::before { </span></span>
<span class="line"><span>    transform: scaleX(-1); </span></span>
<span class="line"><span>    display: inline-flex; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>如果我们使用 <code>image()</code> 函数实现上图的效果就会显得很容易：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>li { </span></span>
<span class="line"><span>    background-image: image(ltr &#39;arrow.png&#39;) </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在《<a href="https://juejin.cn/book/7199571709102391328/section/7199845718343811076" target="_blank" rel="noreferrer">如何提高图片上文本可读性？</a>》一文中，我们介绍了多种方法来提高图片上文本的可读性。这样做的原因之一就是，<strong>防止图片加载失败影响文本的可读性</strong>。以往的做法是，在 <code>img</code> 或背景图片下加一个 <code>background-color</code> ，比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>img { </span></span>
<span class="line"><span>    background-color: #444; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.element { </span></span>
<span class="line"><span>    background-color: #444; </span></span>
<span class="line"><span>    background-image: url(&#39;../images/black.png&#39;); </span></span>
<span class="line"><span>    color: #fff; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>而 <code>image()</code> 函数就具备这样的能力：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> .element { </span></span>
<span class="line"><span>     background-image: image(&quot;../images/black.png&quot;, #444); </span></span>
<span class="line"><span>     color: #fff; </span></span>
<span class="line"><span> }</span></span></code></pre></div><p>当图片 <code>black.png</code> 加载失败或无法正常渲染时，将会把 <code>#444</code> 当作一个纯色和图片作为备用图片（相当于 <code>linear-gradient(to top, #444, #444)</code> 绘制的线色图片），这样就可以确保文本仍然可阅读。</p><p>我们还可以利用该特性，像 <code>&lt;gradient&gt;</code> 一样绘制纯色的图片：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-image: image(rgb(0 0 0)); </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    /* 等同于 */ </span></span>
<span class="line"><span>    background-image: linear-gradient(to bottom, rgb(0 0 0), rgb(0 0 0)); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>还可以绘制带有一定透明度的纯色图片：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> .element { </span></span>
<span class="line"><span>     background-image: image(rgb(0 0 0 / .5)); </span></span>
<span class="line"><span>     </span></span>
<span class="line"><span>     /* 等同于 */ </span></span>
<span class="line"><span>     background-image: linear-gradient(to bottom, rgb(0 0 0 / .5), rgb(0 0 0 / .5)); </span></span>
<span class="line"><span> }</span></span></code></pre></div><p>这样一来，<a href="https://juejin.cn/book/7199571709102391328/section/7199845718343811076" target="_blank" rel="noreferrer">我们就又多了一种处理图片上文字效果的技术方案</a>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d394cdc0bdb4f36add494e02145ce03~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>上图中带透明的纯色层，就可以使用 <code>image()</code> 函数来实现，只不过，需要和 CSS 多背景结合起来一起使用：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-image: image(rgb(0 234 255 / .4)), </span></span>
<span class="line"><span>    url(&quot;avatar.svg&quot;); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>两个背景合成之后的效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132d07ee9d9640d3aaaa77bc99438391~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>是不是很完美！</p><p>那么，在 CSS 中除了使用 <code>&lt;gradient&gt;</code> 构建纯色（或带有一定透明度的纯色）背景层之外，还可以使用 <code>image()</code>来构建，它们都和 <code>background-color</code> 不一样，因为 <strong><code>background-color</code></strong> <strong>始终是在背景图片的下面</strong>。</p><p>早期的 Web 开发过程中，为了节约资源的请求，Web 开发者喜欢将很多小图片（往往是一些图标）集合在一张图片上，并且通过不同的坐标来控制显示的图片：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2012c3e939f4da498fc97d8dd889216~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.icon { </span></span>
<span class="line"><span>    width: 48px; </span></span>
<span class="line"><span>    height: 48px; </span></span>
<span class="line"><span>    background-image: url(&#39;../images/icons.png&#39;); </span></span>
<span class="line"><span>    background-repeat: no-repeat; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.icon--facebook { </span></span>
<span class="line"><span>    background-position: 0 0; </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.icon--rss { </span></span>
<span class="line"><span>    background-position: -57px 0; </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>我们把这种技术称为 <strong>CSS Sprites 技术，俗称雪碧图</strong>。 <code>image()</code> 函数也具备类似的能力。就是给 <code>image()</code> 函数中引入的图片中添加一段媒体标识符（沿着 <code>x</code> 和 <code>y</code> 轴的起点以及宽度 <code>w</code> 和高度 <code>h</code>），只在元素背景层中显示背景图片中的一部分。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-image: image(&#39;sprites.png#xywh=338,324,360,390&#39;) </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>其中 <code>sprites.png</code> 是引入的背景图片名称和相应的路径，和 <code>url()</code> 函数引入背景图片是一样的； <code>#xywh=xVal,yVal,wVal,hVal</code> 指的是媒体标识符，也就是需要显示的图片对应的 <code>x</code> 和 <code>y</code> 坐标以及宽度和高度：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c7269cb45804f408704134152c10efc~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>正如上图所示，它的使用和以前 CSS Sprites 是相似的，不同的只是使用媒体标识符来指定要显示的图片的坐标位置和大小。这也意味着，你可以通过 CSS 裁剪和加载图片的一部分。</p><blockquote><p>注意，媒体标识符 <code>#xywh=xVal,yVal,wVal,hVal</code> 是向后兼容的，如果浏览器不理解媒体标识符，媒体标识符将会被忽略， <code>image()</code> 函数引入的图片将会被视为无效。另外，<code>url()</code> 函数中也可以使用媒体标识符，只不过浏览器不理解时会显示整张图片。</p></blockquote><p><code>image()</code> 函数还有另一个新功能，即给 <code>image()</code> 传入一组不同类型的（格式不同）图片，浏览器将按照 <code>image()</code> 中的写入的图片顺序做遍历，并使用它支持的第一个图片类型：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> .element { </span></span>
<span class="line"><span>     background-image: image(&quot;avatar.avif&quot;, &quot;avatar.webp&quot;, &quot;avatar.jpg&quot;); </span></span>
<span class="line"><span> }</span></span></code></pre></div><p>比如上面的示例，如果浏览器支持 <code>.avif</code> 格式的图片，将会使用 <code>avatar.avif</code>，否则会使用 <code>avatar.webp</code>，如果浏览器也不支持 <code>.webp</code> 格式图片，则会使用 <code>avatar.jpg</code>。</p><h3 id="element-函数" tabindex="-1">element() 函数 <a class="header-anchor" href="#element-函数" aria-label="Permalink to &quot;element() 函数&quot;">​</a></h3><p><code>element()</code> 是一个非常有意思的函数，它可以将 HTML 的元素当作背景图片渲染。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>element() = element(&lt;id-selector&gt;)</span></span></code></pre></div><p>其中 <code>&lt;id-selector&gt;</code> 为 CSS 选择器中的 <code>ID</code> 选择器。具体使用的时候也像在 CSS 中使用 <code>ID</code> 选择器一样，需要在前面添加 <code>#</code> 标识符，如 <code>element(#source)</code>。 使用 <code>element()</code> 函数将某个元素（包括其后代元素）当作另一个元素的背景图片时，如果该引用的元素外观发生变化，目标元素的背景层（背景图片）也会相应发生变化。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb3a340fafa47459cf379b7a94eadc8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/OJowdyY" target="_blank" rel="noreferrer">https://codepen.io/airen/full/OJowdyY</a> （请使用 Firefox 浏览器查看 Demo）</p></blockquote><p>使用 <code>element()</code> 函数可以很容易实现视频所展示的效果：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> &lt;div id=&quot;element-source&quot; contenteditable=&quot;true&quot;&gt;Please press me to enter the content you want!&lt;/div&gt; </span></span>
<span class="line"><span> &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;  </span></span>
<span class="line"><span>.target { </span></span>
<span class="line"><span>    background-repeat: no-repeat; </span></span>
<span class="line"><span>    background-size: 100% 100%; </span></span>
<span class="line"><span>    background-image: element(#element-source); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这个示例将 <code>id</code> 为 <code>element-source</code> 当作 <code>element()</code> 函数的参数，成为目标元素 <code>.target</code> 元素的背景图片。简单地说，<code>element()</code> 可以把 HTML 中的任意元素，当作另一个元素的背景图片，而且神奇的是，只要元素修改了（样式或内容），那么对应的背景也会改变。</p><p>正如上面示例所示，<code>element()</code> 函数可以将任意 DOM 元素当作另一个元素的背景，使用该特性，开发者可以将 <code>&lt;canvas&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;video&gt;</code> 和 <code>&lt;svg&gt;</code> 元素当作背景图片，实现一些有创意的效果。比如实现像 Visual Studio Code 编辑器右侧预览的缩略图效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eae6037d01fe4ba2a36a3fd3a7b1730b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="cross-fade-函数" tabindex="-1">cross-fade() 函数 <a class="header-anchor" href="#cross-fade-函数" aria-label="Permalink to &quot;cross-fade() 函数&quot;">​</a></h3><p>2021年年底，<a href="https://jakearchibald.com/2021/dom-cross-fade/" target="_blank" rel="noreferrer">@Jake 花了很长的篇幅阐述了“目前为止为什么没有什么方法可以对任意两个 DOM 元素进行交叉淡入淡出”</a>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f52aa0baa34db99197916f27d92ab2~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>其实，CSS 中有一个 <code>cross-fade()</code> 函数可以解决该问题。</p><p><a href="https://www.w3.org/TR/css-images-4/#cross-fade-function" target="_blank" rel="noreferrer">W3C 规范是这样描述 cross-fade() 函数的</a>：</p><blockquote><p>在图片之间转换时，CSS 需要一种方法来显式引用中间图片，该中间图片是开始图片和结束图片的组合。这是通过 <code>cross-fade()</code> 函数完成的，该函数指示要组合的两个图片以及组合在过渡中的距离。</p></blockquote><p>简单地说，<code>cross-fade()</code> 可以将两个或多个图片组合在一起生成一个新的图片，并且运用于元素的背景图层上。比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.element { </span></span>
<span class="line"><span>    background-image: cross-fade( url(white.png) 0%, url(black.png) 100%); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>正如示例中代码所示，我们可以在每张图片后面显式指定一个百分比值（<code>&lt;percentage&gt;</code>），用来定义在与其他图片混合时，每个图片在不透明度方面保留了多少。</p><p><strong>百分比值必须不带引号编码，必须包含</strong> <strong><code>%</code></strong> <strong>符号，并且其值必须介于</strong> <strong><code>0%</code></strong> <strong>和</strong> <strong><code>100%</code></strong> <strong>之间，其中</strong> <strong><code>0%</code></strong> <strong>的值表示图片完全透明，而</strong> <strong><code>100%</code></strong> <strong>的值表示图片完全不透明</strong> 。如果省略了任何百分比，则将所有指定的百分比相加并从中减去 <code>100%</code>。如果结果大于 <code>0%</code>，则结果将平均分配给所有省略百分比的图片。</p><p><code>cross-fade()</code> 函数的规范允许多个图片，每个图片具有独立于其他值的透明度值。不过，情况并非总是如此。在某些浏览器中已经实现的原始语法只允许使用两张图片，而这两张图片的透明度之和正好是 <code>100%</code>。 比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> .element { </span></span>
<span class="line"><span>     background-image: cross-fade(url(white.png), url(black.png), 50%) </span></span>
<span class="line"><span> }</span></span></code></pre></div><p>这相当于设置了 <code>50%</code> 透明度（<code>opacity: .5</code>）的 <code>black.png</code> 图片盖在透明度为 <code>100%</code>（完全不透明）的 <code>white.png</code> 上。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97df2a09e80746e69f937764df2525e7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/jOvpdVW" target="_blank" rel="noreferrer">https://codepen.io/airen/full/jOvpdVW</a></p></blockquote><p>从这几个函数展示的效果可以获知，在未来（有一天所有浏览器都支持了这几个函数），<code>background-image</code> 的值不再局限于 <code>url()</code> 和 <code>&lt;gradient&gt;</code>，我们可以使用这些新特性，让运用于元素背景层的图片更丰富，更灵活。</p><blockquote><p>注意，这里提到的 <code>image()</code>、<code>element()</code> 和 <code>cross-fade()</code> 都是 <code>&lt;image&gt;</code> 的新类型，它们不局限于用在 <code>background-image</code> 属性上，只要是可运用 <code>&lt;image&gt;</code> 值类型的 CSS 属性都可以使用。</p></blockquote><h2 id="img-底部的额外-4px" tabindex="-1">img 底部的额外 4px <a class="header-anchor" href="#img-底部的额外-4px" aria-label="Permalink to &quot;img 底部的额外 4px&quot;">​</a></h2><p>使用 <code>&lt;img&gt;</code> 将图片引入 Web 上，在默认情况之下，图片浏览器中展示时，底部分有大约 <code>4px</code> 的空白间距。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b2f53cff30147d79e09ee736fac124d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/vYzabxv" target="_blank" rel="noreferrer">https://codepen.io/airen/full/vYzabxv</a></p></blockquote><p>这是一个 bug 吗?当然不是，这是默认行为。</p><p><img>元素默认情况之下是一个可替换元素（Replaced Element）。默认情况下，<img> 的底部与容器的基线（baseline）对齐。基线是像 a、 b、 c、 d 这样的字母所在的位置，这意味着像 g、j、 y 这样的字母，它们的一部分位于基线以下(顺便说一下，这些部分被称为&quot;下降&quot;)。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb321c8ca11741929102f886b156471a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这就是你在默认情况下看到的大约 <code>4px</code> 的间隙，因为图片是在基线上渲染的，为下降线留出空间。 这个问题是由于图片相对于同一行其他元素的 <code>vertical-algin</code> 造成的，我们可以很容易地通过以下方式进行纠正:</p><ul><li>更改 <code>vertical-align</code> 属性，比如显式设置非 <code>baseline</code> 的值（<code>baseline</code>是其默认值），如 <code>top</code>、<code>bottom</code> 或 <code>middle</code> 等，但该属性仅适用于内联元素；</li><li>更改 <code>display</code> 属性值，使 <code>&lt;img&gt;</code> 成为一个块元素而不是内联元素；</li><li>还有一些其他的技巧，包括设置父容器的 <code>line-height</code> 为 <code>0</code>，设置父容器的 <code>font-size</code> 为 <code>0</code>。</li></ul><p>就我个人而言，我更喜欢在重置样式表中，给 <code>img</code> 添加一个全局的样式，避免 Web 上图片底部有这个 <code>4px</code> 额外空白间距出现：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> img { </span></span>
<span class="line"><span>     display: block; </span></span>
<span class="line"><span> }</span></span></code></pre></div><p>注意，HTML 中的 <code>&lt;iframe&gt;</code> 和 <code>&lt;video&gt;</code> 元素，以及<code>&lt;img&gt;</code> 同类型的标签元素，在这些元素中同样会存在这种现象，在使用类似 <code>&lt;img&gt;</code> 可替换元素时，都建议在重置 CSS 的时候，显式设置 <code>display</code> 的值为 <code>block</code>。</p><h2 id="暗黑模式下降低图片亮度" tabindex="-1">暗黑模式下降低图片亮度 <a class="header-anchor" href="#暗黑模式下降低图片亮度" aria-label="Permalink to &quot;暗黑模式下降低图片亮度&quot;">​</a></h2><p>如果你的 Web 应用要具备暗黑模式，图片的处理也是一个不可忽略的细节。它们可能会直接影响用户的体验，太亮的图片可能会让用户感到困惑和不舒服。而且有人做过这方面相应的调查，大多数被调查的人在暗黑模式下更喜欢亮度低的图片。比如下面这张图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/684d9e582e3a4b80be25e485c74fd89f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在一个小型的应用中，你可以使用 HTML5 的 <code>&lt;picture&gt;</code> 元素，为不同模式加载不同格式图片：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;picture&gt; </span></span>
<span class="line"><span>    &lt;source srcset=&quot;settings-dark.png&quot; media=&quot;(prefers-color-scheme: dark)&quot;&gt; </span></span>
<span class="line"><span>    &lt;source srcset=&quot;settings-light.png&quot; media=&quot;(prefers-color-scheme: light), (prefers-color-scheme: no-preference)&quot;&gt; </span></span>
<span class="line"><span>    &lt;img src=&quot;settings-light.png&quot; id=&quot;screenshot&quot; loading=&quot;lazy&quot;&gt; </span></span>
<span class="line"><span>&lt;/picture&gt;</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22f635c17f4a45ef8a23eb9ff7c352df~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/PodBVdw" target="_blank" rel="noreferrer">https://codepen.io/airen/full/PodBVdw</a></p></blockquote><p>但这种使用方式对于一个中大型的 Web 应用来说，可能没有能力为 Web 应用提供两个版本的图片源。在这种情况之下，可以使用 CSS 的滤镜 <code>filter</code> 特性来降低图片的亮度，即 <strong>在暗黑模式下降低图片亮度</strong> ：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@media (prefers-color-scheme: dark) { </span></span>
<span class="line"><span>    :root { </span></span>
<span class="line"><span>        --image-filter: grayscale(50%); </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    img:not([src*=&quot;.svg&quot;]) { </span></span>
<span class="line"><span>        filter: var(--image-filter); </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>使用 <code>filter</code> 降低图片的灰度（<code>grayscale(50%)</code>），这是暗模式下降低图片亮度的一个快速解决方案，不过，这不是最佳的方案。只有在不具备为暗黑模式提供专用图片的时候才推荐它。</p><p>在暗黑模式下，同样要对 Icon 图标做相应的处理。这里来看两种情景。 先来看第一种，那就是 <code>.svg</code> 文件和其他格式的图片一样通过 <code>&lt;img&gt;</code> 标签引入。由于该 Icon 很有可能是纯色的，因此在暗黑模式下，我们可以通过 <code>filter</code> 来做 <code>dark/light</code> 之间的切换：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* dark.css */ </span></span>
<span class="line"><span>:root { </span></span>
<span class="line"><span>    --icon-filter: invert(100%);</span></span>
<span class="line"><span>    --icon-filter_hover: invert(40%); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span></span></span>
<span class="line"><span>img[src*=&quot;.svg&quot;] { </span></span>
<span class="line"><span>    filter: var(--icon-filter); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* light.css */ </span></span>
<span class="line"><span>:root { </span></span>
<span class="line"><span>    --icon-filter_hover: invert(60%); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* style.css */ </span></span>
<span class="line"><span>img[src*=&quot;.svg&quot;]:hover { </span></span>
<span class="line"><span>    filter: var(--icon-filter_hover); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b21fa461130741d9ad5ab681b99b0f1b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/airen/full/ExepMqx" target="_blank" rel="noreferrer">https://codepen.io/airen/full/ExepMqx</a></p></blockquote><p>该方法和处理图片的方法是类似的。</p><p>接下来我们再来看第二种方式。使用的 Icon 图标很有可能是内联的 SVG，针对这样的场景，我们可以使用 CSS 的<code>currentColor</code> 属性。<code>currentColor</code> 最大的特性就是可以根据 <code>color</code> 的值来决定元素的颜色，而对于 SVG 绘制的 Icon 图标，主要由 <code>path</code>、<code>circle</code>、<code>rect</code>这样的元素构成，这些元素可以通过 <code>fill</code>、<code>stroke</code>来决定填充色和描边色。</p><p>换句话说，我们在使用内联 SVG 时，将 SVG 中用到 <code>fill</code> 和 <code>stroke</code> 的属性值都强制设置成 <code>currentColor</code>，就像下面这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; stroke=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot; fill=&quot;none&quot;  stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; &gt; </span></span>
<span class="line"><span>    &lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot;/&gt; </span></span>
<span class="line"><span>    &lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;4&quot;/&gt; </span></span>
<span class="line"><span>    &lt;line x1=&quot;21.17&quot; y1=&quot;8&quot; x2=&quot;12&quot; y2=&quot;8&quot;/&gt; </span></span>
<span class="line"><span>    &lt;line x1=&quot;3.95&quot; y1=&quot;6.06&quot; x2=&quot;8.54&quot; y2=&quot;14&quot;/&gt; </span></span>
<span class="line"><span>    &lt;line x1=&quot;10.88&quot; y1=&quot;21.94&quot; x2=&quot;15.46&quot; y2=&quot;14&quot;/&gt; </span></span>
<span class="line"><span>&lt;/svg&gt;</span></span></code></pre></div><p>另外在媒体查询中设置：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@media (prefers-color-scheme: dark) { </span></span>
<span class="line"><span>    :root { </span></span>
<span class="line"><span>        --background-color: #111416; </span></span>
<span class="line"><span>        --text-color: #ccc; </span></span>
<span class="line"><span>        --link-color: #f96; </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    svg { </span></span>
<span class="line"><span>        color: var(--text-color) </span></span>
<span class="line"><span>    } </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>如果你分成多个文件的话，可能会像下面这样的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> /* dark.css */ </span></span>
<span class="line"><span> :root { </span></span>
<span class="line"><span>     --color: rgb(250, 250, 250); </span></span>
<span class="line"><span>     --background-color: rgb(5, 5, 5); </span></span>
<span class="line"><span>     --link-color: rgb(0, 188, 212); </span></span>
<span class="line"><span>     --main-headline-color: rgb(233, 30, 99); </span></span>
<span class="line"><span>     --accent-background-color: rgb(0, 188, 212); </span></span>
<span class="line"><span>     --accent-color: rgb(5, 5, 5); </span></span>
<span class="line"><span> }</span></span>
<span class="line"><span> </span></span>
<span class="line"><span> /* light.css */ </span></span>
<span class="line"><span> :root { </span></span>
<span class="line"><span>     --color: rgb(5, 5, 5); </span></span>
<span class="line"><span>     --background-color: rgb(250, 250, 250); </span></span>
<span class="line"><span>     --link-color: rgb(0, 0, 238); </span></span>
<span class="line"><span>     --main-headline-color: rgb(0, 0, 192); </span></span>
<span class="line"><span>     --accent-background-color: rgb(0, 0, 238); </span></span>
<span class="line"><span>     --accent-color: rgb(250, 250, 250); </span></span>
<span class="line"><span> } </span></span>
<span class="line"><span> </span></span>
<span class="line"><span> /* style.css */ </span></span>
<span class="line"><span> :root { </span></span>
<span class="line"><span>     color-scheme: light dark; </span></span>
<span class="line"><span> } </span></span>
<span class="line"><span> </span></span>
<span class="line"><span> body { </span></span>
<span class="line"><span>     color: var(--color); </span></span>
<span class="line"><span>     background-color: var(--background-color); </span></span>
<span class="line"><span>} </span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>svg { </span></span>
<span class="line"><span>    color: var(--color); </span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="给-jpg-图片添加透明通道" tabindex="-1">给 JPG 图片添加透明通道 <a class="header-anchor" href="#给-jpg-图片添加透明通道" aria-label="Permalink to &quot;给 JPG 图片添加透明通道&quot;">​</a></h2><p>如果你有一张很大的图片，需要在上面添加透明阴影效果。使用 <code>PNG</code> 文件又太大，但使用 <code>JPG</code> ，质量又不够好。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e655b361c4ee4bfd84f3e23523fd7c49~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>以往的技术是将一个常规的 <code>JPG</code> 和一个带有透明通道的 <code>8</code> 位 <code>PNG</code> 一起放到一个 SVG 的容器内。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fba28efaaa6642d8a87fefc19e91d3d4~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;svg preserveAspectRatio=&quot;xMinYMin&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; viewBox=&quot;0 0 560 1388&quot;&gt; </span></span>
<span class="line"><span>    &lt;defs&gt; </span></span>
<span class="line"><span>        &lt;mask id=&quot;canTopMask&quot;&gt; </span></span>
<span class="line"><span>            &lt;image width=&quot;560&quot; height=&quot;1388&quot; xlink:href=&quot;img/can-top-alpha.png&quot;&gt;&lt;/image&gt; </span></span>
<span class="line"><span>        &lt;/mask&gt; </span></span>
<span class="line"><span>    &lt;/defs&gt; </span></span>
<span class="line"><span>    &lt;image mask=&quot;url(#canTopMask)&quot; id=&quot;canTop&quot; width=&quot;560&quot; height=&quot;1388&quot; xlink:href=&quot;can-top.jpg&quot;&gt;&lt;/image&gt; </span></span>
<span class="line"><span> &lt;/svg&gt;</span></span></code></pre></div><p>在 HTML 或者 CSS 中可以调用这个 SVG 文件 ：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;img src=&quot;hero-image.svg&quot; /&gt;</span></span>
<span class="line"><span>.element {</span></span>
<span class="line"><span>    background: url(&quot;hero-image.svg&quot;) </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这种技巧可以简单理解成：在 JPG 的文件上添加了一个 PNG 的蒙层，然后输出一个 SVG 文件，并且在 HTML 或者 CSS 中按正常调用图片的方式调用 SVG 文件。</p><p>但在现代 Web 开发中，你完全可以使用 CSS 的 <code>mask</code> 来处理：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;img src=&quot;imgage.jpg&quot; /&gt;</span></span>
<span class="line"><span>img {</span></span>
<span class="line"><span>    mask-image: url(mask.png);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54a58130cdc04860be348b1dcb4ecef7~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>采用这种技术，可以给 Web 图片添加很多有创意的效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7b6f8f40682480c8dee259cfa00ed8c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/DeeDee23/full/zYNGPpq" target="_blank" rel="noreferrer">https://codepen.io/DeeDee23/full/zYNGPpq</a> （该 Demo 来源于 <a href="https://codepen.io/DeeDee23" target="_blank" rel="noreferrer">@Dion Dermott </a>）</p></blockquote><p>再来看一个<a href="https://codepen.io/Semali" target="_blank" rel="noreferrer"> @Sergey 写的一个 Demo:</a></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;div class=&quot;mask-container&quot;&gt;</span></span>
<span class="line"><span>    &lt;div class=&quot;img-bw&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span>    &lt;img class=&quot;img-color&quot; src=&quot;https://2arenanet2.staticwars.com/img/pages/home/panels/games/gw2-on.6753f436.jpg&quot; alt=&quot;&quot;&gt;&lt;/img&gt;</span></span>
<span class="line"><span>&lt;/div&gt;</span></span>
<span class="line"><span>.mask-container {</span></span>
<span class="line"><span>    position: relative;</span></span>
<span class="line"><span>    width: 100vh;</span></span>
<span class="line"><span>    max-width: 100%;</span></span>
<span class="line"><span>    margin: auto;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.img-color {</span></span>
<span class="line"><span>    display: block;</span></span>
<span class="line"><span>    max-width: 100%;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.img-bw {</span></span>
<span class="line"><span>    display: block;</span></span>
<span class="line"><span>    position: absolute;</span></span>
<span class="line"><span>    inset: 0;</span></span>
<span class="line"><span>    background-image: url(https://2arenanet2.staticwars.com/img/pages/home/panels/games/gw2-off.3100c4ff.jpg);</span></span>
<span class="line"><span>    background-size: contain;</span></span>
<span class="line"><span>    background-repeat: no-repeat;</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>    mask-image: url(https://i.ibb.co/xGR5019/mask-img.png);</span></span>
<span class="line"><span>    mask-position: 0% 0%;</span></span>
<span class="line"><span>    mask-size: cover;</span></span>
<span class="line"><span>    mask-repeat: no-repeat;</span></span>
<span class="line"><span>    transition: mask-position;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>.mask-container:hover &gt; .img-bw {</span></span>
<span class="line"><span>    animation: addColor 1200ms steps(32) forwards;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>@keyframes addColor {</span></span>
<span class="line"><span>    0% {</span></span>
<span class="line"><span>        mask-position: 0 0;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    100% {</span></span>
<span class="line"><span>        mask-position: 100% 0;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/951b4e55e3e34498b134b4a2bb3518a5~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><blockquote><p>Demo 地址：<a href="https://codepen.io/Semali/full/JjBpVZy" target="_blank" rel="noreferrer">https://codepen.io/Semali/full/JjBpVZy</a></p></blockquote><p>除此之外，@Ahmad Shadeed 在他的《<a href="https://ishadeed.com/article/aligning-logos-css/" target="_blank" rel="noreferrer">Aligning Logo Images in CSS</a>》教程中，介绍了一种“使用 CSS 混合模式去除白色背景”的方案。假设，你使用的一些 <code>JPG</code> 图片的背景是白色的，但你又期望它能变成是一个类似 <code>PNG</code> 图片，即，你不想（或不能）拿到一个透明版本的 Logo 图片，那么你可以使用 CSS 混合模式来完成。它会使用了黑魔法一样，把 <code>JPG</code> 图片中的白色背景去除掉。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.brands__item img {</span></span>
<span class="line"><span>    width: 130px;</span></span>
<span class="line"><span>    height: 75px;</span></span>
<span class="line"><span>    object-fit: contain;</span></span>
<span class="line"><span>    mix-blend-mode: multiply;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788706f5b74d4919ae02a106ac84a36b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>你也可以使用 CSS 属性选择器，只在 <code>.jpg</code> 和 <code>.png</code> 图片上应用混合模式，去除图片的白色背景：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.brands__item img[src$=&quot;.jpg&quot;],</span></span>
<span class="line"><span>.brands__item img[src$=&quot;.png&quot;] {</span></span>
<span class="line"><span>    mix-blend-mode: multiply;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>这节课主要向大家介绍了一些可用于 Web 图片的 CSS 技巧以及一些新特性。在 Web 中使用图片时，这些技巧和新特性可以使浏览器能更好地呈现图片。</p></div></div></main><footer class="VPDocFooter" data-v-2a8ae8ad data-v-d81114b5><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-d81114b5><span class="visually-hidden" id="doc-footer-aria-label" data-v-d81114b5>Pager</span><div class="pager" data-v-d81114b5><a class="VPLink link pager-link prev" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/15%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20CSS%20%E6%B8%90%E5%8F%98.html" data-v-d81114b5><!--[--><span class="desc" data-v-d81114b5>Previous page</span><span class="title" data-v-d81114b5>15 你不知道的 CSS 渐变</span><!--]--></a></div><div class="pager" data-v-d81114b5><a class="VPLink link pager-link next" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/17%20%E5%9B%BE%E7%89%87%E7%9A%84%E8%A3%81%E5%89%AA%E6%9C%AF.html" data-v-d81114b5><!--[--><span class="desc" data-v-d81114b5>Next page</span><span class="title" data-v-d81114b5>17 图片的裁剪术</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"WgeqFTj3\",\"pamphlet_advanced-guide-to-mastering-typescript_1.开篇：用正确的方式学习 typescript.md\":\"DmSUVnqT\",\"pamphlet_advanced-guide-to-mastering-typescript_10.结构化类型系统：类型兼容性判断的幕后.md\":\"CPpk4b4M\",\"pamphlet_advanced-guide-to-mastering-typescript_11.类型系统层级：从 top type 到 bottom type.md\":\"BtCmiXPa\",\"pamphlet_advanced-guide-to-mastering-typescript_12.类型里的逻辑运算：条件类型与 infer.md\":\"Ba6Xr6Yb\",\"pamphlet_advanced-guide-to-mastering-typescript_13.内置工具类型基础：别再妖魔化工具类型了！.md\":\"BjMR1D0U\",\"pamphlet_advanced-guide-to-mastering-typescript_14.反方向类型推导：用好上下文相关类型.md\":\"DB4BXZ5H\",\"pamphlet_advanced-guide-to-mastering-typescript_15.数类型：协变与逆变的比较.md\":\"BqvrUzqc\",\"pamphlet_advanced-guide-to-mastering-typescript_16.了解类型编程与类型体操的意义，找到平衡点.md\":\"DLDTwqSd\",\"pamphlet_advanced-guide-to-mastering-typescript_17.内置工具类型进阶：类型编程进阶.md\":\"24vS5r16\",\"pamphlet_advanced-guide-to-mastering-typescript_18.基础类型新成员：模板字符串类型入门.md\":\"DYe0-aI-\",\"pamphlet_advanced-guide-to-mastering-typescript_19.类型编程新范式：模板字符串工具类型进阶.md\":\"CwesZEWu\",\"pamphlet_advanced-guide-to-mastering-typescript_2.工欲善其事：打造最舒适的 typescript 开发环境.md\":\"5UU9vuIS\",\"pamphlet_advanced-guide-to-mastering-typescript_20.工程层面的类型能力：类型声明、类型指令与命名空间.md\":\"Cr3ikFql\",\"pamphlet_advanced-guide-to-mastering-typescript_21.在 react 中愉快地使用 typescript：内置类型与泛型坑位.md\":\"F35gI1sV\",\"pamphlet_advanced-guide-to-mastering-typescript_22.让 eslint 来约束你的 typescript 代码：配置与规则集介绍.md\":\"Cf6fP42Z\",\"pamphlet_advanced-guide-to-mastering-typescript_23.全链路 typescript 工具库，找到适合你的工具.md\":\"DjZjdpqu\",\"pamphlet_advanced-guide-to-mastering-typescript_24.说说 typescript 和 ecmascript 之间那些事儿.md\":\"DjiHD1ZL\",\"pamphlet_advanced-guide-to-mastering-typescript_25.装饰器与反射元数据：了解装饰器基本原理与应用.md\":\"DO5tyI8n\",\"pamphlet_advanced-guide-to-mastering-typescript_26.控制反转与依赖注入：基于装饰器的依赖注入实现.md\":\"D5PoZEUp\",\"pamphlet_advanced-guide-to-mastering-typescript_27.tsconfig 全解（上）：构建相关配置.md\":\"BOQBTyWY\",\"pamphlet_advanced-guide-to-mastering-typescript_28.tsconfig 全解（下）：检查相关、工程相关配置.md\":\"cZs2hsd1\",\"pamphlet_advanced-guide-to-mastering-typescript_29.基于 prisma _ nestjs 的 node api ：前置知识储备.md\":\"R8XpGQKL\",\"pamphlet_advanced-guide-to-mastering-typescript_3.进入类型的世界：理解原始类型与对象类型.md\":\"CNT96xXR\",\"pamphlet_advanced-guide-to-mastering-typescript_30.基于 prisma _ nestjs 的 node api ：项目开发与基于 heroku 部署.md\":\"W4A5Dz0F\",\"pamphlet_advanced-guide-to-mastering-typescript_31.玩转 typescript ast：ast checker 与 codemod.md\":\"BzFvNbXa\",\"pamphlet_advanced-guide-to-mastering-typescript_32.感谢相伴：是结束，也是开始.md\":\"BXp2k-oy\",\"pamphlet_advanced-guide-to-mastering-typescript_33.漫谈篇：面试中的 typescript.md\":\"DRU5c8cz\",\"pamphlet_advanced-guide-to-mastering-typescript_4.掌握字面量类型与枚举，让你的类型再精确一些.md\":\"6S9h-Nvw\",\"pamphlet_advanced-guide-to-mastering-typescript_5.函数与 class 中的类型：详解函数重载与面向对象.md\":\"DyLPZnlB\",\"pamphlet_advanced-guide-to-mastering-typescript_6.探秘内置类型：any、unknown、never 与类型断言.md\":\"eRZ9l8MV\",\"pamphlet_advanced-guide-to-mastering-typescript_7.类型编程好帮手：typescript 类型工具（上）.md\":\"BdsbkQCD\",\"pamphlet_advanced-guide-to-mastering-typescript_8.类型编程好帮手：typescript 类型工具（下）.md\":\"BAcNv8Oj\",\"pamphlet_advanced-guide-to-mastering-typescript_9.类型编程基石：typescript 中无处不在的泛型.md\":\"CcaFpoZY\",\"pamphlet_babel 插件通关秘籍_1 babel 的介绍.md\":\"BCiYSdME\",\"pamphlet_babel 插件通关秘籍_10 babel 插件和 preset.md\":\"CPZPwTUD\",\"pamphlet_babel 插件通关秘籍_11 babel 插件的单元测试.md\":\"CZ3NRLP9\",\"pamphlet_babel 插件通关秘籍_12 babel 的内置功能（上）.md\":\"BeW2CIMw\",\"pamphlet_babel 插件通关秘籍_13 babel 的内置功能（下）.md\":\"BVhrGvJw\",\"pamphlet_babel 插件通关秘籍_14 babel 配置的原理.md\":\"BI4bH9ST\",\"pamphlet_babel 插件通关秘籍_15 工具介绍-vscode debugger 的使用.md\":\"VYS8ZZI7\",\"pamphlet_babel 插件通关秘籍_16 实战案例-自动埋点.md\":\"D1jWWup4\",\"pamphlet_babel 插件通关秘籍_17 实战案例-自动国际化.md\":\"CMeaePGb\",\"pamphlet_babel 插件通关秘籍_18 实战案例-自动生成 api 文档.md\":\"BUIEbg5O\",\"pamphlet_babel 插件通关秘籍_19 实战案例-linter.md\":\"Cy5QBXKO\",\"pamphlet_babel 插件通关秘籍_2 babel 的编译流程.md\":\"DlNsu0RJ\",\"pamphlet_babel 插件通关秘籍_20 实战案例-类型检查.md\":\"CdYAY5Dw\",\"pamphlet_babel 插件通关秘籍_21 实战案例-压缩混淆.md\":\"la52pIoU\",\"pamphlet_babel 插件通关秘籍_22 实战案例-js 解释器.md\":\"Cxvse2Y_\",\"pamphlet_babel 插件通关秘籍_23 实战案例-模块遍历.md\":\"BJDm_EVZ\",\"pamphlet_babel 插件通关秘籍_24 babel macros.md\":\"DlUgah5e\",\"pamphlet_babel 插件通关秘籍_25 如何调试babel源码.md\":\"oE8OVdf6\",\"pamphlet_babel 插件通关秘籍_26 手写babel-思路篇.md\":\"DGm6U5Rs\",\"pamphlet_babel 插件通关秘籍_27 手写babel-parser 篇.md\":\"Lia4yQt_\",\"pamphlet_babel 插件通关秘籍_28 手写babel-traverse 篇.md\":\"BCT9YNMa\",\"pamphlet_babel 插件通关秘籍_29 手写babel-traverse -- path篇.md\":\"BMBp3o8v\",\"pamphlet_babel 插件通关秘籍_3 babel 的 ast.md\":\"Bpx25q1R\",\"pamphlet_babel 插件通关秘籍_30 手写babel-traverse -- scope篇.md\":\"ChIoA4m3\",\"pamphlet_babel 插件通关秘籍_31 手写babel-generator篇.md\":\"BphaAeSj\",\"pamphlet_babel 插件通关秘籍_32 手写babel-core篇.md\":\"BI3H0ID1\",\"pamphlet_babel 插件通关秘籍_33 手写babel-cli篇.md\":\"Ca1643lD\",\"pamphlet_babel 插件通关秘籍_34 手写babel-总结.md\":\"B2qSQn9B\",\"pamphlet_babel 插件通关秘籍_35 小册总结.md\":\"Doz__-Sw\",\"pamphlet_babel 插件通关秘籍_36 加餐-会了babel 插件-就会写prettier插件.md\":\"D0cKa7b9\",\"pamphlet_babel 插件通关秘籍_4 babel 的 api.md\":\"DknOTeIS\",\"pamphlet_babel 插件通关秘籍_5 实战案例-插入函数调用参数.md\":\"RV6XhBi1\",\"pamphlet_babel 插件通关秘籍_6 js parser 的历史.md\":\"CLHj8dH1\",\"pamphlet_babel 插件通关秘籍_7 traverse 的 path、scope、visitor.md\":\"CCOJYvtn\",\"pamphlet_babel 插件通关秘籍_8 generator 和 sourcemap 的奥秘.md\":\"r0_u5Iom\",\"pamphlet_babel 插件通关秘籍_9 code-frame 和代码高亮原理.md\":\"BFGRHeO1\",\"pamphlet_webgl 入门与实践_1 初级入门 --- 认识 webgl.md\":\"D2ovrDOX\",\"pamphlet_webgl 入门与实践_10 中级进阶 --- 神说要有光，于是就有了光：给物体添加环境光。.md\":\"BHu-zINj\",\"pamphlet_webgl 入门与实践_11 中级进阶 --- 冯氏光照模型：为物体增加漫反射效果.md\":\"CAgnIaqi\",\"pamphlet_webgl 入门与实践_12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果.md\":\"BgbMmqf-\",\"pamphlet_webgl 入门与实践_13  中级进阶 --- 深入理解 glsl 语法.md\":\"CRuIZ5p5\",\"pamphlet_webgl 入门与实践_14 中级进阶 --- webgl 与数学：我们需要哪些数学知识？.md\":\"BZnj4d22\",\"pamphlet_webgl 入门与实践_15 中级进阶 --- 数学：点、向量、矩阵。.md\":\"Ct2vI7Y-\",\"pamphlet_webgl 入门与实践_16 中级进阶 ---  通用数学库的 javascript 实现。.md\":\"JfbUq6ma\",\"pamphlet_webgl 入门与实践_17 中级进阶 --- webgl 坐标系.md\":\"BpskpQ68\",\"pamphlet_webgl 入门与实践_18 中级进阶 --- 坐标系变换：基本变换原理与算法实现.md\":\"Dnt_phau\",\"pamphlet_webgl 入门与实践_19 中级进阶 --- 坐标系变换：模型空间变换到世界空间.md\":\"C18a_aev\",\"pamphlet_webgl 入门与实践_2 初级入门 --- 从一个点开始：掌握 webgl 的编程要素.md\":\"B-OaeGXq\",\"pamphlet_webgl 入门与实践_20 中级进阶 --- 坐标系变换：世界空间变换到观察空间.md\":\"D0csI_Ib\",\"pamphlet_webgl 入门与实践_21 中级进阶 --- 坐标系变换：观察空间变换到裁剪空间.md\":\"D2G5mbtT\",\"pamphlet_webgl 入门与实践_22 深入研究 --- 更高级的旋转：欧拉角、四元数。.md\":\"t7KrOiMo\",\"pamphlet_webgl 入门与实践_23 深入研究 --- 四元数的应用：使用鼠标控制模型的旋转.md\":\"BGNEknIQ\",\"pamphlet_webgl 入门与实践_24 深入研究 --- css 与 3d 之 transform.md\":\"DYLdHPVc\",\"pamphlet_webgl 入门与实践_25 深入研究 --- css 与 3d 之 perspective.md\":\"DxcAYtiJ\",\"pamphlet_webgl 入门与实践_26 深入研究 --- 数学库在 css 的 3d 动画中扮演的重要角色.md\":\"Bm60DMfV\",\"pamphlet_webgl 入门与实践_27 深入探究 --- 层级建模：行走的机器人.md\":\"CuEFUDGr\",\"pamphlet_webgl 入门与实践_28 深入研究 --- 使用立方体纹理绘制天空盒.md\":\"DDpfA-Ae\",\"pamphlet_webgl 入门与实践_29 深入研究 --- 混合效果.md\":\"CviXlm4q\",\"pamphlet_webgl 入门与实践_3 初级入门 --- 绘制三角形：学会使用缓冲区、了解 webgl 中的基本图形元素.md\":\"DpNJ8f-4\",\"pamphlet_webgl 入门与实践_30 深入研究 --- 帧缓冲.md\":\"cEjOgihf\",\"pamphlet_webgl 入门与实践_31 高级应用 --- 3d模型的拾取原理与实现.md\":\"CQAysc0G\",\"pamphlet_webgl 入门与实践_32 高级应用 --- 魔法 shader：火焰效果的原理与实现.md\":\"BLFdEght\",\"pamphlet_webgl 入门与实践_33 结束了吗？一切刚刚开始.md\":\"-0Rqe-la\",\"pamphlet_webgl 入门与实践_4 初级入门 --- 基本图元绘制：线段.md\":\"YLKfKb69\",\"pamphlet_webgl 入门与实践_5 初级入门 --- 绘制渐变三角形：深入理解缓冲区.md\":\"9MSbB5o6\",\"pamphlet_webgl 入门与实践_6 初级入门 --- 画个矩形：用基本图形构建平面.md\":\"DJqGr6JB\",\"pamphlet_webgl 入门与实践_7 初级入门 --- 纹理贴图：为形体穿上外衣.md\":\"CjKl8T9H\",\"pamphlet_webgl 入门与实践_8 初级入门 --- 绘制立方体、球体、椎体：如何用基本图形构建规则形体.md\":\"5CBoqfv9\",\"pamphlet_webgl 入门与实践_9 初级入门 --- 绘制多个物体：进一步封装绘制方法.md\":\"DYpvsZgk\",\"pamphlet_webpack5_1 重新认识 webpack：旧时代的破局者.md\":\"pJf7ZKbI\",\"pamphlet_webpack5_10 深入理解图像加载原理与最佳实践.md\":\"Dtrgvq-q\",\"pamphlet_webpack5_11 深入理解 webpack 核心配置结构.md\":\"Bs70fBmn\",\"pamphlet_webpack5_12 构建性能：分享 7 款常用的性能分析工具.md\":\"CcXCtIha\",\"pamphlet_webpack5_13 如何使用 webpack 持久化缓存大幅提升构建性能？.md\":\"CxYeeE_e\",\"pamphlet_webpack5_14 webpack 都有哪些实现并行构建的方法？.md\":\"B80y9fPd\",\"pamphlet_webpack5_15 有哪些值得学习的构建性能极致优化技巧？.md\":\"Doslxswz\",\"pamphlet_webpack5_16 如何正确使用 splitchunks提升应用性能？.md\":\"BAYCCY_0\",\"pamphlet_webpack5_17 不止 terser：揭秘代码压缩的门门道道.md\":\"ZtA2qgDs\",\"pamphlet_webpack5_18 还有哪些值得学习的应用性能极致优化技巧？.md\":\"CL6HdaYi\",\"pamphlet_webpack5_19 loader 开发基础：从开源项目学到的 loader 开发技巧.md\":\"UQNk86gS\",\"pamphlet_webpack5_2 如何理解 webpack 配置底层结构逻辑？.md\":\"D0Y3VOoz\",\"pamphlet_webpack5_20 loader 开发进阶：如何用好 loader 扩展开发工具？.md\":\"BooQ2aG3\",\"pamphlet_webpack5_21 插件开发基础：实例剖析插件基本形态与架构逻辑.md\":\"Bg-hdlrs\",\"pamphlet_webpack5_22 插件开发进阶：如何提升插件健壮性？.md\":\"C7u9PrcF\",\"pamphlet_webpack5_23 插件架构：hook 体系是如何影响 webpack 架构的？.md\":\"0-yZvOEd\",\"pamphlet_webpack5_24 init、make、seal：真正读懂 webpack 核心流程.md\":\"CxgffTGl\",\"pamphlet_webpack5_25 dependency graph：如何管理模块间依赖？.md\":\"DtmNmFon\",\"pamphlet_webpack5_26 chunk：三种产物的打包逻辑.md\":\"Du0flIVd\",\"pamphlet_webpack5_27 runtime：模块编译打包及运行时逻辑.md\":\"Dkmfds2n\",\"pamphlet_webpack5_28 tree-shaking：如何删除无用模块导出？.md\":\"DkCyqphG\",\"pamphlet_webpack5_29 sourcemap：源码映射原理与应用技巧.md\":\"Dxaamzlk\",\"pamphlet_webpack5_3 如何借助 babel_ts_eslint 构建现代 js 工程环境？.md\":\"DVASA9qF\",\"pamphlet_webpack5_30 hmr：如何动态替换页面代码？.md\":\"xNyJg7Cr\",\"pamphlet_webpack5_4 如何借助预处理器、postcss 等构建现代 css 工程环境？.md\":\"DyHWH_uo\",\"pamphlet_webpack5_5 如何搭建 vue 全栈开发环境？.md\":\"CwIoe6Md\",\"pamphlet_webpack5_6 如何搭建 react 全栈开发环境？.md\":\"Bl-nc59A\",\"pamphlet_webpack5_7 使用 webpack 构建 npm library 的正确方式.md\":\"aiCSGqMb\",\"pamphlet_webpack5_8 使用 webpack 构建微前端应用.md\":\"CL0PPv_S\",\"pamphlet_webpack5_9 如何借助 webpack 开发 pwa、node、electron 应用？.md\":\"Ddd0833k\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略.md\":\"CyNPbggH\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_10 快慢指针与多指针——玩转链表复杂操作.md\":\"hGBDf9KH\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_11 姿势特别的链表——环形链表专题.md\":\"Bv8Brfms\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_12 栈与队列怎么玩（上）.md\":\"53YPPWKL\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_13 栈与队列怎么玩（下）.md\":\"DCnQGpnI\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_14 遍历专题：dfs 与 bfs.md\":\"Y25TC8E3\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_15 场景化解读：递归与回溯思想在真题中的应用.md\":\"DRXfQflY\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_16 二叉树真题归纳与解读.md\":\"DxLbuz6k\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_17 特殊的二叉树——二叉搜索树专题.md\":\"B6KzKVpN\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_18 特殊的二叉树——平衡二叉树专题.md\":\"Bccc2X9O\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_19 特殊的二叉树——堆结构及其在排序中的应用.md\":\"CLoDOhdn\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_2 快速上手——从0到1掌握算法面试需要的数据结构（一）.md\":\"CLRytReU\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_20 排序算法专题（上）.md\":\"CcvhbS5w\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_21 排序算法专题（下）.md\":\"CNPLnWmZ\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_22 普通人也能吃透的动态规划思想专题（上）.md\":\"CLAF5i97\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_23 普通人也能吃透的动态规划思想专题（下）.md\":\"Dg3lERrT\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_24 大厂真题训练与解读——微软真题.md\":\"CIrqVPM5\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_25 大厂真题训练与解读——google 真题.md\":\"8p1tDgJZ\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_26 大厂真题训练与解读——腾讯真题.md\":\"CHMy4KEH\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_27 大厂真题训练与解读——头条真题.md\":\"DmMGtNYP\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_28 思维课：算法面试的评价逻辑.md\":\"D10rVhnU\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_3 快速上手——从0到1掌握算法面试需要的数据结构（二）.md\":\"BNk9YrBg\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_4 快速上手——从0到1掌握算法面试需要的数据结构（三）.md\":\"Den1pt7l\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_5 递归初相见——二叉树递归遍历的三种姿势.md\":\"BPUEN0Mv\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_6 算法的衡量——轻松理解时间复杂度与空间复杂度.md\":\"DqNE9OjF\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_7 数组的应用——真题归纳与解读.md\":\"UL4HCZ0C\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_8 字符串的应用——真题归纳与解读.md\":\"C717H1nR\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_9 链表的应用——真题归纳与解读.md\":\"BMSkkG03\",\"pamphlet_基于 vite 的组件库工程化实战_1 开篇词：学习前端工程化就从搭建组件库开始.md\":\"1kzkPbQD\",\"pamphlet_基于 vite 的组件库工程化实战_10 开发许可证：维护自己的版权、拒绝拿来党.md\":\"Bks_E7iO\",\"pamphlet_基于 vite 的组件库工程化实战_11 组件发布： 建立语义化版本与提交软件包仓库 npm.md\":\"CWDDx6sX\",\"pamphlet_基于 vite 的组件库工程化实战_12 建立组件库生态： 利用 monorepo 方式管理组件库生态.md\":\"D4c0KsJD\",\"pamphlet_基于 vite 的组件库工程化实战_13 按需引入实现组件库的按需引入功能.md\":\"YsaPaNC3\",\"pamphlet_基于 vite 的组件库工程化实战_14 文档部署： 用 vercel 部署你的线上文档.md\":\"KzJeJ9yz\",\"pamphlet_基于 vite 的组件库工程化实战_15 readme： 编写标准的 readme.md\":\"D9wuhH8V\",\"pamphlet_基于 vite 的组件库工程化实战_16 品质保证：覆盖率测试报告.md\":\"CKtSsqBE\",\"pamphlet_基于 vite 的组件库工程化实战_17 社区参与： 如何管理社区的 pullrequest？.md\":\"BJQ0SfSk\",\"pamphlet_基于 vite 的组件库工程化实战_18 敏捷开发： 用 github 看板和 issue 管理需求.md\":\"nhPdqAGI\",\"pamphlet_基于 vite 的组件库工程化实战_19 架构复用： 创建 cli 工具提高研发体验.md\":\"Bo5q2C6R\",\"pamphlet_基于 vite 的组件库工程化实战_2 mvp原型系统： 将组件封装为组件库.md\":\"4JiADEa2\",\"pamphlet_基于 vite 的组件库工程化实战_20 融入开源生态： 编写 npm init 项目让用户更方便.md\":\"C-sFfQk6\",\"pamphlet_基于 vite 的组件库工程化实战_21 加餐1：类型系统：导出组件库的类型定义.md\":\"L91NiBEc\",\"pamphlet_基于 vite 的组件库工程化实战_22 结语｜当好项目的开路先锋.md\":\"CND4cG-y\",\"pamphlet_基于 vite 的组件库工程化实战_3 css样式：用unocss实现原子化css.md\":\"YFaJcaWa\",\"pamphlet_基于 vite 的组件库工程化实战_4 文档建设：创建具备demo示例功能的文档网站.md\":\"ClDnErko\",\"pamphlet_基于 vite 的组件库工程化实战_5 单元测试(一)： 使用jest进行前端单元测试.md\":\"ltLxlDII\",\"pamphlet_基于 vite 的组件库工程化实战_6 单元测试 (二)： 搭建vitest的单元测试环境.md\":\"DJhJy5Ze\",\"pamphlet_基于 vite 的组件库工程化实战_7 规范化： eslint _ prettier _ husky.md\":\"Wgaob5Lj\",\"pamphlet_基于 vite 的组件库工程化实战_8 软件包封装： 如何发布兼容多种 js 模块标准的软件包？.md\":\"D47wFuGZ\",\"pamphlet_基于 vite 的组件库工程化实战_9 持续集成 ci： 基于 github action 的回归验证.md\":\"B1-iIV0X\",\"pamphlet_玩转css艺术之美_1.准备篇：学前准备.md\":\"BYR6FIpP\",\"pamphlet_玩转css艺术之美_10.技巧篇：背景与遮罩.md\":\"MiFT5noe\",\"pamphlet_玩转css艺术之美_11.技巧篇：阴影与滤镜.md\":\"BqIvzkxX\",\"pamphlet_玩转css艺术之美_12.技巧篇：变换与动画.md\":\"DrJbXnuN\",\"pamphlet_玩转css艺术之美_13.实战篇：实战大操作-切换控件.md\":\"BpOoAw29\",\"pamphlet_玩转css艺术之美_14.实战篇：实战大操作-表单控件.md\":\"q-9ZN3MO\",\"pamphlet_玩转css艺术之美_15.实战篇：实战大操作-变量控件.md\":\"qNtX4TaP\",\"pamphlet_玩转css艺术之美_16.总结篇：玩转css艺术之美.md\":\"w7SagsOO\",\"pamphlet_玩转css艺术之美_2.基础篇：浏览器.md\":\"Bx0p4mMv\",\"pamphlet_玩转css艺术之美_3.进阶篇：回流重绘.md\":\"CoX_ZkJn\",\"pamphlet_玩转css艺术之美_4.基础篇：盒模型.md\":\"DmLMPeQB\",\"pamphlet_玩转css艺术之美_5.基础篇：样式计算.md\":\"2BNBlFHk\",\"pamphlet_玩转css艺术之美_6.进阶篇：布局样式.md\":\"D_SbEab8\",\"pamphlet_玩转css艺术之美_7.进阶篇：函数计算.md\":\"SvQsTQ6A\",\"pamphlet_玩转css艺术之美_8.进阶篇：变量计算.md\":\"DBVCvZNd\",\"pamphlet_玩转css艺术之美_9.技巧篇：选择器.md\":\"DSdSa4WE\",\"pamphlet_防御式 css 精讲_1 推荐序｜克军：写好 css 是需要经验的.md\":\"H88tsFw8\",\"pamphlet_防御式 css 精讲_10 你不知道的 border-radius.md\":\"qLnpjZEZ\",\"pamphlet_防御式 css 精讲_11 web 中的阴影.md\":\"Dh9JO6xZ\",\"pamphlet_防御式 css 精讲_12 web 中的边框.md\":\"DwDVNMHg\",\"pamphlet_防御式 css 精讲_13 响应式图片：防止图片的拉伸或挤压.md\":\"CGHn1GIC\",\"pamphlet_防御式 css 精讲_14 如何提高图片上文本的可读性？.md\":\"DkSkR0WI\",\"pamphlet_防御式 css 精讲_15 你不知道的 css 渐变.md\":\"j1SPdKAx\",\"pamphlet_防御式 css 精讲_16 web 图片：你不应该遗忘的 css 技巧.md\":\"CVkShDQu\",\"pamphlet_防御式 css 精讲_17 图片的裁剪术.md\":\"D6XQpm42\",\"pamphlet_防御式 css 精讲_18  重新思考 web 中的裁剪：css 还是 svg？.md\":\"DDDm5Om9\",\"pamphlet_防御式 css 精讲_19 css 如何改善滚动体验.md\":\"BS7rx-U_\",\"pamphlet_防御式 css 精讲_2 如何根据 ui 形式选择视觉盒模型？.md\":\"CRbx0C9A\",\"pamphlet_防御式 css 精讲_20 美化滚动条 ui：自定义滚动条 ui.md\":\"DIRWpXBO\",\"pamphlet_防御式 css 精讲_21 css 的滚动捕捉.md\":\"DARpjRPQ\",\"pamphlet_防御式 css 精讲_22 溢出常见问题与排查.md\":\"C17GCquS\",\"pamphlet_防御式 css 精讲_23 易碎的容器盒子：避免使用固定尺寸和长内容设置.md\":\"XgD0q8o_\",\"pamphlet_防御式 css 精讲_24 使用逻辑属性来替代物理属性.md\":\"olctqkw2\",\"pamphlet_防御式 css 精讲_25 多语言 web 应用需要注意的细节.md\":\"ClgJhi3U\",\"pamphlet_防御式 css 精讲_26 条件 css 之 @规则和 css 选择器.md\":\"DNiRijC-\",\"pamphlet_防御式 css 精讲_27 条件 css 之 css 属性值和 css 函数.md\":\"BMiQ3oA8\",\"pamphlet_防御式 css 精讲_28 css 的黑魔法.md\":\"7P3U2zAH\",\"pamphlet_防御式 css 精讲_3 flexbox 和 grid 中的换行.md\":\"DV1yOOQD\",\"pamphlet_防御式 css 精讲_4 flexbox 和 grid 中的最小内容尺寸.md\":\"P-N8vHxm\",\"pamphlet_防御式 css 精讲_5 布局中的滚动失效和默认拉伸.md\":\"CgH7nEaH\",\"pamphlet_防御式 css 精讲_6 固定网格轨道尺寸给 web 布局带来的局限性.md\":\"D_EsDEnG\",\"pamphlet_防御式 css 精讲_7 如何灵活设置元素之间的间距？.md\":\"We3s-nL4\",\"pamphlet_防御式 css 精讲_8 position sticky 失效与修复.md\":\"BlbsM2-f\",\"pamphlet_防御式 css 精讲_9  z-index 失效与修复.md\":\"CAeCZ8AM\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"刘云露\",\"description\":\"一些有意思的东西\",\"base\":\"/books/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"小册\",\"items\":[{\"text\":\"Webpack5 核心原理与应用实践\",\"link\":\"/pamphlet/webpack5/1 重新认识 Webpack：旧时代的破局者.md\"},{\"text\":\"TypeScript全面进阶指南\",\"link\":\"/pamphlet/advanced-guide-to-mastering-typeScript/1.开篇：用正确的方式学习 TypeScript.md\"},{\"text\":\"玩转css艺术之美\",\"link\":\"/pamphlet/玩转css艺术之美/1.准备篇：学前准备.md\"},{\"text\":\"防御式 CSS 精讲\",\"link\":\"/pamphlet/防御式 CSS 精讲/1 推荐序｜克军：写好 CSS 是需要经验的.md\"},{\"text\":\"基于 Vite 的组件库工程化实战\",\"link\":\"/pamphlet/基于 Vite 的组件库工程化实战/1 开篇词：学习前端工程化就从搭建组件库开始.md\"},{\"text\":\"前端算法与数据结构面试：底层逻辑解读与大厂真题训练\",\"link\":\"/pamphlet/前端算法与数据结构面试：底层逻辑解读与大厂真题训练/1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略.md\"},{\"text\":\"Babel 插件通关秘籍\",\"link\":\"/pamphlet/Babel 插件通关秘籍/1 Babel 的介绍.md\"},{\"text\":\"WebGL 入门与实践\",\"link\":\"/pamphlet/WebGL 入门与实践/1 初级入门 --- 认识 WebGL.md\"}]}],\"sidebar\":{\"/pamphlet/webpack5/\":{\"base\":\"/pamphlet/webpack5/\",\"items\":[{\"text\":\"1 重新认识 Webpack：旧时代的破局者\",\"link\":\"1 重新认识 Webpack：旧时代的破局者\"},{\"text\":\"2 如何理解 Webpack 配置底层结构逻辑？\",\"link\":\"2 如何理解 Webpack 配置底层结构逻辑？\"},{\"text\":\"3 如何借助 Babel+TS+ESLint 构建现代 JS 工程环境？\",\"link\":\"3 如何借助 Babel+TS+ESLint 构建现代 JS 工程环境？\"},{\"text\":\"4 如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？\",\"link\":\"4 如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？\"},{\"text\":\"5 如何搭建 Vue 全栈开发环境？\",\"link\":\"5 如何搭建 Vue 全栈开发环境？\"},{\"text\":\"6 如何搭建 React 全栈开发环境？\",\"link\":\"6 如何搭建 React 全栈开发环境？\"},{\"text\":\"7 使用 Webpack 构建 NPM Library 的正确方式\",\"link\":\"7 使用 Webpack 构建 NPM Library 的正确方式\"},{\"text\":\"8 使用 Webpack 构建微前端应用\",\"link\":\"8 使用 Webpack 构建微前端应用\"},{\"text\":\"9 如何借助 Webpack 开发 PWA、Node、Electron 应用？\",\"link\":\"9 如何借助 Webpack 开发 PWA、Node、Electron 应用？\"},{\"text\":\"10 深入理解图像加载原理与最佳实践\",\"link\":\"10 深入理解图像加载原理与最佳实践\"},{\"text\":\"11 深入理解 Webpack 核心配置结构\",\"link\":\"11 深入理解 Webpack 核心配置结构\"},{\"text\":\"12 构建性能：分享 7 款常用的性能分析工具\",\"link\":\"12 构建性能：分享 7 款常用的性能分析工具\"},{\"text\":\"13 如何使用 Webpack 持久化缓存大幅提升构建性能？\",\"link\":\"13 如何使用 Webpack 持久化缓存大幅提升构建性能？\"},{\"text\":\"14 Webpack 都有哪些实现并行构建的方法？\",\"link\":\"14 Webpack 都有哪些实现并行构建的方法？\"},{\"text\":\"15 有哪些值得学习的构建性能极致优化技巧？\",\"link\":\"15 有哪些值得学习的构建性能极致优化技巧？\"},{\"text\":\"16 如何正确使用 SplitChunks提升应用性能？\",\"link\":\"16 如何正确使用 SplitChunks提升应用性能？\"},{\"text\":\"17 不止 Terser：揭秘代码压缩的门门道道\",\"link\":\"17 不止 Terser：揭秘代码压缩的门门道道\"},{\"text\":\"18 还有哪些值得学习的应用性能极致优化技巧？\",\"link\":\"18 还有哪些值得学习的应用性能极致优化技巧？\"},{\"text\":\"19 Loader 开发基础：从开源项目学到的 Loader 开发技巧\",\"link\":\"19 Loader 开发基础：从开源项目学到的 Loader 开发技巧\"},{\"text\":\"20 Loader 开发进阶：如何用好 Loader 扩展开发工具？\",\"link\":\"20 Loader 开发进阶：如何用好 Loader 扩展开发工具？\"},{\"text\":\"21 插件开发基础：实例剖析插件基本形态与架构逻辑\",\"link\":\"21 插件开发基础：实例剖析插件基本形态与架构逻辑\"},{\"text\":\"22 插件开发进阶：如何提升插件健壮性？\",\"link\":\"22 插件开发进阶：如何提升插件健壮性？\"},{\"text\":\"23 插件架构：Hook 体系是如何影响 Webpack 架构的？\",\"link\":\"23 插件架构：Hook 体系是如何影响 Webpack 架构的？\"},{\"text\":\"24 Init、Make、Seal：真正读懂 Webpack 核心流程\",\"link\":\"24 Init、Make、Seal：真正读懂 Webpack 核心流程\"},{\"text\":\"25 Dependency Graph：如何管理模块间依赖？\",\"link\":\"25 Dependency Graph：如何管理模块间依赖？\"},{\"text\":\"26 Chunk：三种产物的打包逻辑\",\"link\":\"26 Chunk：三种产物的打包逻辑\"},{\"text\":\"27 Runtime：模块编译打包及运行时逻辑\",\"link\":\"27 Runtime：模块编译打包及运行时逻辑\"},{\"text\":\"28 Tree-shaking：如何删除无用模块导出？\",\"link\":\"28 Tree-shaking：如何删除无用模块导出？\"},{\"text\":\"29 Sourcemap：源码映射原理与应用技巧\",\"link\":\"29 Sourcemap：源码映射原理与应用技巧\"},{\"text\":\"30 HMR：如何动态替换页面代码？\",\"link\":\"30 HMR：如何动态替换页面代码？\"}]},\"/pamphlet/advanced-guide-to-mastering-typeScript/\":{\"base\":\"/pamphlet/advanced-guide-to-mastering-typeScript/\",\"items\":[{\"text\":\"1.开篇：用正确的方式学习 TypeScript\",\"link\":\"1.开篇：用正确的方式学习 TypeScript\"},{\"text\":\"2.工欲善其事：打造最舒适的 TypeScript 开发环境\",\"link\":\"2.工欲善其事：打造最舒适的 TypeScript 开发环境\"},{\"text\":\"3.进入类型的世界：理解原始类型与对象类型\",\"link\":\"3.进入类型的世界：理解原始类型与对象类型\"},{\"text\":\"4.掌握字面量类型与枚举，让你的类型再精确一些\",\"link\":\"4.掌握字面量类型与枚举，让你的类型再精确一些\"},{\"text\":\"5.函数与 Class 中的类型：详解函数重载与面向对象\",\"link\":\"5.函数与 Class 中的类型：详解函数重载与面向对象\"},{\"text\":\"6.探秘内置类型：any、unknown、never 与类型断言\",\"link\":\"6.探秘内置类型：any、unknown、never 与类型断言\"},{\"text\":\"7.类型编程好帮手：TypeScript 类型工具（上）\",\"link\":\"7.类型编程好帮手：TypeScript 类型工具（上）\"},{\"text\":\"8.类型编程好帮手：TypeScript 类型工具（下）\",\"link\":\"8.类型编程好帮手：TypeScript 类型工具（下）\"},{\"text\":\"9.类型编程基石：TypeScript 中无处不在的泛型\",\"link\":\"9.类型编程基石：TypeScript 中无处不在的泛型\"},{\"text\":\"10.结构化类型系统：类型兼容性判断的幕后\",\"link\":\"10.结构化类型系统：类型兼容性判断的幕后\"},{\"text\":\"11.类型系统层级：从 Top Type 到 Bottom Type\",\"link\":\"11.类型系统层级：从 Top Type 到 Bottom Type\"},{\"text\":\"12.类型里的逻辑运算：条件类型与 infer\",\"link\":\"12.类型里的逻辑运算：条件类型与 infer\"},{\"text\":\"13.内置工具类型基础：别再妖魔化工具类型了！\",\"link\":\"13.内置工具类型基础：别再妖魔化工具类型了！\"},{\"text\":\"14.反方向类型推导：用好上下文相关类型\",\"link\":\"14.反方向类型推导：用好上下文相关类型\"},{\"text\":\"15.数类型：协变与逆变的比较\",\"link\":\"15.数类型：协变与逆变的比较\"},{\"text\":\"16.了解类型编程与类型体操的意义，找到平衡点\",\"link\":\"16.了解类型编程与类型体操的意义，找到平衡点\"},{\"text\":\"17.内置工具类型进阶：类型编程进阶\",\"link\":\"17.内置工具类型进阶：类型编程进阶\"},{\"text\":\"18.基础类型新成员：模板字符串类型入门\",\"link\":\"18.基础类型新成员：模板字符串类型入门\"},{\"text\":\"19.类型编程新范式：模板字符串工具类型进阶\",\"link\":\"19.类型编程新范式：模板字符串工具类型进阶\"},{\"text\":\"20.工程层面的类型能力：类型声明、类型指令与命名空间\",\"link\":\"20.工程层面的类型能力：类型声明、类型指令与命名空间\"},{\"text\":\"21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位\",\"link\":\"21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位\"},{\"text\":\"22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍\",\"link\":\"22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍\"},{\"text\":\"23.全链路 TypeScript 工具库，找到适合你的工具\",\"link\":\"23.全链路 TypeScript 工具库，找到适合你的工具\"},{\"text\":\"24.说说 TypeScript 和 ECMAScript 之间那些事儿\",\"link\":\"24.说说 TypeScript 和 ECMAScript 之间那些事儿\"},{\"text\":\"25.装饰器与反射元数据：了解装饰器基本原理与应用\",\"link\":\"25.装饰器与反射元数据：了解装饰器基本原理与应用\"},{\"text\":\"26.控制反转与依赖注入：基于装饰器的依赖注入实现\",\"link\":\"26.控制反转与依赖注入：基于装饰器的依赖注入实现\"},{\"text\":\"27.TSConfig 全解（上）：构建相关配置\",\"link\":\"27.TSConfig 全解（上）：构建相关配置\"},{\"text\":\"28.TSConfig 全解（下）：检查相关、工程相关配置\",\"link\":\"28.TSConfig 全解（下）：检查相关、工程相关配置\"},{\"text\":\"29.基于 Prisma + NestJs 的 Node API ：前置知识储备\",\"link\":\"29.基于 Prisma + NestJs 的 Node API ：前置知识储备\"},{\"text\":\"30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署\",\"link\":\"30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署\"},{\"text\":\"31.玩转 TypeScript AST：AST Checker 与 CodeMod\",\"link\":\"31.玩转 TypeScript AST：AST Checker 与 CodeMod\"},{\"text\":\"32.感谢相伴：是结束，也是开始\",\"link\":\"32.感谢相伴：是结束，也是开始\"},{\"text\":\"33.漫谈篇：面试中的 TypeScript\",\"link\":\"33.漫谈篇：面试中的 TypeScript\"}]},\"/pamphlet/玩转css艺术之美/\":{\"base\":\"/pamphlet/玩转css艺术之美/\",\"items\":[{\"text\":\"1.准备篇：学前准备\",\"link\":\"1.准备篇：学前准备\"},{\"text\":\"2.基础篇：浏览器\",\"link\":\"2.基础篇：浏览器\"},{\"text\":\"3.进阶篇：回流重绘\",\"link\":\"3.进阶篇：回流重绘\"},{\"text\":\"4.基础篇：盒模型\",\"link\":\"4.基础篇：盒模型\"},{\"text\":\"5.基础篇：样式计算\",\"link\":\"5.基础篇：样式计算\"},{\"text\":\"6.进阶篇：布局样式\",\"link\":\"6.进阶篇：布局样式\"},{\"text\":\"7.进阶篇：函数计算\",\"link\":\"7.进阶篇：函数计算\"},{\"text\":\"8.进阶篇：变量计算\",\"link\":\"8.进阶篇：变量计算\"},{\"text\":\"9.技巧篇：选择器\",\"link\":\"9.技巧篇：选择器\"},{\"text\":\"10.技巧篇：背景与遮罩\",\"link\":\"10.技巧篇：背景与遮罩\"},{\"text\":\"11.技巧篇：阴影与滤镜\",\"link\":\"11.技巧篇：阴影与滤镜\"},{\"text\":\"12.技巧篇：变换与动画\",\"link\":\"12.技巧篇：变换与动画\"},{\"text\":\"13.实战篇：实战大操作-切换控件\",\"link\":\"13.实战篇：实战大操作-切换控件\"},{\"text\":\"14.实战篇：实战大操作-表单控件\",\"link\":\"14.实战篇：实战大操作-表单控件\"},{\"text\":\"15.实战篇：实战大操作-变量控件\",\"link\":\"15.实战篇：实战大操作-变量控件\"},{\"text\":\"16.总结篇：玩转css艺术之美\",\"link\":\"16.总结篇：玩转css艺术之美\"}]},\"/pamphlet/防御式 CSS 精讲/\":{\"base\":\"/pamphlet/防御式 CSS 精讲/\",\"items\":[{\"text\":\"1 推荐序｜克军：写好 CSS 是需要经验的\",\"link\":\"1 推荐序｜克军：写好 CSS 是需要经验的\"},{\"text\":\"2 如何根据 UI 形式选择视觉盒模型？\",\"link\":\"2 如何根据 UI 形式选择视觉盒模型？\"},{\"text\":\"3 Flexbox 和 Grid 中的换行\",\"link\":\"3 Flexbox 和 Grid 中的换行\"},{\"text\":\"4 Flexbox 和 Grid 中的最小内容尺寸\",\"link\":\"4 Flexbox 和 Grid 中的最小内容尺寸\"},{\"text\":\"5 布局中的滚动失效和默认拉伸\",\"link\":\"5 布局中的滚动失效和默认拉伸\"},{\"text\":\"6 固定网格轨道尺寸给 Web 布局带来的局限性\",\"link\":\"6 固定网格轨道尺寸给 Web 布局带来的局限性\"},{\"text\":\"7 如何灵活设置元素之间的间距？\",\"link\":\"7 如何灵活设置元素之间的间距？\"},{\"text\":\"8 position sticky 失效与修复\",\"link\":\"8 position sticky 失效与修复\"},{\"text\":\"9  z-index 失效与修复\",\"link\":\"9  z-index 失效与修复\"},{\"text\":\"10 你不知道的 border-radius\",\"link\":\"10 你不知道的 border-radius\"},{\"text\":\"11 Web 中的阴影\",\"link\":\"11 Web 中的阴影\"},{\"text\":\"12 Web 中的边框\",\"link\":\"12 Web 中的边框\"},{\"text\":\"13 响应式图片：防止图片的拉伸或挤压\",\"link\":\"13 响应式图片：防止图片的拉伸或挤压\"},{\"text\":\"14 如何提高图片上文本的可读性？\",\"link\":\"14 如何提高图片上文本的可读性？\"},{\"text\":\"15 你不知道的 CSS 渐变\",\"link\":\"15 你不知道的 CSS 渐变\"},{\"text\":\"16 Web 图片：你不应该遗忘的 CSS 技巧\",\"link\":\"16 Web 图片：你不应该遗忘的 CSS 技巧\"},{\"text\":\"17 图片的裁剪术\",\"link\":\"17 图片的裁剪术\"},{\"text\":\"18  重新思考 Web 中的裁剪：CSS 还是 SVG？\",\"link\":\"18  重新思考 Web 中的裁剪：CSS 还是 SVG？\"},{\"text\":\"19 CSS 如何改善滚动体验\",\"link\":\"19 CSS 如何改善滚动体验\"},{\"text\":\"20 美化滚动条 UI：自定义滚动条 UI\",\"link\":\"20 美化滚动条 UI：自定义滚动条 UI\"},{\"text\":\"21 CSS 的滚动捕捉\",\"link\":\"21 CSS 的滚动捕捉\"},{\"text\":\"22 溢出常见问题与排查\",\"link\":\"22 溢出常见问题与排查\"},{\"text\":\"23 易碎的容器盒子：避免使用固定尺寸和长内容设置\",\"link\":\"23 易碎的容器盒子：避免使用固定尺寸和长内容设置\"},{\"text\":\"24 使用逻辑属性来替代物理属性\",\"link\":\"24 使用逻辑属性来替代物理属性\"},{\"text\":\"25 多语言 Web 应用需要注意的细节\",\"link\":\"25 多语言 Web 应用需要注意的细节\"},{\"text\":\"26 条件 CSS 之 @规则和 CSS 选择器\",\"link\":\"26 条件 CSS 之 @规则和 CSS 选择器\"},{\"text\":\"27 条件 CSS 之 CSS 属性值和 CSS 函数\",\"link\":\"27 条件 CSS 之 CSS 属性值和 CSS 函数\"},{\"text\":\"28 CSS 的黑魔法\",\"link\":\"28 CSS 的黑魔法\"}]},\"/pamphlet/基于 Vite 的组件库工程化实战/\":{\"base\":\"/pamphlet/基于 Vite 的组件库工程化实战/\",\"items\":[{\"text\":\"1 开篇词：学习前端工程化就从搭建组件库开始\",\"link\":\"1 开篇词：学习前端工程化就从搭建组件库开始\"},{\"text\":\"2 MVP原型系统： 将组件封装为组件库\",\"link\":\"2 MVP原型系统： 将组件封装为组件库\"},{\"text\":\"3 CSS样式：用UnoCSS实现原子化CSS\",\"link\":\"3 CSS样式：用UnoCSS实现原子化CSS\"},{\"text\":\"4 文档建设：创建具备Demo示例功能的文档网站\",\"link\":\"4 文档建设：创建具备Demo示例功能的文档网站\"},{\"text\":\"5 单元测试(一)： 使用Jest进行前端单元测试\",\"link\":\"5 单元测试(一)： 使用Jest进行前端单元测试\"},{\"text\":\"6 单元测试 (二)： 搭建Vitest的单元测试环境\",\"link\":\"6 单元测试 (二)： 搭建Vitest的单元测试环境\"},{\"text\":\"7 规范化： Eslint + Prettier + Husky\",\"link\":\"7 规范化： Eslint + Prettier + Husky\"},{\"text\":\"8 软件包封装： 如何发布兼容多种 JS 模块标准的软件包？\",\"link\":\"8 软件包封装： 如何发布兼容多种 JS 模块标准的软件包？\"},{\"text\":\"9 持续集成 CI： 基于 github Action 的回归验证\",\"link\":\"9 持续集成 CI： 基于 github Action 的回归验证\"},{\"text\":\"10 开发许可证：维护自己的版权、拒绝拿来党\",\"link\":\"10 开发许可证：维护自己的版权、拒绝拿来党\"},{\"text\":\"11 组件发布： 建立语义化版本与提交软件包仓库 Npm\",\"link\":\"11 组件发布： 建立语义化版本与提交软件包仓库 Npm\"},{\"text\":\"12 建立组件库生态： 利用 Monorepo 方式管理组件库生态\",\"link\":\"12 建立组件库生态： 利用 Monorepo 方式管理组件库生态\"},{\"text\":\"13 按需引入实现组件库的按需引入功能\",\"link\":\"13 按需引入实现组件库的按需引入功能\"},{\"text\":\"14 文档部署： 用 Vercel 部署你的线上文档\",\"link\":\"14 文档部署： 用 Vercel 部署你的线上文档\"},{\"text\":\"15 README： 编写标准的 README\",\"link\":\"15 README： 编写标准的 README\"},{\"text\":\"16 品质保证：覆盖率测试报告\",\"link\":\"16 品质保证：覆盖率测试报告\"},{\"text\":\"17 社区参与： 如何管理社区的 PullRequest？\",\"link\":\"17 社区参与： 如何管理社区的 PullRequest？\"},{\"text\":\"18 敏捷开发： 用 Github 看板和 issue 管理需求\",\"link\":\"18 敏捷开发： 用 Github 看板和 issue 管理需求\"},{\"text\":\"19 架构复用： 创建 CLI 工具提高研发体验\",\"link\":\"19 架构复用： 创建 CLI 工具提高研发体验\"},{\"text\":\"20 融入开源生态： 编写 npm init 项目让用户更方便\",\"link\":\"20 融入开源生态： 编写 npm init 项目让用户更方便\"},{\"text\":\"21 加餐1：类型系统：导出组件库的类型定义\",\"link\":\"21 加餐1：类型系统：导出组件库的类型定义\"},{\"text\":\"22 结语｜当好项目的开路先锋\",\"link\":\"22 结语｜当好项目的开路先锋\"}]},\"/pamphlet/前端算法与数据结构面试：底层逻辑解读与大厂真题训练/\":{\"base\":\"/pamphlet/前端算法与数据结构面试：底层逻辑解读与大厂真题训练/\",\"items\":[{\"text\":\"1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略\",\"link\":\"1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略\"},{\"text\":\"2 快速上手——从0到1掌握算法面试需要的数据结构（一）\",\"link\":\"2 快速上手——从0到1掌握算法面试需要的数据结构（一）\"},{\"text\":\"3 快速上手——从0到1掌握算法面试需要的数据结构（二）\",\"link\":\"3 快速上手——从0到1掌握算法面试需要的数据结构（二）\"},{\"text\":\"4 快速上手——从0到1掌握算法面试需要的数据结构（三）\",\"link\":\"4 快速上手——从0到1掌握算法面试需要的数据结构（三）\"},{\"text\":\"5 递归初相见——二叉树递归遍历的三种姿势\",\"link\":\"5 递归初相见——二叉树递归遍历的三种姿势\"},{\"text\":\"6 算法的衡量——轻松理解时间复杂度与空间复杂度\",\"link\":\"6 算法的衡量——轻松理解时间复杂度与空间复杂度\"},{\"text\":\"7 数组的应用——真题归纳与解读\",\"link\":\"7 数组的应用——真题归纳与解读\"},{\"text\":\"8 字符串的应用——真题归纳与解读\",\"link\":\"8 字符串的应用——真题归纳与解读\"},{\"text\":\"9 链表的应用——真题归纳与解读\",\"link\":\"9 链表的应用——真题归纳与解读\"},{\"text\":\"10 快慢指针与多指针——玩转链表复杂操作\",\"link\":\"10 快慢指针与多指针——玩转链表复杂操作\"},{\"text\":\"11 姿势特别的链表——环形链表专题\",\"link\":\"11 姿势特别的链表——环形链表专题\"},{\"text\":\"12 栈与队列怎么玩（上）\",\"link\":\"12 栈与队列怎么玩（上）\"},{\"text\":\"13 栈与队列怎么玩（下）\",\"link\":\"13 栈与队列怎么玩（下）\"},{\"text\":\"14 遍历专题：DFS 与 BFS\",\"link\":\"14 遍历专题：DFS 与 BFS\"},{\"text\":\"15 场景化解读：递归与回溯思想在真题中的应用\",\"link\":\"15 场景化解读：递归与回溯思想在真题中的应用\"},{\"text\":\"16 二叉树真题归纳与解读\",\"link\":\"16 二叉树真题归纳与解读\"},{\"text\":\"17 特殊的二叉树——二叉搜索树专题\",\"link\":\"17 特殊的二叉树——二叉搜索树专题\"},{\"text\":\"18 特殊的二叉树——平衡二叉树专题\",\"link\":\"18 特殊的二叉树——平衡二叉树专题\"},{\"text\":\"19 特殊的二叉树——堆结构及其在排序中的应用\",\"link\":\"19 特殊的二叉树——堆结构及其在排序中的应用\"},{\"text\":\"20 排序算法专题（上）\",\"link\":\"20 排序算法专题（上）\"},{\"text\":\"21 排序算法专题（下）\",\"link\":\"21 排序算法专题（下）\"},{\"text\":\"22 普通人也能吃透的动态规划思想专题（上）\",\"link\":\"22 普通人也能吃透的动态规划思想专题（上）\"},{\"text\":\"23 普通人也能吃透的动态规划思想专题（下）\",\"link\":\"23 普通人也能吃透的动态规划思想专题（下）\"},{\"text\":\"24 大厂真题训练与解读——微软真题\",\"link\":\"24 大厂真题训练与解读——微软真题\"},{\"text\":\"25 大厂真题训练与解读——Google 真题\",\"link\":\"25 大厂真题训练与解读——Google 真题\"},{\"text\":\"26 大厂真题训练与解读——腾讯真题\",\"link\":\"26 大厂真题训练与解读——腾讯真题\"},{\"text\":\"27 大厂真题训练与解读——头条真题\",\"link\":\"27 大厂真题训练与解读——头条真题\"},{\"text\":\"28 思维课：算法面试的评价逻辑\",\"link\":\"28 思维课：算法面试的评价逻辑\"}]},\"/pamphlet/Babel 插件通关秘籍/\":{\"base\":\"/pamphlet/Babel 插件通关秘籍/\",\"items\":[{\"text\":\"1 Babel 的介绍\",\"link\":\"1 Babel 的介绍\"},{\"text\":\"2 Babel 的编译流程\",\"link\":\"2 Babel 的编译流程\"},{\"text\":\"3 Babel 的 AST\",\"link\":\"3 Babel 的 AST\"},{\"text\":\"4 Babel 的 API\",\"link\":\"4 Babel 的 API\"},{\"text\":\"5 实战案例-插入函数调用参数\",\"link\":\"5 实战案例-插入函数调用参数\"},{\"text\":\"6 JS Parser 的历史\",\"link\":\"6 JS Parser 的历史\"},{\"text\":\"7 traverse 的 path、scope、visitor\",\"link\":\"7 traverse 的 path、scope、visitor\"},{\"text\":\"8 Generator 和 SourceMap 的奥秘\",\"link\":\"8 Generator 和 SourceMap 的奥秘\"},{\"text\":\"9 Code-Frame 和代码高亮原理\",\"link\":\"9 Code-Frame 和代码高亮原理\"},{\"text\":\"10 Babel 插件和 preset\",\"link\":\"10 Babel 插件和 preset\"},{\"text\":\"11 Babel 插件的单元测试\",\"link\":\"11 Babel 插件的单元测试\"},{\"text\":\"12 Babel 的内置功能（上）\",\"link\":\"12 Babel 的内置功能（上）\"},{\"text\":\"13 Babel 的内置功能（下）\",\"link\":\"13 Babel 的内置功能（下）\"},{\"text\":\"14 Babel 配置的原理\",\"link\":\"14 Babel 配置的原理\"},{\"text\":\"15 工具介绍-VSCode Debugger 的使用\",\"link\":\"15 工具介绍-VSCode Debugger 的使用\"},{\"text\":\"16 实战案例-自动埋点\",\"link\":\"16 实战案例-自动埋点\"},{\"text\":\"17 实战案例-自动国际化\",\"link\":\"17 实战案例-自动国际化\"},{\"text\":\"18 实战案例-自动生成 API 文档\",\"link\":\"18 实战案例-自动生成 API 文档\"},{\"text\":\"19 实战案例-Linter\",\"link\":\"19 实战案例-Linter\"},{\"text\":\"20 实战案例-类型检查\",\"link\":\"20 实战案例-类型检查\"},{\"text\":\"21 实战案例-压缩混淆\",\"link\":\"21 实战案例-压缩混淆\"},{\"text\":\"22 实战案例-JS 解释器\",\"link\":\"22 实战案例-JS 解释器\"},{\"text\":\"23 实战案例-模块遍历\",\"link\":\"23 实战案例-模块遍历\"},{\"text\":\"24 Babel Macros\",\"link\":\"24 Babel Macros\"},{\"text\":\"25 如何调试Babel源码\",\"link\":\"25 如何调试Babel源码\"},{\"text\":\"26 手写Babel-思路篇\",\"link\":\"26 手写Babel-思路篇\"},{\"text\":\"27 手写Babel-parser 篇\",\"link\":\"27 手写Babel-parser 篇\"},{\"text\":\"28 手写Babel-traverse 篇\",\"link\":\"28 手写Babel-traverse 篇\"},{\"text\":\"29 手写Babel-traverse -- path篇\",\"link\":\"29 手写Babel-traverse -- path篇\"},{\"text\":\"30 手写Babel-traverse -- scope篇\",\"link\":\"30 手写Babel-traverse -- scope篇\"},{\"text\":\"31 手写Babel-generator篇\",\"link\":\"31 手写Babel-generator篇\"},{\"text\":\"32 手写Babel-core篇\",\"link\":\"32 手写Babel-core篇\"},{\"text\":\"33 手写Babel-cli篇\",\"link\":\"33 手写Babel-cli篇\"},{\"text\":\"34 手写Babel-总结\",\"link\":\"34 手写Babel-总结\"},{\"text\":\"35 小册总结\",\"link\":\"35 小册总结\"},{\"text\":\"36 加餐-会了babel 插件-就会写prettier插件\",\"link\":\"36 加餐-会了babel 插件-就会写prettier插件\"}]},\"/pamphlet/WebGL 入门与实践/\":{\"base\":\"/pamphlet/WebGL 入门与实践/\",\"items\":[{\"text\":\"1 初级入门 --- 认识 WebGL\",\"link\":\"1 初级入门 --- 认识 WebGL\"},{\"text\":\"2 初级入门 --- 从一个点开始：掌握 WebGL 的编程要素\",\"link\":\"2 初级入门 --- 从一个点开始：掌握 WebGL 的编程要素\"},{\"text\":\"3 初级入门 --- 绘制三角形：学会使用缓冲区、了解 WebGL 中的基本图形元素\",\"link\":\"3 初级入门 --- 绘制三角形：学会使用缓冲区、了解 WebGL 中的基本图形元素\"},{\"text\":\"4 初级入门 --- 基本图元绘制：线段\",\"link\":\"4 初级入门 --- 基本图元绘制：线段\"},{\"text\":\"5 初级入门 --- 绘制渐变三角形：深入理解缓冲区\",\"link\":\"5 初级入门 --- 绘制渐变三角形：深入理解缓冲区\"},{\"text\":\"6 初级入门 --- 画个矩形：用基本图形构建平面\",\"link\":\"6 初级入门 --- 画个矩形：用基本图形构建平面\"},{\"text\":\"7 初级入门 --- 纹理贴图：为形体穿上外衣\",\"link\":\"7 初级入门 --- 纹理贴图：为形体穿上外衣\"},{\"text\":\"8 初级入门 --- 绘制立方体、球体、椎体：如何用基本图形构建规则形体\",\"link\":\"8 初级入门 --- 绘制立方体、球体、椎体：如何用基本图形构建规则形体\"},{\"text\":\"9 初级入门 --- 绘制多个物体：进一步封装绘制方法\",\"link\":\"9 初级入门 --- 绘制多个物体：进一步封装绘制方法\"},{\"text\":\"10 中级进阶 --- 神说要有光，于是就有了光：给物体添加环境光。\",\"link\":\"10 中级进阶 --- 神说要有光，于是就有了光：给物体添加环境光。\"},{\"text\":\"11 中级进阶 --- 冯氏光照模型：为物体增加漫反射效果\",\"link\":\"11 中级进阶 --- 冯氏光照模型：为物体增加漫反射效果\"},{\"text\":\"12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果\",\"link\":\"12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果\"},{\"text\":\"13  中级进阶 --- 深入理解 GLSL 语法\",\"link\":\"13  中级进阶 --- 深入理解 GLSL 语法\"},{\"text\":\"14 中级进阶 --- WebGL 与数学：我们需要哪些数学知识？\",\"link\":\"14 中级进阶 --- WebGL 与数学：我们需要哪些数学知识？\"},{\"text\":\"15 中级进阶 --- 数学：点、向量、矩阵。\",\"link\":\"15 中级进阶 --- 数学：点、向量、矩阵。\"},{\"text\":\"16 中级进阶 ---  通用数学库的 JavaScript 实现。\",\"link\":\"16 中级进阶 ---  通用数学库的 JavaScript 实现。\"},{\"text\":\"17 中级进阶 --- WebGL 坐标系\",\"link\":\"17 中级进阶 --- WebGL 坐标系\"},{\"text\":\"18 中级进阶 --- 坐标系变换：基本变换原理与算法实现\",\"link\":\"18 中级进阶 --- 坐标系变换：基本变换原理与算法实现\"},{\"text\":\"19 中级进阶 --- 坐标系变换：模型空间变换到世界空间\",\"link\":\"19 中级进阶 --- 坐标系变换：模型空间变换到世界空间\"},{\"text\":\"20 中级进阶 --- 坐标系变换：世界空间变换到观察空间\",\"link\":\"20 中级进阶 --- 坐标系变换：世界空间变换到观察空间\"},{\"text\":\"21 中级进阶 --- 坐标系变换：观察空间变换到裁剪空间\",\"link\":\"21 中级进阶 --- 坐标系变换：观察空间变换到裁剪空间\"},{\"text\":\"22 深入研究 --- 更高级的旋转：欧拉角、四元数。\",\"link\":\"22 深入研究 --- 更高级的旋转：欧拉角、四元数。\"},{\"text\":\"23 深入研究 --- 四元数的应用：使用鼠标控制模型的旋转\",\"link\":\"23 深入研究 --- 四元数的应用：使用鼠标控制模型的旋转\"},{\"text\":\"24 深入研究 --- CSS 与 3D 之 transform\",\"link\":\"24 深入研究 --- CSS 与 3D 之 transform\"},{\"text\":\"25 深入研究 --- CSS 与 3D 之 perspective\",\"link\":\"25 深入研究 --- CSS 与 3D 之 perspective\"},{\"text\":\"26 深入研究 --- 数学库在 CSS 的 3D 动画中扮演的重要角色\",\"link\":\"26 深入研究 --- 数学库在 CSS 的 3D 动画中扮演的重要角色\"},{\"text\":\"27 深入探究 --- 层级建模：行走的机器人\",\"link\":\"27 深入探究 --- 层级建模：行走的机器人\"},{\"text\":\"28 深入研究 --- 使用立方体纹理绘制天空盒\",\"link\":\"28 深入研究 --- 使用立方体纹理绘制天空盒\"},{\"text\":\"29 深入研究 --- 混合效果\",\"link\":\"29 深入研究 --- 混合效果\"},{\"text\":\"30 深入研究 --- 帧缓冲\",\"link\":\"30 深入研究 --- 帧缓冲\"},{\"text\":\"31 高级应用 --- 3D模型的拾取原理与实现\",\"link\":\"31 高级应用 --- 3D模型的拾取原理与实现\"},{\"text\":\"32 高级应用 --- 魔法 Shader：火焰效果的原理与实现\",\"link\":\"32 高级应用 --- 魔法 Shader：火焰效果的原理与实现\"},{\"text\":\"33 结束了吗？一切刚刚开始\",\"link\":\"33 结束了吗？一切刚刚开始\"}]}},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/jypleo/books\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>