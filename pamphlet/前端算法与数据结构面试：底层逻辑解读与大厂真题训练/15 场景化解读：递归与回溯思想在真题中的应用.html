<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>刘云露</title>
    <meta name="description" content="一些有意思的东西">
    <meta name="generator" content="VitePress v1.3.1">
    <link rel="preload stylesheet" href="/books/assets/style.BoxccS-0.css" as="style">
    
    <script type="module" src="/books/assets/app.MGbGTwrK.js"></script>
    <link rel="preload" href="/books/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/books/assets/chunks/framework.D8Prfz4N.js">
    <link rel="modulepreload" href="/books/assets/chunks/theme.CHiTq8XS.js">
    <link rel="modulepreload" href="/books/assets/pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_15 场景化解读：递归与回溯思想在真题中的应用.md.DRXfQflY.lean.js">
    <meta name="referrer" content="no-referrer">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-fa9c8703><!--[--><!--]--><!--[--><span tabindex="-1" data-v-243700a8></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-243700a8> Skip to content </a><!--]--><!----><header class="VPNav" data-v-fa9c8703 data-v-9ecd24f1><div class="VPNavBar has-sidebar top" data-v-9ecd24f1 data-v-8be259f3><div class="wrapper" data-v-8be259f3><div class="container" data-v-8be259f3><div class="title" data-v-8be259f3><div class="VPNavBarTitle has-sidebar" data-v-8be259f3 data-v-d4781334><a class="title" href="/books/" data-v-d4781334><!--[--><!--]--><!----><span data-v-d4781334>刘云露</span><!--[--><!--]--></a></div></div><div class="content" data-v-8be259f3><div class="content-body" data-v-8be259f3><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8be259f3><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8be259f3 data-v-2f005d11><span id="main-nav-aria-label" class="visually-hidden" data-v-2f005d11> Main Navigation </span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-2f005d11 data-v-823b819b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-823b819b><span class="text" data-v-823b819b><!----><span data-v-823b819b>小册</span><span class="vpi-chevron-down text-icon" data-v-823b819b></span></span></button><div class="menu" data-v-823b819b><div class="VPMenu" data-v-823b819b data-v-cc2a57f1><div class="items" data-v-cc2a57f1><!--[--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/webpack5/1%20%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%20Webpack%EF%BC%9A%E6%97%A7%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A0%B4%E5%B1%80%E8%80%85.html" data-v-d12d4856><!--[-->Webpack5 核心原理与应用实践<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/advanced-guide-to-mastering-typeScript/1.%E5%BC%80%E7%AF%87%EF%BC%9A%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%20TypeScript.html" data-v-d12d4856><!--[-->TypeScript全面进阶指南<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E7%8E%A9%E8%BD%ACcss%E8%89%BA%E6%9C%AF%E4%B9%8B%E7%BE%8E/1.%E5%87%86%E5%A4%87%E7%AF%87%EF%BC%9A%E5%AD%A6%E5%89%8D%E5%87%86%E5%A4%87.html" data-v-d12d4856><!--[-->玩转css艺术之美<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E9%98%B2%E5%BE%A1%E5%BC%8F%20CSS%20%E7%B2%BE%E8%AE%B2/1%20%E6%8E%A8%E8%8D%90%E5%BA%8F%EF%BD%9C%E5%85%8B%E5%86%9B%EF%BC%9A%E5%86%99%E5%A5%BD%20CSS%20%E6%98%AF%E9%9C%80%E8%A6%81%E7%BB%8F%E9%AA%8C%E7%9A%84.html" data-v-d12d4856><!--[-->防御式 CSS 精讲<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E5%9F%BA%E4%BA%8E%20Vite%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E6%88%98/1%20%E5%BC%80%E7%AF%87%E8%AF%8D%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B0%B1%E4%BB%8E%E6%90%AD%E5%BB%BA%E7%BB%84%E4%BB%B6%E5%BA%93%E5%BC%80%E5%A7%8B.html" data-v-d12d4856><!--[-->基于 Vite 的组件库工程化实战<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/1%20%E9%9D%A2%E8%AF%95%E6%80%BB%E6%9C%89%E5%A5%97%E8%B7%AF%EF%BC%8C%E7%AE%97%E6%B3%95%E4%B8%8D%E6%98%AF%E7%8E%84%E5%AD%A6%E2%80%94%E2%80%94%E5%86%99%E7%BB%99%E6%99%AE%E9%80%9A%E4%BA%BA%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5.html" data-v-d12d4856><!--[-->前端算法与数据结构面试：底层逻辑解读与大厂真题训练<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D/1%20Babel%20%E7%9A%84%E4%BB%8B%E7%BB%8D.html" data-v-d12d4856><!--[-->Babel 插件通关秘籍<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-cc2a57f1 data-v-d12d4856><a class="VPLink link" href="/books/pamphlet/WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/1%20%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%20---%20%E8%AE%A4%E8%AF%86%20WebGL.html" data-v-d12d4856><!--[-->WebGL 入门与实践<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8be259f3 data-v-0ac8ed3b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-0ac8ed3b data-v-8ca151db data-v-b8d94da6><span class="check" data-v-b8d94da6><span class="icon" data-v-b8d94da6><!--[--><span class="vpi-sun sun" data-v-8ca151db></span><span class="vpi-moon moon" data-v-8ca151db></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8be259f3 data-v-a68b78fa data-v-7d9d8cc4><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7d9d8cc4 data-v-4c6ec8e5><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8be259f3 data-v-de89d543 data-v-823b819b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-823b819b><span class="vpi-more-horizontal icon" data-v-823b819b></span></button><div class="menu" data-v-823b819b><div class="VPMenu" data-v-823b819b data-v-cc2a57f1><!----><!--[--><!--[--><!----><div class="group" data-v-de89d543><div class="item appearance" data-v-de89d543><p class="label" data-v-de89d543>Appearance</p><div class="appearance-action" data-v-de89d543><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-de89d543 data-v-8ca151db data-v-b8d94da6><span class="check" data-v-b8d94da6><span class="icon" data-v-b8d94da6><!--[--><span class="vpi-sun sun" data-v-8ca151db></span><span class="vpi-moon moon" data-v-8ca151db></span><!--]--></span></span></button></div></div></div><div class="group" data-v-de89d543><div class="item social-links" data-v-de89d543><div class="VPSocialLinks social-links-list" data-v-de89d543 data-v-7d9d8cc4><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7d9d8cc4 data-v-4c6ec8e5><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8be259f3 data-v-89220f3a><span class="container" data-v-89220f3a><span class="top" data-v-89220f3a></span><span class="middle" data-v-89220f3a></span><span class="bottom" data-v-89220f3a></span></span></button></div></div></div></div><div class="divider" data-v-8be259f3><div class="divider-line" data-v-8be259f3></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-fa9c8703 data-v-3e43048a><div class="container" data-v-3e43048a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-3e43048a><span class="vpi-align-left menu-icon" data-v-3e43048a></span><span class="menu-text" data-v-3e43048a>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-3e43048a data-v-394bc835><button data-v-394bc835>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-fa9c8703 data-v-a8e7572a><div class="curtain" data-v-a8e7572a></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-a8e7572a><span class="visually-hidden" id="sidebar-aria-label" data-v-a8e7572a> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-630655c8><section class="VPSidebarItem level-0 has-active" data-v-630655c8 data-v-1396c9b9><!----><div class="items" data-v-1396c9b9><!--[--><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/1%20%E9%9D%A2%E8%AF%95%E6%80%BB%E6%9C%89%E5%A5%97%E8%B7%AF%EF%BC%8C%E7%AE%97%E6%B3%95%E4%B8%8D%E6%98%AF%E7%8E%84%E5%AD%A6%E2%80%94%E2%80%94%E5%86%99%E7%BB%99%E6%99%AE%E9%80%9A%E4%BA%BA%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/2%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%8E%8C%E6%8F%A1%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>2 快速上手——从0到1掌握算法面试需要的数据结构（一）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/3%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%8E%8C%E6%8F%A1%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>3 快速上手——从0到1掌握算法面试需要的数据结构（二）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/4%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%8E%8C%E6%8F%A1%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>4 快速上手——从0到1掌握算法面试需要的数据结构（三）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/5%20%E9%80%92%E5%BD%92%E5%88%9D%E7%9B%B8%E8%A7%81%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>5 递归初相见——二叉树递归遍历的三种姿势</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/6%20%E7%AE%97%E6%B3%95%E7%9A%84%E8%A1%A1%E9%87%8F%E2%80%94%E2%80%94%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>6 算法的衡量——轻松理解时间复杂度与空间复杂度</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/7%20%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%9C%9F%E9%A2%98%E5%BD%92%E7%BA%B3%E4%B8%8E%E8%A7%A3%E8%AF%BB.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>7 数组的应用——真题归纳与解读</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/8%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%9C%9F%E9%A2%98%E5%BD%92%E7%BA%B3%E4%B8%8E%E8%A7%A3%E8%AF%BB.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>8 字符串的应用——真题归纳与解读</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/9%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%9C%9F%E9%A2%98%E5%BD%92%E7%BA%B3%E4%B8%8E%E8%A7%A3%E8%AF%BB.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>9 链表的应用——真题归纳与解读</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/10%20%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%9A%E6%8C%87%E9%92%88%E2%80%94%E2%80%94%E7%8E%A9%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%A4%8D%E6%9D%82%E6%93%8D%E4%BD%9C.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>10 快慢指针与多指针——玩转链表复杂操作</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/11%20%E5%A7%BF%E5%8A%BF%E7%89%B9%E5%88%AB%E7%9A%84%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>11 姿势特别的链表——环形链表专题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/12%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%8E%E4%B9%88%E7%8E%A9%EF%BC%88%E4%B8%8A%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>12 栈与队列怎么玩（上）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/13%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%8E%E4%B9%88%E7%8E%A9%EF%BC%88%E4%B8%8B%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>13 栈与队列怎么玩（下）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/14%20%E9%81%8D%E5%8E%86%E4%B8%93%E9%A2%98%EF%BC%9ADFS%20%E4%B8%8E%20BFS.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>14 遍历专题：DFS 与 BFS</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/15%20%E5%9C%BA%E6%99%AF%E5%8C%96%E8%A7%A3%E8%AF%BB%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3%E5%9C%A8%E7%9C%9F%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>15 场景化解读：递归与回溯思想在真题中的应用</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/16%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9C%9F%E9%A2%98%E5%BD%92%E7%BA%B3%E4%B8%8E%E8%A7%A3%E8%AF%BB.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>16 二叉树真题归纳与解读</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/17%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%93%E9%A2%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>17 特殊的二叉树——二叉搜索树专题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/18%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>18 特殊的二叉树——平衡二叉树专题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/19%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%A0%86%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%9C%A8%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>19 特殊的二叉树——堆结构及其在排序中的应用</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/20%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>20 排序算法专题（上）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/21%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>21 排序算法专题（下）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/22%20%E6%99%AE%E9%80%9A%E4%BA%BA%E4%B9%9F%E8%83%BD%E5%90%83%E9%80%8F%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E6%83%B3%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>22 普通人也能吃透的动态规划思想专题（上）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/23%20%E6%99%AE%E9%80%9A%E4%BA%BA%E4%B9%9F%E8%83%BD%E5%90%83%E9%80%8F%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E6%83%B3%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>23 普通人也能吃透的动态规划思想专题（下）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/24%20%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E5%BE%AE%E8%BD%AF%E7%9C%9F%E9%A2%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>24 大厂真题训练与解读——微软真题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/25%20%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94Google%20%E7%9C%9F%E9%A2%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>25 大厂真题训练与解读——Google 真题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/26%20%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E8%85%BE%E8%AE%AF%E7%9C%9F%E9%A2%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>26 大厂真题训练与解读——腾讯真题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/27%20%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E5%A4%B4%E6%9D%A1%E7%9C%9F%E9%A2%98.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>27 大厂真题训练与解读——头条真题</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-1396c9b9 data-v-1396c9b9><div class="item" data-v-1396c9b9><div class="indicator" data-v-1396c9b9></div><a class="VPLink link link" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/28%20%E6%80%9D%E7%BB%B4%E8%AF%BE%EF%BC%9A%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E7%9A%84%E8%AF%84%E4%BB%B7%E9%80%BB%E8%BE%91.html" data-v-1396c9b9><!--[--><p class="text" data-v-1396c9b9>28 思维课：算法面试的评价逻辑</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-fa9c8703 data-v-f34757bc><div class="VPDoc has-sidebar has-aside" data-v-f34757bc data-v-2a8ae8ad><!--[--><!--]--><div class="container" data-v-2a8ae8ad><div class="aside" data-v-2a8ae8ad><div class="aside-curtain" data-v-2a8ae8ad></div><div class="aside-container" data-v-2a8ae8ad><div class="aside-content" data-v-2a8ae8ad><div class="VPDocAside" data-v-2a8ae8ad data-v-5e1f76ae><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-5e1f76ae data-v-381c8800><div class="content" data-v-381c8800><div class="outline-marker" data-v-381c8800></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-381c8800>On this page</div><ul class="VPDocOutlineItem root" data-v-381c8800 data-v-b5df0154><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-5e1f76ae></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-2a8ae8ad><div class="content-container" data-v-2a8ae8ad><!--[--><!--]--><main class="main" data-v-2a8ae8ad><div style="position:relative;" class="vp-doc _books_pamphlet_%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83_15%20%E5%9C%BA%E6%99%AF%E5%8C%96%E8%A7%A3%E8%AF%BB%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3%E5%9C%A8%E7%9C%9F%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" data-v-2a8ae8ad><div><h2 id="在开始之前" tabindex="-1">在开始之前 <a class="header-anchor" href="#在开始之前" aria-label="Permalink to &quot;在开始之前&quot;">​</a></h2><p>根据我深耕技术写作多年的经验，很多同学一看到标题里有“思想”两个字，就会觉得接下来要讲的一定是一个非常复杂的“高大上”理论，于是他会先给自己箍上一个“我一定学不会”的紧箍咒，接着心里就开始打退堂鼓了。这样的同学在和算法正面交锋之前，就先被自己内心的恐惧击垮了，实在可惜。 <br>    <br>站在讲解者的角度来说，我确实不会先给大家画个饼，说这玩意儿有多么多么简单——这是一个非常不负责任的承诺。因为对于初学者来说，没有什么是简单的，从不会到会本来就是一个过程。况且，你现在学的是不少前端er都不肯学/学不动的算法，这本就不是一个轻松的挑战。但既然走到了这一步，不管你这会儿心里有多慌，我都希望你可以坚持一下、读读看，你会发现这玩意儿真的不是玄学——它真的很香。   <br>     <br></p><p><a name="Cj7I7"></a></p><h2 id="如何学好这一节" tabindex="-1">如何学好这一节 <a class="header-anchor" href="#如何学好这一节" aria-label="Permalink to &quot;如何学好这一节&quot;">​</a></h2><p>不可否认，在一些传统教材里，谈及“思想”必定会有大段理论文字的堆砌，这也是很多同学学完数据结构直接放弃学习算法思想的重要原因。   <br><br>但站在面试的角度来看，算法相关的考察几乎不存在“背知识点”这种形式，更多还是看你能不能把题做出来。算法思想是抽象的，题目却是具体的。我们常说“以题为纲”，其目的就是帮助大家站在具体去理解抽象。  <br><br>本节我们先不用纠结什么是递归、什么是回溯，而是直接来做一道题，从题中去认识所谓的“思想”。  <br><br>通过本节的学习，我希望大家能够认识到，“思想”并不是一坨剪不断理还乱、学了只能用来吹水的虚无概念。“思想”本质上就是套路，而且是普适性非常强的套路，它有着大量的对口问题。搞定了它，就搞定了一大波面试题——爽不爽？要想爽这一把，就不要轻易撤退。  <br>  <br></p><p><a name="pwQVt"></a></p><h2 id="关键套路初相见-全排列问题" tabindex="-1">关键套路初相见：全排列问题 <a class="header-anchor" href="#关键套路初相见-全排列问题" aria-label="Permalink to &quot;关键套路初相见：全排列问题&quot;">​</a></h2><blockquote><p>题目描述：给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p></blockquote><p></p><blockquote><p>示例：   <br> 输入: [1,2,3]<br> 输出: [<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br> ]</p></blockquote><p><a name="WtuIE"></a></p><h3 id="思路分析" tabindex="-1">思路分析 <a class="header-anchor" href="#思路分析" aria-label="Permalink to &quot;思路分析&quot;">​</a></h3><p>“全排列”是高中数学里的一个概念，这里先带大家复习一下：</p><blockquote><p>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。</p></blockquote><p>不过就算你已经完全忘了“全排列”到底是一个什么样的数学概念，也没有关系。结合题目描述和示例，我们依然可以分析出这道题想让我们做的事情：拿到一个 n 个数的数组作为入参，穷举出这 n 个数的所有排列方式。    <br>  <br>哎？等等，我好像看到一个熟悉的词眼——<strong>穷举</strong>！楼上是不是说了穷举？我们最近还在哪里见过穷举？是不是在上一节？上一节的哪个位置？DFS 对不对？DFS 用什么实现比较好？递归！好，来得早不如来得巧，我现在就决定用递归来做这个题。  <br></p><div class="language-! vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">!</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>如果你的脑回路暂时没有反应出来上面这些知识点之间的关联关系，也不要着急。新手上路，这很正常。    </span></span>
<span class="line"><span></span></span>
<span class="line"><span>做完下面一系列的题目之后，我会跟大家介绍这类题目的关键特征，到时候会有更直白的套路可以用。现在先不要慌，跟着我的思路往下走，好好敲代码</span></span></code></pre></div><p>怎么做呢？大家仔细想想，在这个变化的序列中，不变的是什么——是不是坑位的数量？拿示例来说，不管我怎么调整数字的顺序，它们都只能围着这 3 个坑打转。<strong>当我们感到变化难以把握时，不如尝试先从不变的东西入手</strong>。这里我把坑位给大家画出来：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a215aa6c68~tplv-t2oaga2asx-image.image" alt="image.png"><br>  <br>现在问题变成了，我手里有 3 个数，要往这 3 个坑里填，有几种填法？我们一个一个坑来看：</p><ul><li><strong>Step1</strong>:：面对第一个坑，我有3种选择：填1、填2、填3，随机选择其中一个填进去即可。</li><li><strong>Step2</strong>：面对第二个坑，由于 Step1 中已经分出去1个数字，现在只剩下2个选择：比如如果 Step1 中填进去的是 1，那么现在就剩下2、3；如果 Step1 中填进去的是 2，那么就剩下 1、3。</li><li><strong>Step3</strong>： 面对第三个坑，由于前面已经消耗了2个数字，此时我们手里只剩下 1 个数字了。所以说第 3 个坑是毫无悬念的，它只有1种可能。</li></ul><p><br>我们把三个坑的情况统筹起来，那么全排列就一共有 <code>3x2x1=6</code>  种可能。可惜这道题问的不是全排列的可能性有多少种，而是要求你把每一种可能性都<strong>穷举</strong>出来。这其实有点类似于我们上一节玩迷宫游戏的时候，游戏规则不仅要求你回答出迷宫的通关方法有几种，还要求你列举出每一条路的路径。<strong>列举“路径”，我们首先要找到“坐标”</strong>。在这道题里，“坐标”就是每一个坑里可能填进的数字。我把它画出来，你就明白了： <br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a215c76113~tplv-t2oaga2asx-image.image" alt="image.png"><br><code>root</code> 是一个空坐标，是我们分配数字的起点。   <br>你可以想象自己此时此刻正手握 3 个数字站在 <code>root</code> 这个位置上。眼前是第一个坑，这个坑向你问道：“小哥，你打算给我哪个数字呢？” <br>你说：“不好说，这里有 3 种可能”。第一个坑里可以填的数字，对应的是以下三种情况：  <br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21761dd46~tplv-t2oaga2asx-image.image" alt="image.png"><br>  <br>接着，你走到了第二个坑。第二个坑问你：“小哥，你打算给我哪个数字呢？”。 <br>你仔细想想，说：“不好说，这要看我给了 1 号坑哪个数字。但可以确定的是，不管我给了 1 号坑哪个数字，到你这里的时候，都只有 2 个数字可选了”。基于 1 号坑的分配结果，2 号坑分别有以下可能：   <br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a217acd94b~tplv-t2oaga2asx-image.image" alt="image.png"><br>终于，你走到了第三个坑。此时，你手里只剩下 1 个数，还没等第 3 个坑问你要，你就对它说：“哥，别挑了，我就剩一个了，你没得选”。说着，你把 1 号坑和 2 号坑挑完剩下的最后 1 个数给了 3 号坑：  <br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21bed6cbe~tplv-t2oaga2asx-image.image" alt="image.png"><br>  <br><strong>有没有发现，不知不觉中，我们构造出了一个树结构。</strong><br>从这个树结构里我们可以清晰地看出，全排列的所有可能性：  <br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21d81055e~tplv-t2oaga2asx-image.image" alt="image.png"><br>图中以圆点为起点，以箭头为终点，起点和终点之间就是一个完整的排列。<br><br>我们的思维路径是一个树结构，但这并不意味着我们需要真的在编码的时候去构造一棵树出来。回忆一下上一节，我们走迷宫的各种路径组合起来，是不是也是一个树结构？走迷宫时我们没有构造树，这里也不需要构造树。需要什么？需要<strong>递归</strong>！   <br>  <br>即便不联想咱们刚刚学过的 DFS 知识点，这道题的解答思路中也有一个非常关键的特征在提醒你往递归去想，那就是<strong>重复</strong>。    <br><br></p><div class="language-! vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">!</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>这里给大家一个思维工具：以后只要分析出重复的逻辑（排除掉类似数组遍历这种简单粗暴的重复），你都需要把递归从你的大脑内存里调度出来、将其列为“可以一试”的解法之一；只要想到递归，立刻回忆我们上一节讲的 DFS 思想、然后尝试套我们这一节末尾教给大家的解题模板。这个脑回路未必 100% 准确，但确实有极高的成功概率——题，是有规律的。这，就是规律之一。</span></span></code></pre></div><p><br>在以上的“填坑”过程中，我们重复地做了以下事情：</p><ol><li>检查手里剩下的数字有哪些</li><li>选取其中一个填进当前的坑里</li></ol><p><br>在第 5 节初识递归时，大家已经知道“<strong>重复”的内容，就是递归式</strong>。<br><br>这个重复递归式的动作一直持续到了最后一个数字也被填进坑里为止——“<strong>重复”的终点，就是递归边界</strong>。   <br><br>这里大家当然也可以借鉴遍历二叉树的经验 ，通过判断数组的可选数字是否为空，来决定当前是不是走到了递归边界。但是这道题其实可以做得更简单：坑位的个数是已知的，我们可以通过记录当前坑位的索引来判断是否已经走到了边界：比如说示例中有 <code>n</code>  个坑，假如我们把第 1 个坑的索引记为 0 ，那么索引为 <code>n-1</code>   的坑就是递归式的执行终点，索引为 <code>n</code>  的坑（压根不存在）就是递归边界。 <br><br>   <br>递归的编码实现，无非是把我们上面描述过的递归式和递归边界翻译成代码：   <br>    <a name="G4KFk"></a></p><h3 id="编码实现" tabindex="-1">编码实现 <a class="header-anchor" href="#编码实现" aria-label="Permalink to &quot;编码实现&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[][]}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入参是一个数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> permute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 缓存数组的长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // curr 变量用来记录当前的排列内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // res 用来记录所有的排列顺序</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // visited 用来避免重复使用同一个数字</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> visited</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 此时前 len 个坑位已经填满，将对应的排列记录下来</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(curr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 检查手里剩下的数字有哪些</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">len;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">visited[nums[i]]) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 给 nums[i] 打个“已用过”的标</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              visited[nums[i]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 将nums[i]推入当前排列</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              curr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nums[i])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 基于这个排列继续往下一个坑走去</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">              dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // nums[i]让出当前坑位</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              curr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // 下掉“已用过”标识</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              visited[nums[i]] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><a name="wN075"></a></p><h3 id="小贴士" tabindex="-1">小贴士 <a class="header-anchor" href="#小贴士" aria-label="Permalink to &quot;小贴士&quot;">​</a></h3><p>上面这坨代码里，有两个点需要大家格外注意，它们将会成为我们以后做类似题目的关键技巧：</p><ol><li>Map 结构 <code>visited</code>  的使用：填坑时，每用到一个数字，我们都要给这个数字打上“已用过”的标——避免它被使用第二次；数字让出坑位时，对应的排列和 <code>visited</code>  状态也需要被及时地更新掉。</li><li>当走到递归边界时，一个完整的排列也到手了。将这个完整排列推入结果数组时，我们用了 <code> res.push(curr.slice())</code> 而不是简单的 <code>res.push(curr)</code> 。为什么这样做？因为全局只有一个唯一的 <code>curr</code> ， <code>curr</code> 的值会随着 <code>dfs</code> 的进行而不断被更新。 <code>slice</code> 方法的作用是帮助我们拷贝出一个不影响<code>curr</code>正本的副本，以防直接修改到<code>curr</code>的引用。</li></ol><br><br>带着全排列问题教会我们的解题思路和编码技巧，我们再来看另一个类型的题目——组合问题。  <br> <br><h2 id="组合问题-变化的-坑位-不变的-套路" tabindex="-1">组合问题：变化的“坑位”，不变的“套路” <a class="header-anchor" href="#组合问题-变化的-坑位-不变的-套路" aria-label="Permalink to &quot;组合问题：变化的“坑位”，不变的“套路”&quot;">​</a></h2><blockquote><p>题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br> 说明：解集不能包含重复的子集。</p></blockquote><blockquote><p>示例: 输入: nums = [1,2,3]<br> 输出:<br> [<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br> ]</p></blockquote><h3 id="思路分析-1" tabindex="-1">思路分析 <a class="header-anchor" href="#思路分析-1" aria-label="Permalink to &quot;思路分析&quot;">​</a></h3><p>见到这道题，大家第一反应会是什么？吸取了上一道题的经验，这道题我们应该想到的是：<strong>穷举出现了，大概率会用到 DFS</strong>。<br> 只要用到 DFS，就不得不想到<strong>树形思维方式</strong>，进而不得不思考递归式和递归边界的问题。在这个思考的过程中，最重要的一环就是<strong>对“坑位”的定位和分析。</strong><br>从上一道题中，我们不难看出，“坑位”对应的就是树形逻辑中树的某一层，“坑位数”往往意味着递归边界的限制条件。   <br>  <br>找“坑位”的思路也是具有规律的：“坑位”往往是那些不会变化的东西。在上一道题中，排列的顺序是变化的，而每个排列中数字的个数却是不变的，因此数字的个数就对应“坑位”的个数；在这道题中，每个组合中数字的个数是不确定的，不变的东西变成了<strong>可以参与组合的数字</strong>，变化的东西则是每个数字在组合中的<strong>存在性</strong>。因此我们的思路可以调整为，<strong>从每一个数字入手，讨论它出现或者不出现的情况</strong>。</p><p>换汤不换药，这里我们仍然采取树形思维模型：   <br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-image.image" alt="image.png"><br>为了使存在性凸显得更具体，这里我直接把树形结构中每一层对应的可能组合给大家列出来：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root                                            []                  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">数字1——第一层                     </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                   []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">数字2——第二层            [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]            [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]                   [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]         []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">数字3———第三层    [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]     [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]   [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]           [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]   [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]   [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  []</span></span></code></pre></div><p>从 <code>root</code>  出发，每一个数字对应树的一层，<strong>存在或不存在对应树的两个分叉</strong>。从第一层到第三层，我们得到的所有完整路径，就是 3 个数的所有可能的组合形式。  <br><br>我们分析一下这个过程中的递归式与递归边界：</p><ul><li><strong>递归式</strong>：检查手里剩下的数字有哪些（有没有发现和上一道题的递归式是一样的，因为两道题都强调了数字不能重复使用），选取其中一个填进当前的坑里、或者干脆把这个坑空出来（这里就体现出了和上一道题的区别，这道题强调的是存在性而非顺序）。</li><li><strong>递归边界</strong>：组合里数字个数的最大值。拿示例来说，只给了 3 个数，因此组合里数字最多也只有 3 个，超过 3 个则视为触碰递归边界。</li></ul><p><br>按照这个思路，可以编码如下：  <br>   <a name="NjlCx"></a></p><h3 id="编码实现-1" tabindex="-1">编码实现 <a class="header-anchor" href="#编码实现-1" aria-label="Permalink to &quot;编码实现&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[]}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[][]}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 入参是一个数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subsets</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 初始化结果数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 缓存数组长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 初始化组合数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> subset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 进入 dfs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 定义 dfs 函数，入参是 nums 中的数字索引</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(subset.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 从当前数字的索引开始，遍历 nums</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">len;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 这是当前数字存在于组合中的情况</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            subset.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nums[i]) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 基于当前数字存在于组合中的情况，进一步 dfs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 这是当前数字不存在与组合中的情况</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            subset.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回结果数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><a name="gW7Nk"></a></p><h3 id="编码复盘" tabindex="-1">编码复盘 <a class="header-anchor" href="#编码复盘" aria-label="Permalink to &quot;编码复盘&quot;">​</a></h3><p>这道题和上一道题的基本思路高度一致，但是在实现上有些差别。对初学者来说，即便是非常微小的变化也有可能引起困惑。因此，我在这里针对编码部分变化的内容作进一步讲解： <br></p><ul><li>递归式的变化：在上一道题中，我们检查一个数字是否可用的依据是它是否已被纳入当前排列（ <code>visited</code> 值是否为 1），而这道题中，并不存在一个类似 <code>visited</code> 一样的标记对象。取而代之的，是每次直接以 <code>index</code> 作为了索引起点。这是因为，在排列场景下，一个元素可能出现在任何坑位里；而在组合场景下，坑位的选择逻辑发生了变化，坑位和元素是一一对应的。因此讨论完一个坑位的取舍后，一个元素的取舍也相应地讨论完毕了，直接跳过这个元素的索引往下走即可。</li><li>递归边界的变化：这道题中，并没有显式的 <code>return</code> 语句来标示递归边界的存在。这个边界的判定被 <code>for</code> 语句偷偷地做掉了： <code>for</code> 语句会遍历所有的数字，当数字遍历完全时，也就意味着递归走到了尽头。<br></li></ul><br><p><a name="BkLyC"></a></p><h2 id="限定组合问题-及时回溯-即为-剪枝" tabindex="-1">限定组合问题：及时回溯，即为“剪枝” <a class="header-anchor" href="#限定组合问题-及时回溯-即为-剪枝" aria-label="Permalink to &quot;限定组合问题：及时回溯，即为“剪枝”&quot;">​</a></h2><blockquote><p>题目描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</p></blockquote><blockquote><p>示例: 输入: n = 4, k = 2<br> 输出:<br> [<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br> ]</p></blockquote><p><a name="v6ZzY"></a></p><h3 id="思路分析-2" tabindex="-1">思路分析 <a class="header-anchor" href="#思路分析-2" aria-label="Permalink to &quot;思路分析&quot;">​</a></h3><p>这是一道复杂化的组合问题，它追加了一个限定条件——只返回 n 个数中 k 个数的组合。在普通的组合问题中，树形逻辑是这样的：  <br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-image.image" alt="image.png"><br><br>而在这道题里，树形逻辑被“截胡”了，它要求我们只输出其中的一部分。假如 n=3， k=2，那么需要输出的内容就如下图的红色箭头所示：   <br>  <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a254223576~tplv-t2oaga2asx-image.image" alt="image.png"><br><br>我们发现，只有双向箭头所指的结点组合被认为是有效结果，其它结点都被丢弃了。在寻找这三对结点组合的过程中，我们一旦找到一对，就停止继续往深处搜索，这就意味着一些结点压根没有机会被遍历到。<br><br>这其实就是“剪枝”的过程——在深度优先搜索中，<strong>有时我们会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案。这个丢掉答案的过程，形似剪掉树的枝叶，所以这一方法被称为“剪枝”</strong>。   <br><br>在这道题中，要做到剪枝，我们需要分别在组合问题的递归式和递归边界上动手脚：</p><ul><li>递归式：普通组合问题，每到一个新的坑位处，我们都需要对组合结果数组进行更新；这道题中，当且仅当组合内数字个数为 <code>k</code> 个时，才会对组合结果数组进行更新。</li><li>递归边界：只要组合内数字个数达到了 <code>k</code> 个，就不再继续当前的路径往下遍历，而是直接返回。</li></ul><p><br><br>基于这两个改造点，我们可以编码如下：   <br>   <a name="W7wvf"></a></p><h3 id="编码实现-2" tabindex="-1">编码实现 <a class="header-anchor" href="#编码实现-2" aria-label="Permalink to &quot;编码实现&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {number[][]}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> combine</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">k</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 初始化结果数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 初始化组合数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> subset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 进入 dfs，起始数字是1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 定义 dfs 函数，入参是当前遍历到的数字</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(subset.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(subset.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 从当前数字的值开始，遍历 index-n 之间的所有数字</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">n;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 这是当前数字存在于组合中的情况</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            subset.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 基于当前数字存在于组合中的情况，进一步 dfs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 这是当前数字不存在与组合中的情况</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            subset.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回结果数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>注意这道题中虽然没有直接给出一个 <code>nums</code> 数组，而是直接约定了数字的范围为 <code>1-n</code> ，但其本质仍然是一个数字集合，我们像上面这样稍微调整下取值方式即可。</p><h2 id="概念复盘-何为-回溯" tabindex="-1">概念复盘：何为“回溯”？ <a class="header-anchor" href="#概念复盘-何为-回溯" aria-label="Permalink to &quot;概念复盘：何为“回溯”？&quot;">​</a></h2><p>现在，或许你还暂时不知道何为“回溯算法”，但你其实已经实打实地在真题中对它有了具体的实践。基于这些实践，我们反过来理解一下回溯的概念：</p><blockquote><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。<br> 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。<br> 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。<br> 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 ——LeetCode</p></blockquote><p>我们重点关注这句话：“回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。”   <br>  <br>有没有发现，这个“回溯算法”和上一节的 <code>DFS</code> ，好像翻来覆去是在讲同一件事情？   <br>实际上，这里的“回溯”二字，大家可以理解为是在强调 <code>DFS</code> 过程中“退一步重新选择”这个动作。这样想的话， <code>DFS</code> 算法其实就是回溯思想的体现。      <br><br>这里顺便给大家提个醒：一些同学在平时的刷题和面试中，会因为对“回溯”的定义感到困惑，进而拼命地钻牛角尖，这样的做法是非常不可取的。<br> 早年笔者有过一段短暂的 ACMer 生涯，彼时关于回溯，老师曾经给出过一个这样的解读：“在我们接下来要应对的题目里，有递归就会有回溯。回溯算法的特别之处，在于其对应的题目往往要求你在递归过程中求出一个确切的解”。后来笔者自己乱七八糟地读了一堆算法相关的“名著”，其中又有一本书这样定义回溯：“涉及剪枝操作的递归，我们一般称之为回溯”。    <br>  <br>大家会发现，关于回溯算法的定义，可以说是仁者见仁、智者见智。这也是我不建议大家从概念入手去学算法的一个原因——反复纠结文字游戏，无法给你带来任何实质上的能力提升。在实际面试中，没有一个面试官会要求你默写算法的定义，他关注的一定是你的解题思路和编码内容——什么都是浮云，能把题做出来，才是王道！<br></p><p><a name="Ph6KJ"></a></p><h2 id="递归与回溯问题——解题模板总结" tabindex="-1">递归与回溯问题——解题模板总结 <a class="header-anchor" href="#递归与回溯问题——解题模板总结" aria-label="Permalink to &quot;递归与回溯问题——解题模板总结&quot;">​</a></h2><p>做完了楼上三道典型例题，相信大家此时都有了一些微妙的感觉——这三道题的解题方法是非常相似的，是不是意味着涉及递归回溯、或者说涉及 <code>DFS</code> 应用的题目，都有某种共通之处呢？会不会存在某种解题套路，可以帮助我们知一解百、举一反 N 呢？   <br>能想到这一层的老铁，我要给你双击一个巨大的 666——善于总结，积极寻找题目与题目之间的关联，尝试发掘题目中反映出来的规律，这都是非常棒的学习习惯。   <br>  <br>对于递归回溯系列的问题，笔者自己在刷题过程中总结出了一套模板。在这套模板的引导下，笔者至今还没有在递归回溯问题上翻过车。在这里我和大家分享这套模板，同时也希望各位在身经百战之后，能够针对不同类型的问题，尝试去总结一套属于你自己的解题模板。     <br>  <br>如何总结出一套解题模板？其实很简单，大家只需要搞清楚三个问题：</p><ol><li>什么时候用？（明确场景）</li><li>为什么这样用？（提供依据）</li><li>怎么用？（细化步骤）</li></ol><p><br>拿这个专题来说，我给出的解题模板内容如下：  <br></p><p><a name="HbP9b"></a></p><h4 id="什么时候用" tabindex="-1">什么时候用 <a class="header-anchor" href="#什么时候用" aria-label="Permalink to &quot;什么时候用&quot;">​</a></h4><p>看两个特征：</p><ol><li>题目中暗示了一个或多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯。</li><li>题目经分析后，可以转化为树形逻辑模型求解。</li></ol><p><strong>为什么这样用</strong><br>递归与回溯的过程，本身就是穷举的过程。题目中要求我们列举每一个解的内容，解从哪来？解是基于穷举思想、对搜索树进行恰当地剪枝后得来的。   <br></p><div class="language-! vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">!</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>这里需要大家注意到另一种问法：不问解的内容，只问解的个数。这类问题往往不用 DFS 来解，而是用动态规划（我们后面会学）。这里，大家先记下这个辨析，对以后做题会有帮助。</span></span></code></pre></div><p><strong>怎么用</strong><br>一个模型——树形逻辑模型；两个要点——递归式和递归边界。<br>树形逻辑模型的构建，关键在于找“坑位”，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。至于递归边界，要么在题目中约束得非常清楚、要么默认为“坑位”数量的边界。  <br>用伪代码总结一下编码形式，大部分的题解都符合以下特征：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> xxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">入参</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  前期的变量定义、缓存等准备工作 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 定义路径栈</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 进入 dfs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(起点) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 定义 dfs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(递归参数) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(到达了递归边界) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      结合题意处理边界逻辑，往往和 path 内容有关</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 注意这里也可能不是 for，视题意决定</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(遍历坑位的可选值) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(当前选中值)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      处理坑位本身的相关逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在面试中，如果你隐约觉得这道题用递归回溯来解可能有戏，却一时间没办法明确具体的解法，那么不妨尝试把这段伪代码记在脑子里。在面试时，先把框架写出来，然后结合题意去调整和填充伪代码的内容——很多时候，我们做题缺的不是知识储备，而是一个具体的切入点。</p><p>（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）</p></div></div></main><footer class="VPDocFooter" data-v-2a8ae8ad data-v-d81114b5><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-d81114b5><span class="visually-hidden" id="doc-footer-aria-label" data-v-d81114b5>Pager</span><div class="pager" data-v-d81114b5><a class="VPLink link pager-link prev" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/14%20%E9%81%8D%E5%8E%86%E4%B8%93%E9%A2%98%EF%BC%9ADFS%20%E4%B8%8E%20BFS.html" data-v-d81114b5><!--[--><span class="desc" data-v-d81114b5>Previous page</span><span class="title" data-v-d81114b5>14 遍历专题：DFS 与 BFS</span><!--]--></a></div><div class="pager" data-v-d81114b5><a class="VPLink link pager-link next" href="/books/pamphlet/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83/16%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9C%9F%E9%A2%98%E5%BD%92%E7%BA%B3%E4%B8%8E%E8%A7%A3%E8%AF%BB.html" data-v-d81114b5><!--[--><span class="desc" data-v-d81114b5>Next page</span><span class="title" data-v-d81114b5>16 二叉树真题归纳与解读</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"WgeqFTj3\",\"pamphlet_advanced-guide-to-mastering-typescript_1.开篇：用正确的方式学习 typescript.md\":\"DmSUVnqT\",\"pamphlet_advanced-guide-to-mastering-typescript_10.结构化类型系统：类型兼容性判断的幕后.md\":\"CPpk4b4M\",\"pamphlet_advanced-guide-to-mastering-typescript_11.类型系统层级：从 top type 到 bottom type.md\":\"BtCmiXPa\",\"pamphlet_advanced-guide-to-mastering-typescript_12.类型里的逻辑运算：条件类型与 infer.md\":\"Ba6Xr6Yb\",\"pamphlet_advanced-guide-to-mastering-typescript_13.内置工具类型基础：别再妖魔化工具类型了！.md\":\"BjMR1D0U\",\"pamphlet_advanced-guide-to-mastering-typescript_14.反方向类型推导：用好上下文相关类型.md\":\"DB4BXZ5H\",\"pamphlet_advanced-guide-to-mastering-typescript_15.数类型：协变与逆变的比较.md\":\"BqvrUzqc\",\"pamphlet_advanced-guide-to-mastering-typescript_16.了解类型编程与类型体操的意义，找到平衡点.md\":\"DLDTwqSd\",\"pamphlet_advanced-guide-to-mastering-typescript_17.内置工具类型进阶：类型编程进阶.md\":\"24vS5r16\",\"pamphlet_advanced-guide-to-mastering-typescript_18.基础类型新成员：模板字符串类型入门.md\":\"DYe0-aI-\",\"pamphlet_advanced-guide-to-mastering-typescript_19.类型编程新范式：模板字符串工具类型进阶.md\":\"CwesZEWu\",\"pamphlet_advanced-guide-to-mastering-typescript_2.工欲善其事：打造最舒适的 typescript 开发环境.md\":\"5UU9vuIS\",\"pamphlet_advanced-guide-to-mastering-typescript_20.工程层面的类型能力：类型声明、类型指令与命名空间.md\":\"Cr3ikFql\",\"pamphlet_advanced-guide-to-mastering-typescript_21.在 react 中愉快地使用 typescript：内置类型与泛型坑位.md\":\"F35gI1sV\",\"pamphlet_advanced-guide-to-mastering-typescript_22.让 eslint 来约束你的 typescript 代码：配置与规则集介绍.md\":\"Cf6fP42Z\",\"pamphlet_advanced-guide-to-mastering-typescript_23.全链路 typescript 工具库，找到适合你的工具.md\":\"DjZjdpqu\",\"pamphlet_advanced-guide-to-mastering-typescript_24.说说 typescript 和 ecmascript 之间那些事儿.md\":\"DjiHD1ZL\",\"pamphlet_advanced-guide-to-mastering-typescript_25.装饰器与反射元数据：了解装饰器基本原理与应用.md\":\"DO5tyI8n\",\"pamphlet_advanced-guide-to-mastering-typescript_26.控制反转与依赖注入：基于装饰器的依赖注入实现.md\":\"D5PoZEUp\",\"pamphlet_advanced-guide-to-mastering-typescript_27.tsconfig 全解（上）：构建相关配置.md\":\"BOQBTyWY\",\"pamphlet_advanced-guide-to-mastering-typescript_28.tsconfig 全解（下）：检查相关、工程相关配置.md\":\"cZs2hsd1\",\"pamphlet_advanced-guide-to-mastering-typescript_29.基于 prisma _ nestjs 的 node api ：前置知识储备.md\":\"R8XpGQKL\",\"pamphlet_advanced-guide-to-mastering-typescript_3.进入类型的世界：理解原始类型与对象类型.md\":\"CNT96xXR\",\"pamphlet_advanced-guide-to-mastering-typescript_30.基于 prisma _ nestjs 的 node api ：项目开发与基于 heroku 部署.md\":\"W4A5Dz0F\",\"pamphlet_advanced-guide-to-mastering-typescript_31.玩转 typescript ast：ast checker 与 codemod.md\":\"BzFvNbXa\",\"pamphlet_advanced-guide-to-mastering-typescript_32.感谢相伴：是结束，也是开始.md\":\"BXp2k-oy\",\"pamphlet_advanced-guide-to-mastering-typescript_33.漫谈篇：面试中的 typescript.md\":\"DRU5c8cz\",\"pamphlet_advanced-guide-to-mastering-typescript_4.掌握字面量类型与枚举，让你的类型再精确一些.md\":\"6S9h-Nvw\",\"pamphlet_advanced-guide-to-mastering-typescript_5.函数与 class 中的类型：详解函数重载与面向对象.md\":\"DyLPZnlB\",\"pamphlet_advanced-guide-to-mastering-typescript_6.探秘内置类型：any、unknown、never 与类型断言.md\":\"eRZ9l8MV\",\"pamphlet_advanced-guide-to-mastering-typescript_7.类型编程好帮手：typescript 类型工具（上）.md\":\"BdsbkQCD\",\"pamphlet_advanced-guide-to-mastering-typescript_8.类型编程好帮手：typescript 类型工具（下）.md\":\"BAcNv8Oj\",\"pamphlet_advanced-guide-to-mastering-typescript_9.类型编程基石：typescript 中无处不在的泛型.md\":\"CcaFpoZY\",\"pamphlet_babel 插件通关秘籍_1 babel 的介绍.md\":\"BCiYSdME\",\"pamphlet_babel 插件通关秘籍_10 babel 插件和 preset.md\":\"CPZPwTUD\",\"pamphlet_babel 插件通关秘籍_11 babel 插件的单元测试.md\":\"CZ3NRLP9\",\"pamphlet_babel 插件通关秘籍_12 babel 的内置功能（上）.md\":\"BeW2CIMw\",\"pamphlet_babel 插件通关秘籍_13 babel 的内置功能（下）.md\":\"BVhrGvJw\",\"pamphlet_babel 插件通关秘籍_14 babel 配置的原理.md\":\"BI4bH9ST\",\"pamphlet_babel 插件通关秘籍_15 工具介绍：vscode debugger 的使用.md\":\"D98e35bu\",\"pamphlet_babel 插件通关秘籍_16 实战案例：自动埋点.md\":\"irHDl4En\",\"pamphlet_babel 插件通关秘籍_17 实战案例-自动国际化.md\":\"CMeaePGb\",\"pamphlet_babel 插件通关秘籍_18 实战案例-自动生成 api 文档.md\":\"BUIEbg5O\",\"pamphlet_babel 插件通关秘籍_19 实战案例-linter.md\":\"Cy5QBXKO\",\"pamphlet_babel 插件通关秘籍_2 babel 的编译流程.md\":\"DlNsu0RJ\",\"pamphlet_babel 插件通关秘籍_20 实战案例-类型检查.md\":\"CdYAY5Dw\",\"pamphlet_babel 插件通关秘籍_21 实战案例-压缩混淆.md\":\"la52pIoU\",\"pamphlet_babel 插件通关秘籍_22 实战案例-js 解释器.md\":\"Cxvse2Y_\",\"pamphlet_babel 插件通关秘籍_23 实战案例-模块遍历.md\":\"BJDm_EVZ\",\"pamphlet_babel 插件通关秘籍_24 babel macros.md\":\"DlUgah5e\",\"pamphlet_babel 插件通关秘籍_25 如何调试 babel 源码？.md\":\"CjYRxMzu\",\"pamphlet_babel 插件通关秘籍_26 手写 babel：思路篇.md\":\"CtyU0e9F\",\"pamphlet_babel 插件通关秘籍_27 手写 babel： parser 篇.md\":\"ChkaEM7N\",\"pamphlet_babel 插件通关秘籍_28 手写 babel： traverse 篇.md\":\"D92rswsn\",\"pamphlet_babel 插件通关秘籍_29 手写 babel： traverse -- path篇.md\":\"BTqz3BT9\",\"pamphlet_babel 插件通关秘籍_3 babel 的 ast.md\":\"Bpx25q1R\",\"pamphlet_babel 插件通关秘籍_30 手写 babel： traverse -- scope篇.md\":\"gM70OjHN\",\"pamphlet_babel 插件通关秘籍_31 手写 babel： generator篇.md\":\"Rx916kjC\",\"pamphlet_babel 插件通关秘籍_32 手写 babel： core篇.md\":\"CRWrpar2\",\"pamphlet_babel 插件通关秘籍_33 手写 babel： cli篇.md\":\"C34G_y0O\",\"pamphlet_babel 插件通关秘籍_34 手写 babel： 总结.md\":\"BAIp7kjh\",\"pamphlet_babel 插件通关秘籍_35 小册总结.md\":\"Doz__-Sw\",\"pamphlet_babel 插件通关秘籍_36 加餐：会了 babel 插件，就会写 prettier 插件.md\":\"Df2P1YJ8\",\"pamphlet_babel 插件通关秘籍_4 babel 的 api.md\":\"DknOTeIS\",\"pamphlet_babel 插件通关秘籍_5 实战案例：插入函数调用参数.md\":\"CnExLr6N\",\"pamphlet_babel 插件通关秘籍_6 js parser 的历史.md\":\"CLHj8dH1\",\"pamphlet_babel 插件通关秘籍_7 traverse 的 path、scope、visitor.md\":\"CCOJYvtn\",\"pamphlet_babel 插件通关秘籍_8 generator 和 sourcemap 的奥秘.md\":\"r0_u5Iom\",\"pamphlet_babel 插件通关秘籍_9 code- frame 和代码高亮原理.md\":\"7IuvK7vt\",\"pamphlet_webgl 入门与实践_1 初级入门 --- 认识 webgl.md\":\"D2ovrDOX\",\"pamphlet_webgl 入门与实践_10 中级进阶 --- 神说要有光，于是就有了光：给物体添加环境光。.md\":\"BHu-zINj\",\"pamphlet_webgl 入门与实践_11 中级进阶 --- 冯氏光照模型：为物体增加漫反射效果.md\":\"CAgnIaqi\",\"pamphlet_webgl 入门与实践_12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果.md\":\"BgbMmqf-\",\"pamphlet_webgl 入门与实践_13  中级进阶 --- 深入理解 glsl 语法.md\":\"CRuIZ5p5\",\"pamphlet_webgl 入门与实践_14 中级进阶 --- webgl 与数学：我们需要哪些数学知识？.md\":\"BZnj4d22\",\"pamphlet_webgl 入门与实践_15 中级进阶 --- 数学：点、向量、矩阵。.md\":\"Ct2vI7Y-\",\"pamphlet_webgl 入门与实践_16 中级进阶 ---  通用数学库的 javascript 实现。.md\":\"JfbUq6ma\",\"pamphlet_webgl 入门与实践_17 中级进阶 --- webgl 坐标系.md\":\"BpskpQ68\",\"pamphlet_webgl 入门与实践_18 中级进阶 --- 坐标系变换：基本变换原理与算法实现.md\":\"Dnt_phau\",\"pamphlet_webgl 入门与实践_19 中级进阶 --- 坐标系变换：模型空间变换到世界空间.md\":\"C18a_aev\",\"pamphlet_webgl 入门与实践_2 初级入门 --- 从一个点开始：掌握 webgl 的编程要素.md\":\"B-OaeGXq\",\"pamphlet_webgl 入门与实践_20 中级进阶 --- 坐标系变换：世界空间变换到观察空间.md\":\"D0csI_Ib\",\"pamphlet_webgl 入门与实践_21 中级进阶 --- 坐标系变换：观察空间变换到裁剪空间.md\":\"D2G5mbtT\",\"pamphlet_webgl 入门与实践_22 深入研究 --- 更高级的旋转：欧拉角、四元数。.md\":\"t7KrOiMo\",\"pamphlet_webgl 入门与实践_23 深入研究 --- 四元数的应用：使用鼠标控制模型的旋转.md\":\"BGNEknIQ\",\"pamphlet_webgl 入门与实践_24 深入研究 --- css 与 3d 之 transform.md\":\"DYLdHPVc\",\"pamphlet_webgl 入门与实践_25 深入研究 --- css 与 3d 之 perspective.md\":\"DxcAYtiJ\",\"pamphlet_webgl 入门与实践_26 深入研究 --- 数学库在 css 的 3d 动画中扮演的重要角色.md\":\"Bm60DMfV\",\"pamphlet_webgl 入门与实践_27 深入探究 --- 层级建模：行走的机器人.md\":\"CuEFUDGr\",\"pamphlet_webgl 入门与实践_28 深入研究 --- 使用立方体纹理绘制天空盒.md\":\"DDpfA-Ae\",\"pamphlet_webgl 入门与实践_29 深入研究 --- 混合效果.md\":\"CviXlm4q\",\"pamphlet_webgl 入门与实践_3 初级入门 --- 绘制三角形：学会使用缓冲区、了解 webgl 中的基本图形元素.md\":\"DpNJ8f-4\",\"pamphlet_webgl 入门与实践_30 深入研究 --- 帧缓冲.md\":\"cEjOgihf\",\"pamphlet_webgl 入门与实践_31 高级应用 --- 3d模型的拾取原理与实现.md\":\"CQAysc0G\",\"pamphlet_webgl 入门与实践_32 高级应用 --- 魔法 shader：火焰效果的原理与实现.md\":\"BLFdEght\",\"pamphlet_webgl 入门与实践_33 结束了吗？一切刚刚开始.md\":\"-0Rqe-la\",\"pamphlet_webgl 入门与实践_4 初级入门 --- 基本图元绘制：线段.md\":\"YLKfKb69\",\"pamphlet_webgl 入门与实践_5 初级入门 --- 绘制渐变三角形：深入理解缓冲区.md\":\"9MSbB5o6\",\"pamphlet_webgl 入门与实践_6 初级入门 --- 画个矩形：用基本图形构建平面.md\":\"DJqGr6JB\",\"pamphlet_webgl 入门与实践_7 初级入门 --- 纹理贴图：为形体穿上外衣.md\":\"CjKl8T9H\",\"pamphlet_webgl 入门与实践_8 初级入门 --- 绘制立方体、球体、椎体：如何用基本图形构建规则形体.md\":\"5CBoqfv9\",\"pamphlet_webgl 入门与实践_9 初级入门 --- 绘制多个物体：进一步封装绘制方法.md\":\"DYpvsZgk\",\"pamphlet_webpack5_1 重新认识 webpack：旧时代的破局者.md\":\"pJf7ZKbI\",\"pamphlet_webpack5_10 深入理解图像加载原理与最佳实践.md\":\"Dtrgvq-q\",\"pamphlet_webpack5_11 深入理解 webpack 核心配置结构.md\":\"Bs70fBmn\",\"pamphlet_webpack5_12 构建性能：分享 7 款常用的性能分析工具.md\":\"CcXCtIha\",\"pamphlet_webpack5_13 如何使用 webpack 持久化缓存大幅提升构建性能？.md\":\"CxYeeE_e\",\"pamphlet_webpack5_14 webpack 都有哪些实现并行构建的方法？.md\":\"B80y9fPd\",\"pamphlet_webpack5_15 有哪些值得学习的构建性能极致优化技巧？.md\":\"Doslxswz\",\"pamphlet_webpack5_16 如何正确使用 splitchunks提升应用性能？.md\":\"BAYCCY_0\",\"pamphlet_webpack5_17 不止 terser：揭秘代码压缩的门门道道.md\":\"ZtA2qgDs\",\"pamphlet_webpack5_18 还有哪些值得学习的应用性能极致优化技巧？.md\":\"CL6HdaYi\",\"pamphlet_webpack5_19 loader 开发基础：从开源项目学到的 loader 开发技巧.md\":\"UQNk86gS\",\"pamphlet_webpack5_2 如何理解 webpack 配置底层结构逻辑？.md\":\"D0Y3VOoz\",\"pamphlet_webpack5_20 loader 开发进阶：如何用好 loader 扩展开发工具？.md\":\"BooQ2aG3\",\"pamphlet_webpack5_21 插件开发基础：实例剖析插件基本形态与架构逻辑.md\":\"Bg-hdlrs\",\"pamphlet_webpack5_22 插件开发进阶：如何提升插件健壮性？.md\":\"C7u9PrcF\",\"pamphlet_webpack5_23 插件架构：hook 体系是如何影响 webpack 架构的？.md\":\"0-yZvOEd\",\"pamphlet_webpack5_24 init、make、seal：真正读懂 webpack 核心流程.md\":\"CxgffTGl\",\"pamphlet_webpack5_25 dependency graph：如何管理模块间依赖？.md\":\"DtmNmFon\",\"pamphlet_webpack5_26 chunk：三种产物的打包逻辑.md\":\"Du0flIVd\",\"pamphlet_webpack5_27 runtime：模块编译打包及运行时逻辑.md\":\"Dkmfds2n\",\"pamphlet_webpack5_28 tree-shaking：如何删除无用模块导出？.md\":\"DkCyqphG\",\"pamphlet_webpack5_29 sourcemap：源码映射原理与应用技巧.md\":\"Dxaamzlk\",\"pamphlet_webpack5_3 如何借助 babel_ts_eslint 构建现代 js 工程环境？.md\":\"DVASA9qF\",\"pamphlet_webpack5_30 hmr：如何动态替换页面代码？.md\":\"xNyJg7Cr\",\"pamphlet_webpack5_4 如何借助预处理器、postcss 等构建现代 css 工程环境？.md\":\"DyHWH_uo\",\"pamphlet_webpack5_5 如何搭建 vue 全栈开发环境？.md\":\"CwIoe6Md\",\"pamphlet_webpack5_6 如何搭建 react 全栈开发环境？.md\":\"Bl-nc59A\",\"pamphlet_webpack5_7 使用 webpack 构建 npm library 的正确方式.md\":\"aiCSGqMb\",\"pamphlet_webpack5_8 使用 webpack 构建微前端应用.md\":\"CL0PPv_S\",\"pamphlet_webpack5_9 如何借助 webpack 开发 pwa、node、electron 应用？.md\":\"Ddd0833k\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略.md\":\"CyNPbggH\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_10 快慢指针与多指针——玩转链表复杂操作.md\":\"hGBDf9KH\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_11 姿势特别的链表——环形链表专题.md\":\"Bv8Brfms\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_12 栈与队列怎么玩（上）.md\":\"53YPPWKL\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_13 栈与队列怎么玩（下）.md\":\"DCnQGpnI\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_14 遍历专题：dfs 与 bfs.md\":\"Y25TC8E3\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_15 场景化解读：递归与回溯思想在真题中的应用.md\":\"DRXfQflY\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_16 二叉树真题归纳与解读.md\":\"DxLbuz6k\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_17 特殊的二叉树——二叉搜索树专题.md\":\"B6KzKVpN\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_18 特殊的二叉树——平衡二叉树专题.md\":\"Bccc2X9O\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_19 特殊的二叉树——堆结构及其在排序中的应用.md\":\"CLoDOhdn\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_2 快速上手——从0到1掌握算法面试需要的数据结构（一）.md\":\"CLRytReU\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_20 排序算法专题（上）.md\":\"CcvhbS5w\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_21 排序算法专题（下）.md\":\"CNPLnWmZ\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_22 普通人也能吃透的动态规划思想专题（上）.md\":\"CLAF5i97\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_23 普通人也能吃透的动态规划思想专题（下）.md\":\"Dg3lERrT\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_24 大厂真题训练与解读——微软真题.md\":\"CIrqVPM5\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_25 大厂真题训练与解读——google 真题.md\":\"8p1tDgJZ\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_26 大厂真题训练与解读——腾讯真题.md\":\"CHMy4KEH\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_27 大厂真题训练与解读——头条真题.md\":\"DmMGtNYP\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_28 思维课：算法面试的评价逻辑.md\":\"D10rVhnU\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_3 快速上手——从0到1掌握算法面试需要的数据结构（二）.md\":\"BNk9YrBg\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_4 快速上手——从0到1掌握算法面试需要的数据结构（三）.md\":\"Den1pt7l\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_5 递归初相见——二叉树递归遍历的三种姿势.md\":\"BPUEN0Mv\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_6 算法的衡量——轻松理解时间复杂度与空间复杂度.md\":\"DqNE9OjF\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_7 数组的应用——真题归纳与解读.md\":\"UL4HCZ0C\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_8 字符串的应用——真题归纳与解读.md\":\"C717H1nR\",\"pamphlet_前端算法与数据结构面试：底层逻辑解读与大厂真题训练_9 链表的应用——真题归纳与解读.md\":\"BMSkkG03\",\"pamphlet_基于 vite 的组件库工程化实战_1 开篇词：学习前端工程化就从搭建组件库开始.md\":\"1kzkPbQD\",\"pamphlet_基于 vite 的组件库工程化实战_10 开发许可证：维护自己的版权、拒绝拿来党.md\":\"Bks_E7iO\",\"pamphlet_基于 vite 的组件库工程化实战_11 组件发布： 建立语义化版本与提交软件包仓库 npm.md\":\"CWDDx6sX\",\"pamphlet_基于 vite 的组件库工程化实战_12 建立组件库生态： 利用 monorepo 方式管理组件库生态.md\":\"D4c0KsJD\",\"pamphlet_基于 vite 的组件库工程化实战_13 按需引入实现组件库的按需引入功能.md\":\"DvOftsMa\",\"pamphlet_基于 vite 的组件库工程化实战_14 文档部署： 用 vercel 部署你的线上文档.md\":\"KzJeJ9yz\",\"pamphlet_基于 vite 的组件库工程化实战_15 readme： 编写标准的 readme.md\":\"D9wuhH8V\",\"pamphlet_基于 vite 的组件库工程化实战_16 品质保证：覆盖率测试报告.md\":\"CKtSsqBE\",\"pamphlet_基于 vite 的组件库工程化实战_17 社区参与： 如何管理社区的 pullrequest？.md\":\"BJQ0SfSk\",\"pamphlet_基于 vite 的组件库工程化实战_18 敏捷开发： 用 github 看板和 issue 管理需求.md\":\"nhPdqAGI\",\"pamphlet_基于 vite 的组件库工程化实战_19 架构复用： 创建 cli 工具提高研发体验.md\":\"Bo5q2C6R\",\"pamphlet_基于 vite 的组件库工程化实战_2 mvp原型系统： 将组件封装为组件库.md\":\"4JiADEa2\",\"pamphlet_基于 vite 的组件库工程化实战_20 融入开源生态： 编写 npm init 项目让用户更方便.md\":\"C-sFfQk6\",\"pamphlet_基于 vite 的组件库工程化实战_21 加餐1：类型系统：导出组件库的类型定义.md\":\"L91NiBEc\",\"pamphlet_基于 vite 的组件库工程化实战_22 结语｜当好项目的开路先锋.md\":\"CND4cG-y\",\"pamphlet_基于 vite 的组件库工程化实战_3 css样式：用unocss实现原子化css.md\":\"YFaJcaWa\",\"pamphlet_基于 vite 的组件库工程化实战_4 文档建设：创建具备demo示例功能的文档网站.md\":\"ClDnErko\",\"pamphlet_基于 vite 的组件库工程化实战_5 单元测试(一)： 使用jest进行前端单元测试.md\":\"ltLxlDII\",\"pamphlet_基于 vite 的组件库工程化实战_6 单元测试 (二)： 搭建vitest的单元测试环境.md\":\"DJhJy5Ze\",\"pamphlet_基于 vite 的组件库工程化实战_7 规范化： eslint _ prettier _ husky.md\":\"Wgaob5Lj\",\"pamphlet_基于 vite 的组件库工程化实战_8 软件包封装： 如何发布兼容多种 js 模块标准的软件包？.md\":\"D47wFuGZ\",\"pamphlet_基于 vite 的组件库工程化实战_9 持续集成 ci： 基于 github action 的回归验证.md\":\"B1-iIV0X\",\"pamphlet_玩转css艺术之美_1.准备篇：学前准备.md\":\"BYR6FIpP\",\"pamphlet_玩转css艺术之美_10.技巧篇：背景与遮罩.md\":\"MiFT5noe\",\"pamphlet_玩转css艺术之美_11.技巧篇：阴影与滤镜.md\":\"BqIvzkxX\",\"pamphlet_玩转css艺术之美_12.技巧篇：变换与动画.md\":\"DrJbXnuN\",\"pamphlet_玩转css艺术之美_13.实战篇：实战大操作-切换控件.md\":\"BpOoAw29\",\"pamphlet_玩转css艺术之美_14.实战篇：实战大操作-表单控件.md\":\"q-9ZN3MO\",\"pamphlet_玩转css艺术之美_15.实战篇：实战大操作-变量控件.md\":\"qNtX4TaP\",\"pamphlet_玩转css艺术之美_16.总结篇：玩转css艺术之美.md\":\"w7SagsOO\",\"pamphlet_玩转css艺术之美_2.基础篇：浏览器.md\":\"Bx0p4mMv\",\"pamphlet_玩转css艺术之美_3.进阶篇：回流重绘.md\":\"CoX_ZkJn\",\"pamphlet_玩转css艺术之美_4.基础篇：盒模型.md\":\"DmLMPeQB\",\"pamphlet_玩转css艺术之美_5.基础篇：样式计算.md\":\"2BNBlFHk\",\"pamphlet_玩转css艺术之美_6.进阶篇：布局样式.md\":\"D_SbEab8\",\"pamphlet_玩转css艺术之美_7.进阶篇：函数计算.md\":\"SvQsTQ6A\",\"pamphlet_玩转css艺术之美_8.进阶篇：变量计算.md\":\"DBVCvZNd\",\"pamphlet_玩转css艺术之美_9.技巧篇：选择器.md\":\"DSdSa4WE\",\"pamphlet_防御式 css 精讲_1 推荐序｜克军：写好 css 是需要经验的.md\":\"H88tsFw8\",\"pamphlet_防御式 css 精讲_10 你不知道的 border-radius.md\":\"qLnpjZEZ\",\"pamphlet_防御式 css 精讲_11 web 中的阴影.md\":\"Dh9JO6xZ\",\"pamphlet_防御式 css 精讲_12 web 中的边框.md\":\"DwDVNMHg\",\"pamphlet_防御式 css 精讲_13 响应式图片：防止图片的拉伸或挤压.md\":\"CGHn1GIC\",\"pamphlet_防御式 css 精讲_14 如何提高图片上文本的可读性？.md\":\"DkSkR0WI\",\"pamphlet_防御式 css 精讲_15 你不知道的 css 渐变.md\":\"j1SPdKAx\",\"pamphlet_防御式 css 精讲_16 web 图片：你不应该遗忘的 css 技巧.md\":\"CVkShDQu\",\"pamphlet_防御式 css 精讲_17 图片的裁剪术.md\":\"D6XQpm42\",\"pamphlet_防御式 css 精讲_18  重新思考 web 中的裁剪：css 还是 svg？.md\":\"DDDm5Om9\",\"pamphlet_防御式 css 精讲_19 css 如何改善滚动体验.md\":\"BS7rx-U_\",\"pamphlet_防御式 css 精讲_2 如何根据 ui 形式选择视觉盒模型？.md\":\"CRbx0C9A\",\"pamphlet_防御式 css 精讲_20 美化滚动条 ui：自定义滚动条 ui.md\":\"DIRWpXBO\",\"pamphlet_防御式 css 精讲_21 css 的滚动捕捉.md\":\"DARpjRPQ\",\"pamphlet_防御式 css 精讲_22 溢出常见问题与排查.md\":\"C17GCquS\",\"pamphlet_防御式 css 精讲_23 易碎的容器盒子：避免使用固定尺寸和长内容设置.md\":\"XgD0q8o_\",\"pamphlet_防御式 css 精讲_24 使用逻辑属性来替代物理属性.md\":\"olctqkw2\",\"pamphlet_防御式 css 精讲_25 多语言 web 应用需要注意的细节.md\":\"ClgJhi3U\",\"pamphlet_防御式 css 精讲_26 条件 css 之 @规则和 css 选择器.md\":\"DNiRijC-\",\"pamphlet_防御式 css 精讲_27 条件 css 之 css 属性值和 css 函数.md\":\"BMiQ3oA8\",\"pamphlet_防御式 css 精讲_28 css 的黑魔法.md\":\"7P3U2zAH\",\"pamphlet_防御式 css 精讲_3 flexbox 和 grid 中的换行.md\":\"DV1yOOQD\",\"pamphlet_防御式 css 精讲_4 flexbox 和 grid 中的最小内容尺寸.md\":\"P-N8vHxm\",\"pamphlet_防御式 css 精讲_5 布局中的滚动失效和默认拉伸.md\":\"CgH7nEaH\",\"pamphlet_防御式 css 精讲_6 固定网格轨道尺寸给 web 布局带来的局限性.md\":\"D_EsDEnG\",\"pamphlet_防御式 css 精讲_7 如何灵活设置元素之间的间距？.md\":\"We3s-nL4\",\"pamphlet_防御式 css 精讲_8 position sticky 失效与修复.md\":\"BlbsM2-f\",\"pamphlet_防御式 css 精讲_9  z-index 失效与修复.md\":\"CAeCZ8AM\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"刘云露\",\"description\":\"一些有意思的东西\",\"base\":\"/books/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"小册\",\"items\":[{\"text\":\"Webpack5 核心原理与应用实践\",\"link\":\"/pamphlet/webpack5/1 重新认识 Webpack：旧时代的破局者.md\"},{\"text\":\"TypeScript全面进阶指南\",\"link\":\"/pamphlet/advanced-guide-to-mastering-typeScript/1.开篇：用正确的方式学习 TypeScript.md\"},{\"text\":\"玩转css艺术之美\",\"link\":\"/pamphlet/玩转css艺术之美/1.准备篇：学前准备.md\"},{\"text\":\"防御式 CSS 精讲\",\"link\":\"/pamphlet/防御式 CSS 精讲/1 推荐序｜克军：写好 CSS 是需要经验的.md\"},{\"text\":\"基于 Vite 的组件库工程化实战\",\"link\":\"/pamphlet/基于 Vite 的组件库工程化实战/1 开篇词：学习前端工程化就从搭建组件库开始.md\"},{\"text\":\"前端算法与数据结构面试：底层逻辑解读与大厂真题训练\",\"link\":\"/pamphlet/前端算法与数据结构面试：底层逻辑解读与大厂真题训练/1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略.md\"},{\"text\":\"Babel 插件通关秘籍\",\"link\":\"/pamphlet/Babel 插件通关秘籍/1 Babel 的介绍.md\"},{\"text\":\"WebGL 入门与实践\",\"link\":\"/pamphlet/WebGL 入门与实践/1 初级入门 --- 认识 WebGL.md\"}]}],\"sidebar\":{\"/pamphlet/webpack5/\":{\"base\":\"/pamphlet/webpack5/\",\"items\":[{\"text\":\"1 重新认识 Webpack：旧时代的破局者\",\"link\":\"1 重新认识 Webpack：旧时代的破局者\"},{\"text\":\"2 如何理解 Webpack 配置底层结构逻辑？\",\"link\":\"2 如何理解 Webpack 配置底层结构逻辑？\"},{\"text\":\"3 如何借助 Babel+TS+ESLint 构建现代 JS 工程环境？\",\"link\":\"3 如何借助 Babel+TS+ESLint 构建现代 JS 工程环境？\"},{\"text\":\"4 如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？\",\"link\":\"4 如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？\"},{\"text\":\"5 如何搭建 Vue 全栈开发环境？\",\"link\":\"5 如何搭建 Vue 全栈开发环境？\"},{\"text\":\"6 如何搭建 React 全栈开发环境？\",\"link\":\"6 如何搭建 React 全栈开发环境？\"},{\"text\":\"7 使用 Webpack 构建 NPM Library 的正确方式\",\"link\":\"7 使用 Webpack 构建 NPM Library 的正确方式\"},{\"text\":\"8 使用 Webpack 构建微前端应用\",\"link\":\"8 使用 Webpack 构建微前端应用\"},{\"text\":\"9 如何借助 Webpack 开发 PWA、Node、Electron 应用？\",\"link\":\"9 如何借助 Webpack 开发 PWA、Node、Electron 应用？\"},{\"text\":\"10 深入理解图像加载原理与最佳实践\",\"link\":\"10 深入理解图像加载原理与最佳实践\"},{\"text\":\"11 深入理解 Webpack 核心配置结构\",\"link\":\"11 深入理解 Webpack 核心配置结构\"},{\"text\":\"12 构建性能：分享 7 款常用的性能分析工具\",\"link\":\"12 构建性能：分享 7 款常用的性能分析工具\"},{\"text\":\"13 如何使用 Webpack 持久化缓存大幅提升构建性能？\",\"link\":\"13 如何使用 Webpack 持久化缓存大幅提升构建性能？\"},{\"text\":\"14 Webpack 都有哪些实现并行构建的方法？\",\"link\":\"14 Webpack 都有哪些实现并行构建的方法？\"},{\"text\":\"15 有哪些值得学习的构建性能极致优化技巧？\",\"link\":\"15 有哪些值得学习的构建性能极致优化技巧？\"},{\"text\":\"16 如何正确使用 SplitChunks提升应用性能？\",\"link\":\"16 如何正确使用 SplitChunks提升应用性能？\"},{\"text\":\"17 不止 Terser：揭秘代码压缩的门门道道\",\"link\":\"17 不止 Terser：揭秘代码压缩的门门道道\"},{\"text\":\"18 还有哪些值得学习的应用性能极致优化技巧？\",\"link\":\"18 还有哪些值得学习的应用性能极致优化技巧？\"},{\"text\":\"19 Loader 开发基础：从开源项目学到的 Loader 开发技巧\",\"link\":\"19 Loader 开发基础：从开源项目学到的 Loader 开发技巧\"},{\"text\":\"20 Loader 开发进阶：如何用好 Loader 扩展开发工具？\",\"link\":\"20 Loader 开发进阶：如何用好 Loader 扩展开发工具？\"},{\"text\":\"21 插件开发基础：实例剖析插件基本形态与架构逻辑\",\"link\":\"21 插件开发基础：实例剖析插件基本形态与架构逻辑\"},{\"text\":\"22 插件开发进阶：如何提升插件健壮性？\",\"link\":\"22 插件开发进阶：如何提升插件健壮性？\"},{\"text\":\"23 插件架构：Hook 体系是如何影响 Webpack 架构的？\",\"link\":\"23 插件架构：Hook 体系是如何影响 Webpack 架构的？\"},{\"text\":\"24 Init、Make、Seal：真正读懂 Webpack 核心流程\",\"link\":\"24 Init、Make、Seal：真正读懂 Webpack 核心流程\"},{\"text\":\"25 Dependency Graph：如何管理模块间依赖？\",\"link\":\"25 Dependency Graph：如何管理模块间依赖？\"},{\"text\":\"26 Chunk：三种产物的打包逻辑\",\"link\":\"26 Chunk：三种产物的打包逻辑\"},{\"text\":\"27 Runtime：模块编译打包及运行时逻辑\",\"link\":\"27 Runtime：模块编译打包及运行时逻辑\"},{\"text\":\"28 Tree-shaking：如何删除无用模块导出？\",\"link\":\"28 Tree-shaking：如何删除无用模块导出？\"},{\"text\":\"29 Sourcemap：源码映射原理与应用技巧\",\"link\":\"29 Sourcemap：源码映射原理与应用技巧\"},{\"text\":\"30 HMR：如何动态替换页面代码？\",\"link\":\"30 HMR：如何动态替换页面代码？\"}]},\"/pamphlet/advanced-guide-to-mastering-typeScript/\":{\"base\":\"/pamphlet/advanced-guide-to-mastering-typeScript/\",\"items\":[{\"text\":\"1.开篇：用正确的方式学习 TypeScript\",\"link\":\"1.开篇：用正确的方式学习 TypeScript\"},{\"text\":\"2.工欲善其事：打造最舒适的 TypeScript 开发环境\",\"link\":\"2.工欲善其事：打造最舒适的 TypeScript 开发环境\"},{\"text\":\"3.进入类型的世界：理解原始类型与对象类型\",\"link\":\"3.进入类型的世界：理解原始类型与对象类型\"},{\"text\":\"4.掌握字面量类型与枚举，让你的类型再精确一些\",\"link\":\"4.掌握字面量类型与枚举，让你的类型再精确一些\"},{\"text\":\"5.函数与 Class 中的类型：详解函数重载与面向对象\",\"link\":\"5.函数与 Class 中的类型：详解函数重载与面向对象\"},{\"text\":\"6.探秘内置类型：any、unknown、never 与类型断言\",\"link\":\"6.探秘内置类型：any、unknown、never 与类型断言\"},{\"text\":\"7.类型编程好帮手：TypeScript 类型工具（上）\",\"link\":\"7.类型编程好帮手：TypeScript 类型工具（上）\"},{\"text\":\"8.类型编程好帮手：TypeScript 类型工具（下）\",\"link\":\"8.类型编程好帮手：TypeScript 类型工具（下）\"},{\"text\":\"9.类型编程基石：TypeScript 中无处不在的泛型\",\"link\":\"9.类型编程基石：TypeScript 中无处不在的泛型\"},{\"text\":\"10.结构化类型系统：类型兼容性判断的幕后\",\"link\":\"10.结构化类型系统：类型兼容性判断的幕后\"},{\"text\":\"11.类型系统层级：从 Top Type 到 Bottom Type\",\"link\":\"11.类型系统层级：从 Top Type 到 Bottom Type\"},{\"text\":\"12.类型里的逻辑运算：条件类型与 infer\",\"link\":\"12.类型里的逻辑运算：条件类型与 infer\"},{\"text\":\"13.内置工具类型基础：别再妖魔化工具类型了！\",\"link\":\"13.内置工具类型基础：别再妖魔化工具类型了！\"},{\"text\":\"14.反方向类型推导：用好上下文相关类型\",\"link\":\"14.反方向类型推导：用好上下文相关类型\"},{\"text\":\"15.数类型：协变与逆变的比较\",\"link\":\"15.数类型：协变与逆变的比较\"},{\"text\":\"16.了解类型编程与类型体操的意义，找到平衡点\",\"link\":\"16.了解类型编程与类型体操的意义，找到平衡点\"},{\"text\":\"17.内置工具类型进阶：类型编程进阶\",\"link\":\"17.内置工具类型进阶：类型编程进阶\"},{\"text\":\"18.基础类型新成员：模板字符串类型入门\",\"link\":\"18.基础类型新成员：模板字符串类型入门\"},{\"text\":\"19.类型编程新范式：模板字符串工具类型进阶\",\"link\":\"19.类型编程新范式：模板字符串工具类型进阶\"},{\"text\":\"20.工程层面的类型能力：类型声明、类型指令与命名空间\",\"link\":\"20.工程层面的类型能力：类型声明、类型指令与命名空间\"},{\"text\":\"21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位\",\"link\":\"21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位\"},{\"text\":\"22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍\",\"link\":\"22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍\"},{\"text\":\"23.全链路 TypeScript 工具库，找到适合你的工具\",\"link\":\"23.全链路 TypeScript 工具库，找到适合你的工具\"},{\"text\":\"24.说说 TypeScript 和 ECMAScript 之间那些事儿\",\"link\":\"24.说说 TypeScript 和 ECMAScript 之间那些事儿\"},{\"text\":\"25.装饰器与反射元数据：了解装饰器基本原理与应用\",\"link\":\"25.装饰器与反射元数据：了解装饰器基本原理与应用\"},{\"text\":\"26.控制反转与依赖注入：基于装饰器的依赖注入实现\",\"link\":\"26.控制反转与依赖注入：基于装饰器的依赖注入实现\"},{\"text\":\"27.TSConfig 全解（上）：构建相关配置\",\"link\":\"27.TSConfig 全解（上）：构建相关配置\"},{\"text\":\"28.TSConfig 全解（下）：检查相关、工程相关配置\",\"link\":\"28.TSConfig 全解（下）：检查相关、工程相关配置\"},{\"text\":\"29.基于 Prisma + NestJs 的 Node API ：前置知识储备\",\"link\":\"29.基于 Prisma + NestJs 的 Node API ：前置知识储备\"},{\"text\":\"30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署\",\"link\":\"30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署\"},{\"text\":\"31.玩转 TypeScript AST：AST Checker 与 CodeMod\",\"link\":\"31.玩转 TypeScript AST：AST Checker 与 CodeMod\"},{\"text\":\"32.感谢相伴：是结束，也是开始\",\"link\":\"32.感谢相伴：是结束，也是开始\"},{\"text\":\"33.漫谈篇：面试中的 TypeScript\",\"link\":\"33.漫谈篇：面试中的 TypeScript\"}]},\"/pamphlet/玩转css艺术之美/\":{\"base\":\"/pamphlet/玩转css艺术之美/\",\"items\":[{\"text\":\"1.准备篇：学前准备\",\"link\":\"1.准备篇：学前准备\"},{\"text\":\"2.基础篇：浏览器\",\"link\":\"2.基础篇：浏览器\"},{\"text\":\"3.进阶篇：回流重绘\",\"link\":\"3.进阶篇：回流重绘\"},{\"text\":\"4.基础篇：盒模型\",\"link\":\"4.基础篇：盒模型\"},{\"text\":\"5.基础篇：样式计算\",\"link\":\"5.基础篇：样式计算\"},{\"text\":\"6.进阶篇：布局样式\",\"link\":\"6.进阶篇：布局样式\"},{\"text\":\"7.进阶篇：函数计算\",\"link\":\"7.进阶篇：函数计算\"},{\"text\":\"8.进阶篇：变量计算\",\"link\":\"8.进阶篇：变量计算\"},{\"text\":\"9.技巧篇：选择器\",\"link\":\"9.技巧篇：选择器\"},{\"text\":\"10.技巧篇：背景与遮罩\",\"link\":\"10.技巧篇：背景与遮罩\"},{\"text\":\"11.技巧篇：阴影与滤镜\",\"link\":\"11.技巧篇：阴影与滤镜\"},{\"text\":\"12.技巧篇：变换与动画\",\"link\":\"12.技巧篇：变换与动画\"},{\"text\":\"13.实战篇：实战大操作-切换控件\",\"link\":\"13.实战篇：实战大操作-切换控件\"},{\"text\":\"14.实战篇：实战大操作-表单控件\",\"link\":\"14.实战篇：实战大操作-表单控件\"},{\"text\":\"15.实战篇：实战大操作-变量控件\",\"link\":\"15.实战篇：实战大操作-变量控件\"},{\"text\":\"16.总结篇：玩转css艺术之美\",\"link\":\"16.总结篇：玩转css艺术之美\"}]},\"/pamphlet/防御式 CSS 精讲/\":{\"base\":\"/pamphlet/防御式 CSS 精讲/\",\"items\":[{\"text\":\"1 推荐序｜克军：写好 CSS 是需要经验的\",\"link\":\"1 推荐序｜克军：写好 CSS 是需要经验的\"},{\"text\":\"2 如何根据 UI 形式选择视觉盒模型？\",\"link\":\"2 如何根据 UI 形式选择视觉盒模型？\"},{\"text\":\"3 Flexbox 和 Grid 中的换行\",\"link\":\"3 Flexbox 和 Grid 中的换行\"},{\"text\":\"4 Flexbox 和 Grid 中的最小内容尺寸\",\"link\":\"4 Flexbox 和 Grid 中的最小内容尺寸\"},{\"text\":\"5 布局中的滚动失效和默认拉伸\",\"link\":\"5 布局中的滚动失效和默认拉伸\"},{\"text\":\"6 固定网格轨道尺寸给 Web 布局带来的局限性\",\"link\":\"6 固定网格轨道尺寸给 Web 布局带来的局限性\"},{\"text\":\"7 如何灵活设置元素之间的间距？\",\"link\":\"7 如何灵活设置元素之间的间距？\"},{\"text\":\"8 position sticky 失效与修复\",\"link\":\"8 position sticky 失效与修复\"},{\"text\":\"9  z-index 失效与修复\",\"link\":\"9  z-index 失效与修复\"},{\"text\":\"10 你不知道的 border-radius\",\"link\":\"10 你不知道的 border-radius\"},{\"text\":\"11 Web 中的阴影\",\"link\":\"11 Web 中的阴影\"},{\"text\":\"12 Web 中的边框\",\"link\":\"12 Web 中的边框\"},{\"text\":\"13 响应式图片：防止图片的拉伸或挤压\",\"link\":\"13 响应式图片：防止图片的拉伸或挤压\"},{\"text\":\"14 如何提高图片上文本的可读性？\",\"link\":\"14 如何提高图片上文本的可读性？\"},{\"text\":\"15 你不知道的 CSS 渐变\",\"link\":\"15 你不知道的 CSS 渐变\"},{\"text\":\"16 Web 图片：你不应该遗忘的 CSS 技巧\",\"link\":\"16 Web 图片：你不应该遗忘的 CSS 技巧\"},{\"text\":\"17 图片的裁剪术\",\"link\":\"17 图片的裁剪术\"},{\"text\":\"18  重新思考 Web 中的裁剪：CSS 还是 SVG？\",\"link\":\"18  重新思考 Web 中的裁剪：CSS 还是 SVG？\"},{\"text\":\"19 CSS 如何改善滚动体验\",\"link\":\"19 CSS 如何改善滚动体验\"},{\"text\":\"20 美化滚动条 UI：自定义滚动条 UI\",\"link\":\"20 美化滚动条 UI：自定义滚动条 UI\"},{\"text\":\"21 CSS 的滚动捕捉\",\"link\":\"21 CSS 的滚动捕捉\"},{\"text\":\"22 溢出常见问题与排查\",\"link\":\"22 溢出常见问题与排查\"},{\"text\":\"23 易碎的容器盒子：避免使用固定尺寸和长内容设置\",\"link\":\"23 易碎的容器盒子：避免使用固定尺寸和长内容设置\"},{\"text\":\"24 使用逻辑属性来替代物理属性\",\"link\":\"24 使用逻辑属性来替代物理属性\"},{\"text\":\"25 多语言 Web 应用需要注意的细节\",\"link\":\"25 多语言 Web 应用需要注意的细节\"},{\"text\":\"26 条件 CSS 之 @规则和 CSS 选择器\",\"link\":\"26 条件 CSS 之 @规则和 CSS 选择器\"},{\"text\":\"27 条件 CSS 之 CSS 属性值和 CSS 函数\",\"link\":\"27 条件 CSS 之 CSS 属性值和 CSS 函数\"},{\"text\":\"28 CSS 的黑魔法\",\"link\":\"28 CSS 的黑魔法\"}]},\"/pamphlet/基于 Vite 的组件库工程化实战/\":{\"base\":\"/pamphlet/基于 Vite 的组件库工程化实战/\",\"items\":[{\"text\":\"1 开篇词：学习前端工程化就从搭建组件库开始\",\"link\":\"1 开篇词：学习前端工程化就从搭建组件库开始\"},{\"text\":\"2 MVP原型系统： 将组件封装为组件库\",\"link\":\"2 MVP原型系统： 将组件封装为组件库\"},{\"text\":\"3 CSS样式：用UnoCSS实现原子化CSS\",\"link\":\"3 CSS样式：用UnoCSS实现原子化CSS\"},{\"text\":\"4 文档建设：创建具备Demo示例功能的文档网站\",\"link\":\"4 文档建设：创建具备Demo示例功能的文档网站\"},{\"text\":\"5 单元测试(一)： 使用Jest进行前端单元测试\",\"link\":\"5 单元测试(一)： 使用Jest进行前端单元测试\"},{\"text\":\"6 单元测试 (二)： 搭建Vitest的单元测试环境\",\"link\":\"6 单元测试 (二)： 搭建Vitest的单元测试环境\"},{\"text\":\"7 规范化： Eslint + Prettier + Husky\",\"link\":\"7 规范化： Eslint + Prettier + Husky\"},{\"text\":\"8 软件包封装： 如何发布兼容多种 JS 模块标准的软件包？\",\"link\":\"8 软件包封装： 如何发布兼容多种 JS 模块标准的软件包？\"},{\"text\":\"9 持续集成 CI： 基于 github Action 的回归验证\",\"link\":\"9 持续集成 CI： 基于 github Action 的回归验证\"},{\"text\":\"10 开发许可证：维护自己的版权、拒绝拿来党\",\"link\":\"10 开发许可证：维护自己的版权、拒绝拿来党\"},{\"text\":\"11 组件发布： 建立语义化版本与提交软件包仓库 Npm\",\"link\":\"11 组件发布： 建立语义化版本与提交软件包仓库 Npm\"},{\"text\":\"12 建立组件库生态： 利用 Monorepo 方式管理组件库生态\",\"link\":\"12 建立组件库生态： 利用 Monorepo 方式管理组件库生态\"},{\"text\":\"13 按需引入实现组件库的按需引入功能\",\"link\":\"13 按需引入实现组件库的按需引入功能\"},{\"text\":\"14 文档部署： 用 Vercel 部署你的线上文档\",\"link\":\"14 文档部署： 用 Vercel 部署你的线上文档\"},{\"text\":\"15 README： 编写标准的 README\",\"link\":\"15 README： 编写标准的 README\"},{\"text\":\"16 品质保证：覆盖率测试报告\",\"link\":\"16 品质保证：覆盖率测试报告\"},{\"text\":\"17 社区参与： 如何管理社区的 PullRequest？\",\"link\":\"17 社区参与： 如何管理社区的 PullRequest？\"},{\"text\":\"18 敏捷开发： 用 Github 看板和 issue 管理需求\",\"link\":\"18 敏捷开发： 用 Github 看板和 issue 管理需求\"},{\"text\":\"19 架构复用： 创建 CLI 工具提高研发体验\",\"link\":\"19 架构复用： 创建 CLI 工具提高研发体验\"},{\"text\":\"20 融入开源生态： 编写 npm init 项目让用户更方便\",\"link\":\"20 融入开源生态： 编写 npm init 项目让用户更方便\"},{\"text\":\"21 加餐1：类型系统：导出组件库的类型定义\",\"link\":\"21 加餐1：类型系统：导出组件库的类型定义\"},{\"text\":\"22 结语｜当好项目的开路先锋\",\"link\":\"22 结语｜当好项目的开路先锋\"}]},\"/pamphlet/前端算法与数据结构面试：底层逻辑解读与大厂真题训练/\":{\"base\":\"/pamphlet/前端算法与数据结构面试：底层逻辑解读与大厂真题训练/\",\"items\":[{\"text\":\"1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略\",\"link\":\"1 面试总有套路，算法不是玄学——写给普通人的前端算法面试攻略\"},{\"text\":\"2 快速上手——从0到1掌握算法面试需要的数据结构（一）\",\"link\":\"2 快速上手——从0到1掌握算法面试需要的数据结构（一）\"},{\"text\":\"3 快速上手——从0到1掌握算法面试需要的数据结构（二）\",\"link\":\"3 快速上手——从0到1掌握算法面试需要的数据结构（二）\"},{\"text\":\"4 快速上手——从0到1掌握算法面试需要的数据结构（三）\",\"link\":\"4 快速上手——从0到1掌握算法面试需要的数据结构（三）\"},{\"text\":\"5 递归初相见——二叉树递归遍历的三种姿势\",\"link\":\"5 递归初相见——二叉树递归遍历的三种姿势\"},{\"text\":\"6 算法的衡量——轻松理解时间复杂度与空间复杂度\",\"link\":\"6 算法的衡量——轻松理解时间复杂度与空间复杂度\"},{\"text\":\"7 数组的应用——真题归纳与解读\",\"link\":\"7 数组的应用——真题归纳与解读\"},{\"text\":\"8 字符串的应用——真题归纳与解读\",\"link\":\"8 字符串的应用——真题归纳与解读\"},{\"text\":\"9 链表的应用——真题归纳与解读\",\"link\":\"9 链表的应用——真题归纳与解读\"},{\"text\":\"10 快慢指针与多指针——玩转链表复杂操作\",\"link\":\"10 快慢指针与多指针——玩转链表复杂操作\"},{\"text\":\"11 姿势特别的链表——环形链表专题\",\"link\":\"11 姿势特别的链表——环形链表专题\"},{\"text\":\"12 栈与队列怎么玩（上）\",\"link\":\"12 栈与队列怎么玩（上）\"},{\"text\":\"13 栈与队列怎么玩（下）\",\"link\":\"13 栈与队列怎么玩（下）\"},{\"text\":\"14 遍历专题：DFS 与 BFS\",\"link\":\"14 遍历专题：DFS 与 BFS\"},{\"text\":\"15 场景化解读：递归与回溯思想在真题中的应用\",\"link\":\"15 场景化解读：递归与回溯思想在真题中的应用\"},{\"text\":\"16 二叉树真题归纳与解读\",\"link\":\"16 二叉树真题归纳与解读\"},{\"text\":\"17 特殊的二叉树——二叉搜索树专题\",\"link\":\"17 特殊的二叉树——二叉搜索树专题\"},{\"text\":\"18 特殊的二叉树——平衡二叉树专题\",\"link\":\"18 特殊的二叉树——平衡二叉树专题\"},{\"text\":\"19 特殊的二叉树——堆结构及其在排序中的应用\",\"link\":\"19 特殊的二叉树——堆结构及其在排序中的应用\"},{\"text\":\"20 排序算法专题（上）\",\"link\":\"20 排序算法专题（上）\"},{\"text\":\"21 排序算法专题（下）\",\"link\":\"21 排序算法专题（下）\"},{\"text\":\"22 普通人也能吃透的动态规划思想专题（上）\",\"link\":\"22 普通人也能吃透的动态规划思想专题（上）\"},{\"text\":\"23 普通人也能吃透的动态规划思想专题（下）\",\"link\":\"23 普通人也能吃透的动态规划思想专题（下）\"},{\"text\":\"24 大厂真题训练与解读——微软真题\",\"link\":\"24 大厂真题训练与解读——微软真题\"},{\"text\":\"25 大厂真题训练与解读——Google 真题\",\"link\":\"25 大厂真题训练与解读——Google 真题\"},{\"text\":\"26 大厂真题训练与解读——腾讯真题\",\"link\":\"26 大厂真题训练与解读——腾讯真题\"},{\"text\":\"27 大厂真题训练与解读——头条真题\",\"link\":\"27 大厂真题训练与解读——头条真题\"},{\"text\":\"28 思维课：算法面试的评价逻辑\",\"link\":\"28 思维课：算法面试的评价逻辑\"}]},\"/pamphlet/Babel 插件通关秘籍/\":{\"base\":\"/pamphlet/Babel 插件通关秘籍/\",\"items\":[{\"text\":\"1 Babel 的介绍\",\"link\":\"1 Babel 的介绍\"},{\"text\":\"2 Babel 的编译流程\",\"link\":\"2 Babel 的编译流程\"},{\"text\":\"3 Babel 的 AST\",\"link\":\"3 Babel 的 AST\"},{\"text\":\"4 Babel 的 API\",\"link\":\"4 Babel 的 API\"},{\"text\":\"5 实战案例：插入函数调用参数\",\"link\":\"5 实战案例：插入函数调用参数\"},{\"text\":\"6 JS Parser 的历史\",\"link\":\"6 JS Parser 的历史\"},{\"text\":\"7 traverse 的 path、scope、visitor\",\"link\":\"7 traverse 的 path、scope、visitor\"},{\"text\":\"8 Generator 和 SourceMap 的奥秘\",\"link\":\"8 Generator 和 SourceMap 的奥秘\"},{\"text\":\"9 Code- Frame 和代码高亮原理\",\"link\":\"9 Code- Frame 和代码高亮原理\"},{\"text\":\"10 Babel 插件和 preset\",\"link\":\"10 Babel 插件和 preset\"},{\"text\":\"11 Babel 插件的单元测试\",\"link\":\"11 Babel 插件的单元测试\"},{\"text\":\"12 Babel 的内置功能（上）\",\"link\":\"12 Babel 的内置功能（上）\"},{\"text\":\"13 Babel 的内置功能（下）\",\"link\":\"13 Babel 的内置功能（下）\"},{\"text\":\"14 Babel 配置的原理\",\"link\":\"14 Babel 配置的原理\"},{\"text\":\"15 工具介绍：VSCode Debugger 的使用\",\"link\":\"15 工具介绍：VSCode Debugger 的使用\"},{\"text\":\"16 实战案例：自动埋点\",\"link\":\"16 实战案例：自动埋点\"},{\"text\":\"17 实战案例-自动国际化\",\"link\":\"17 实战案例-自动国际化\"},{\"text\":\"18 实战案例-自动生成 API 文档\",\"link\":\"18 实战案例-自动生成 API 文档\"},{\"text\":\"19 实战案例-Linter\",\"link\":\"19 实战案例-Linter\"},{\"text\":\"20 实战案例-类型检查\",\"link\":\"20 实战案例-类型检查\"},{\"text\":\"21 实战案例-压缩混淆\",\"link\":\"21 实战案例-压缩混淆\"},{\"text\":\"22 实战案例-JS 解释器\",\"link\":\"22 实战案例-JS 解释器\"},{\"text\":\"23 实战案例-模块遍历\",\"link\":\"23 实战案例-模块遍历\"},{\"text\":\"24 Babel Macros\",\"link\":\"24 Babel Macros\"},{\"text\":\"25 如何调试 Babel 源码？\",\"link\":\"25 如何调试 Babel 源码？\"},{\"text\":\"26 手写 Babel：思路篇\",\"link\":\"26 手写 Babel：思路篇\"},{\"text\":\"27 手写 Babel： parser 篇\",\"link\":\"27 手写 Babel： parser 篇\"},{\"text\":\"28 手写 Babel： traverse 篇\",\"link\":\"28 手写 Babel： traverse 篇\"},{\"text\":\"29 手写 Babel： traverse -- path篇\",\"link\":\"29 手写 Babel： traverse -- path篇\"},{\"text\":\"30 手写 Babel： traverse -- scope篇\",\"link\":\"30 手写 Babel： traverse -- scope篇\"},{\"text\":\"31 手写 Babel： generator篇\",\"link\":\"31 手写 Babel： generator篇\"},{\"text\":\"32 手写 Babel： core篇\",\"link\":\"32 手写 Babel： core篇\"},{\"text\":\"33 手写 Babel： cli篇\",\"link\":\"33 手写 Babel： cli篇\"},{\"text\":\"34 手写 Babel： 总结\",\"link\":\"34 手写 Babel： 总结\"},{\"text\":\"35 小册总结\",\"link\":\"35 小册总结\"},{\"text\":\"36 加餐：会了 babel 插件，就会写 prettier 插件\",\"link\":\"36 加餐：会了 babel 插件，就会写 prettier 插件\"}]},\"/pamphlet/WebGL 入门与实践/\":{\"base\":\"/pamphlet/WebGL 入门与实践/\",\"items\":[{\"text\":\"1 初级入门 --- 认识 WebGL\",\"link\":\"1 初级入门 --- 认识 WebGL\"},{\"text\":\"2 初级入门 --- 从一个点开始：掌握 WebGL 的编程要素\",\"link\":\"2 初级入门 --- 从一个点开始：掌握 WebGL 的编程要素\"},{\"text\":\"3 初级入门 --- 绘制三角形：学会使用缓冲区、了解 WebGL 中的基本图形元素\",\"link\":\"3 初级入门 --- 绘制三角形：学会使用缓冲区、了解 WebGL 中的基本图形元素\"},{\"text\":\"4 初级入门 --- 基本图元绘制：线段\",\"link\":\"4 初级入门 --- 基本图元绘制：线段\"},{\"text\":\"5 初级入门 --- 绘制渐变三角形：深入理解缓冲区\",\"link\":\"5 初级入门 --- 绘制渐变三角形：深入理解缓冲区\"},{\"text\":\"6 初级入门 --- 画个矩形：用基本图形构建平面\",\"link\":\"6 初级入门 --- 画个矩形：用基本图形构建平面\"},{\"text\":\"7 初级入门 --- 纹理贴图：为形体穿上外衣\",\"link\":\"7 初级入门 --- 纹理贴图：为形体穿上外衣\"},{\"text\":\"8 初级入门 --- 绘制立方体、球体、椎体：如何用基本图形构建规则形体\",\"link\":\"8 初级入门 --- 绘制立方体、球体、椎体：如何用基本图形构建规则形体\"},{\"text\":\"9 初级入门 --- 绘制多个物体：进一步封装绘制方法\",\"link\":\"9 初级入门 --- 绘制多个物体：进一步封装绘制方法\"},{\"text\":\"10 中级进阶 --- 神说要有光，于是就有了光：给物体添加环境光。\",\"link\":\"10 中级进阶 --- 神说要有光，于是就有了光：给物体添加环境光。\"},{\"text\":\"11 中级进阶 --- 冯氏光照模型：为物体增加漫反射效果\",\"link\":\"11 中级进阶 --- 冯氏光照模型：为物体增加漫反射效果\"},{\"text\":\"12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果\",\"link\":\"12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果\"},{\"text\":\"13  中级进阶 --- 深入理解 GLSL 语法\",\"link\":\"13  中级进阶 --- 深入理解 GLSL 语法\"},{\"text\":\"14 中级进阶 --- WebGL 与数学：我们需要哪些数学知识？\",\"link\":\"14 中级进阶 --- WebGL 与数学：我们需要哪些数学知识？\"},{\"text\":\"15 中级进阶 --- 数学：点、向量、矩阵。\",\"link\":\"15 中级进阶 --- 数学：点、向量、矩阵。\"},{\"text\":\"16 中级进阶 ---  通用数学库的 JavaScript 实现。\",\"link\":\"16 中级进阶 ---  通用数学库的 JavaScript 实现。\"},{\"text\":\"17 中级进阶 --- WebGL 坐标系\",\"link\":\"17 中级进阶 --- WebGL 坐标系\"},{\"text\":\"18 中级进阶 --- 坐标系变换：基本变换原理与算法实现\",\"link\":\"18 中级进阶 --- 坐标系变换：基本变换原理与算法实现\"},{\"text\":\"19 中级进阶 --- 坐标系变换：模型空间变换到世界空间\",\"link\":\"19 中级进阶 --- 坐标系变换：模型空间变换到世界空间\"},{\"text\":\"20 中级进阶 --- 坐标系变换：世界空间变换到观察空间\",\"link\":\"20 中级进阶 --- 坐标系变换：世界空间变换到观察空间\"},{\"text\":\"21 中级进阶 --- 坐标系变换：观察空间变换到裁剪空间\",\"link\":\"21 中级进阶 --- 坐标系变换：观察空间变换到裁剪空间\"},{\"text\":\"22 深入研究 --- 更高级的旋转：欧拉角、四元数。\",\"link\":\"22 深入研究 --- 更高级的旋转：欧拉角、四元数。\"},{\"text\":\"23 深入研究 --- 四元数的应用：使用鼠标控制模型的旋转\",\"link\":\"23 深入研究 --- 四元数的应用：使用鼠标控制模型的旋转\"},{\"text\":\"24 深入研究 --- CSS 与 3D 之 transform\",\"link\":\"24 深入研究 --- CSS 与 3D 之 transform\"},{\"text\":\"25 深入研究 --- CSS 与 3D 之 perspective\",\"link\":\"25 深入研究 --- CSS 与 3D 之 perspective\"},{\"text\":\"26 深入研究 --- 数学库在 CSS 的 3D 动画中扮演的重要角色\",\"link\":\"26 深入研究 --- 数学库在 CSS 的 3D 动画中扮演的重要角色\"},{\"text\":\"27 深入探究 --- 层级建模：行走的机器人\",\"link\":\"27 深入探究 --- 层级建模：行走的机器人\"},{\"text\":\"28 深入研究 --- 使用立方体纹理绘制天空盒\",\"link\":\"28 深入研究 --- 使用立方体纹理绘制天空盒\"},{\"text\":\"29 深入研究 --- 混合效果\",\"link\":\"29 深入研究 --- 混合效果\"},{\"text\":\"30 深入研究 --- 帧缓冲\",\"link\":\"30 深入研究 --- 帧缓冲\"},{\"text\":\"31 高级应用 --- 3D模型的拾取原理与实现\",\"link\":\"31 高级应用 --- 3D模型的拾取原理与实现\"},{\"text\":\"32 高级应用 --- 魔法 Shader：火焰效果的原理与实现\",\"link\":\"32 高级应用 --- 魔法 Shader：火焰效果的原理与实现\"},{\"text\":\"33 结束了吗？一切刚刚开始\",\"link\":\"33 结束了吗？一切刚刚开始\"}]}},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>