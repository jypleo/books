import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.D8Prfz4N.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/Babel 插件通关秘籍/7 traverse 的 path、scope、visitor.md","filePath":"pamphlet/Babel 插件通关秘籍/7 traverse 的 path、scope、visitor.md"}'),p={name:"pamphlet/Babel 插件通关秘籍/7 traverse 的 path、scope、visitor.md"},e=n(`<p>源码 parse 成 AST 之后，需要进行 AST 的遍历和增删改（transform）。那么 transform 的流程是什么样的？</p><p>babel 会递归遍历 AST，遍历过程中处理到不同的 AST 会调用不同的 visitor 函数来实现 transform。这其实是一种设计模式，叫做访问者模式：</p><h2 id="visitor-模式" tabindex="-1">visitor 模式 <a class="header-anchor" href="#visitor-模式" aria-label="Permalink to &quot;visitor 模式&quot;">​</a></h2><p>visitor 模式（访问者模式）是 23 种经典设计模式中的一种。visitor 模式的思想是：当被操作的对象结构比较稳定，而操作对象的逻辑经常变化的时候，通过分离逻辑和对象结构，使得他们能独立扩展。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a89899432b549d198a98f404e791a97~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如图，Element 和 Visitor 分别代表对象结构和操作逻辑，两者可以独立扩展，在 Client 里面来组合两者，使用 visitor 操作 element。这就是 visitor 模式。</p><p>对应到 babel traverse 的实现，就是 AST 和 visitor 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c592dedef6ff429ebbcb350e0afa404d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这样 AST 是独立的扩展的，visitor 是独立的扩展的，两者可以各自独立扩展单还能轻易地结合在一起。</p><h2 id="path-和-scope" tabindex="-1">path 和 scope <a class="header-anchor" href="#path-和-scope" aria-label="Permalink to &quot;path 和 scope&quot;">​</a></h2><p>path 是记录遍历路径的 api，它记录了父子节点的引用，还有很多增删改查 AST 的 api：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/293327a616cc4c90b7fa40c7e28761a0~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>那 path 大概有哪些属性和方法呢？</p><h3 id="path" tabindex="-1">path <a class="header-anchor" href="#path" aria-label="Permalink to &quot;path&quot;">​</a></h3><p>path 大概有这些属性和方法，不需要记，后面案例用到的时候知道是啥就行。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 属性：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    node </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    parent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    parentPath</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scope</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hub</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    container</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    listKey</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 方法</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key) </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, node)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    inList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getSibling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key) </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getNextSibling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getPrevSibling</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getAllPrevSiblings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    getAllNextSiblings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    isXxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opts)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    assertXxx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opts)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    findParent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    insertAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    replaceWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(replacement)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    replaceWithMultiple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    replaceWithSourceString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(replacement)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(visitor, state)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    skip</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    stop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>它们各自的含义：</p><ul><li>path.node 当前 AST 节点</li><li>path.parent 父 AST 节点</li><li>path.parentPath 父 AST 节点的 path</li><li>path.scope 作用域</li><li>path.hub 可以通过 path.hub.file 拿到最外层 File 对象， path.hub.getScope 拿到最外层作用域，path.hub.getCode 拿到源码字符串</li><li>path.container 当前 AST 节点所在的父节点属性的属性值</li><li>path.key 当前 AST 节点所在父节点属性的属性名或所在数组的下标</li><li>path.listkey 当前 AST 节点所在父节点属性的属性值为数组时 listkey 为该属性名，否则为 undefined</li></ul><h4 id="container、listkey、key" tabindex="-1">container、listkey、key <a class="header-anchor" href="#container、listkey、key" aria-label="Permalink to &quot;container、listkey、key&quot;">​</a></h4><p>这几个属性不太常用，简单介绍一下。</p><p>因为 AST 节点要挂在父 AST 节点的某个属性上，那个属性的属性值就是这个 AST 节点的 container。</p><p>比如 CallExpression 有 callee 和 arguments 属性，那么对于 callee 的 AST 节点来说，callee 的属性值就是它的 container，而 callee 就是它的 key。</p><p>因为不是一个列表，所以 listkey 是 undefined。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce55f6c749d4e35ad6460de6f5be71a~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>而 BlockStatement 有 body 属性，是一个数组，对于数组中的每一个 AST 来说，这个数组就是它们的 container，而 listKey 是 body，key 则是下标。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b48a0cdddb4344d1b9343e04818460ad~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="path-的方法" tabindex="-1">path 的方法 <a class="header-anchor" href="#path-的方法" aria-label="Permalink to &quot;path 的方法&quot;">​</a></h3><p>path 有如下方法，同样也不需要记：</p><ul><li>get(key) 获取某个属性的 path</li><li>set(key, node) 设置某个属性的值</li><li>getSibling(key) 获取某个下标的兄弟节点</li><li>getNextSibling() 获取下一个兄弟节点</li><li>getPrevSibling() 获取上一个兄弟节点</li><li>getAllPrevSiblings() 获取之前的所有兄弟节点</li><li>getAllNextSiblings() 获取之后的所有兄弟节点</li><li>find(callback) 从当前节点到根节点来查找节点（包括当前节点），调用 callback（传入 path）来决定是否终止查找</li><li>findParent(callback) 从当前节点到根节点来查找节点（不包括当前节点），调用 callback（传入 path）来决定是否终止查找</li><li>inList() 判断节点是否在数组中，如果 container 为数组，也就是有 listkey 的时候，返回 true</li><li>isXxx(opts) 判断当前节点是否是某个类型，可以传入属性和属性值进一步判断，比如path.isIdentifier({name: &#39;a&#39;})</li><li>assertXxx(opts) 同 isXxx，但是不返回布尔值，而是抛出异常</li><li>insertBefore(nodes) 在之前插入节点，可以是单个节点或者节点数组</li><li>insertAfter(nodes) 在之后插入节点，可以是单个节点或者节点数组</li><li>replaceWith(replacement) 用某个节点替换当前节点</li><li>replaceWithMultiple(nodes) 用多个节点替换当前节点</li><li>replaceWithSourceString(replacement) 解析源码成 AST，然后替换当前节点</li><li>remove() 删除当前节点</li><li>traverse(visitor, state) 遍历当前节点的子节点，传入 visitor 和 state（state 是不同节点间传递数据的方式）</li><li>skip() 跳过当前节点的子节点的遍历</li><li>stop() 结束所有遍历</li></ul><h3 id="作用域-path-scope" tabindex="-1">作用域 path.scope <a class="header-anchor" href="#作用域-path-scope" aria-label="Permalink to &quot;作用域 path.scope&quot;">​</a></h3><p>scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。</p><p>属性和方法大概有这些</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>path.scope {</span></span>
<span class="line"><span>    bindings</span></span>
<span class="line"><span>    block</span></span>
<span class="line"><span>    parent</span></span>
<span class="line"><span>    parentBlock</span></span>
<span class="line"><span>    path</span></span>
<span class="line"><span>    references</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>    dump()</span></span>
<span class="line"><span>    getAllBindings()</span></span>
<span class="line"><span>    getBinding(name)</span></span>
<span class="line"><span>    hasBinding(name)</span></span>
<span class="line"><span>    getOwnBinding(name)</span></span>
<span class="line"><span>    parentHasBinding(name)</span></span>
<span class="line"><span>    removeBinding(name)</span></span>
<span class="line"><span>    moveBindingTo(name, scope)</span></span>
<span class="line"><span>    generateUid(name)</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>各自的含义：</p><ul><li>scope.bindings 当前作用域内声明的所有变量</li><li>scope.block 生成作用域的 block，详见下文</li><li>scope.path 生成作用域的节点对应的 path</li><li>scope.references 所有 binding 的引用对应的 path，详见下文</li><li>scope.dump() 打印作用域链的所有 binding 到控制台</li><li>scope.parentBlock 父级作用域的 block</li><li>getAllBindings() 从当前作用域到根作用域的所有 binding 的合并</li><li>getBinding(name) 查找某个 binding，从当前作用域一直查找到根作用域</li><li>getOwnBinding(name) 从当前作用域查找 binding</li><li>parentHasBinding(name, noGlobals) 查找某个 binding，从父作用域查到根作用域，不包括当前作用域。可以通过 noGlobals 参数指定是否算上全局变量（比如console，不需要声明就可用），默认是 false</li><li>removeBinding(name) 删除某个 binding</li><li>hasBinding(name, noGlobals) 从当前作用域查找 binding，可以指定是否算上全局变量，默认是 false</li><li>moveBindingTo(name, scope) 把当前作用域中的某个 binding 移动到其他作用域</li><li>generateUid(name) 生成作用域内唯一的名字，根据 name 添加下划线，比如 name 为 a，会尝试生成 _a，如果被占用就会生成 __a，直到生成没有被使用的名字。</li></ul><h4 id="scope-block" tabindex="-1">scope.block <a class="header-anchor" href="#scope-block" aria-label="Permalink to &quot;scope.block&quot;">​</a></h4><p>能形成 scope 的有这些节点，这些节点也叫 block 节点。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Scopable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BlockStatement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CatchClause</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DoWhileStatement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForInStatement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForStatement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FunctionDeclaration</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FunctionExpression</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Program</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ObjectMethod</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SwitchStatement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WhileStatement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrowFunctionExpression</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassExpression</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassDeclaration</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForOfStatement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassMethod</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassPrivateMethod</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StaticBlock</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TSModuleBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>我们可以通过 path.scope.block 来拿到所在的块对应的节点，通过 path.scope.parentBlock 拿到父作用域对应的块节点。</p><p>一般情况下我们不需要拿到生成作用域的块节点，只需要通过 path.scope 拿到作用域的信息，通过 path.scope.parent 拿到父作用域的信息。</p><h4 id="scope-bindings、scope-references-重点" tabindex="-1">scope.bindings、scope.references（重点） <a class="header-anchor" href="#scope-bindings、scope-references-重点" aria-label="Permalink to &quot;scope.bindings、scope.references（重点）&quot;">​</a></h4><p>作用域中保存的是声明的变量和对应的值，<strong>每一个声明叫做一个binding</strong>。</p><p>比如这样一段代码</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>它的 path.scope.bindings 是这样的</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        constant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        constantViolations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        identifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Identifier&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;const&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {node,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        referenced</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        referencePaths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        references</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        scope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>因为我们在当前 scope 中声明了 a 这个变量，所以 bindings 中有 a 的 binding，每一个 binding 都有 kind，这代表绑定的类型：</p><ul><li>var、let、const 分别代表 var、let、const 形式声明的变量</li><li>param 代表参数的声明</li><li>module 代表 import 的变量的声明</li></ul><p>binding 有多种 kind，代表变量是用不同的方式声明的。</p><p>binding.identifier 和 binding.path，分别代表标识符、整个声明语句。</p><p>声明之后的变量会被引用和修改，binding.referenced 代表声明的变量是否被引用，binding.constant 代表变量是否被修改过。如果被引用了，就可以通过 binding.referencePaths 拿到所有引用的语句的 path。如果被修改了，可以通过 binding.constViolations 拿到所有修改的语句的 path。</p><p>path 的 api 还是比较多的，这也是 babel 最强大的地方。主要是操作当前节点、当前节点的父节点、兄弟节点，作用域，以及增删改的方法。</p><h2 id="state" tabindex="-1">state <a class="header-anchor" href="#state" aria-label="Permalink to &quot;state&quot;">​</a></h2><p>state 是遍历过程中 AST 节点之间传递数据的方式。插件的 visitor 中，第一个参数是 path，第二个参数就是 state。</p><p>插件可以从 state 中拿到 opts，也就是插件的配置项，也可以拿到 file 对象，file 中有一些文件级别的信息，这个也可以从 path.hub.file 中拿。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>state {</span></span>
<span class="line"><span>    file</span></span>
<span class="line"><span>    opts</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>可以在遍历的过程中在 state 中存一些状态信息，用于后续的 AST 处理。</p><h2 id="ast-的别名" tabindex="-1">AST 的别名 <a class="header-anchor" href="#ast-的别名" aria-label="Permalink to &quot;AST 的别名&quot;">​</a></h2><p>遍历的时候要指定 visitor 处理的 AST，有的时候需要对多个节点做同样的处理，babel 支持指定多个 AST 类型，也可以通过别名指定一系列类型。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 单个 AST 类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  FunctionDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, state) {},</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 多个 AST 类型</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;FunctionDeclaration|VariableDeclaration&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path, state) {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // AST 类型别名</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  Declaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span></code></pre></div><p>可以在<a href="https://babeljs.io/docs/en/babel-types" target="_blank" rel="noreferrer">文档中</a>查到某个 AST 类型的别名是啥，某个别名都包含哪些 AST 类型可以在<a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts#L2489-L2535" target="_blank" rel="noreferrer">babel-types的类型定义</a>处查。</p><p>可以把 @babel/types 源码下载下来看，类型定义在 src/ast-types/generated 目录下，这样可以利用 ide 的功能方便的查看每种 alias 的具体 AST 类型。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7ce124c18bd4e5c95760212e5e16078~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>所有的 AST 相关的信息都可以在<a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/definitions/core.ts" target="_blank" rel="noreferrer">babel-types</a>里查看，每一个 AST 节点怎么创建、怎么校验、怎么遍历，其实都与 AST 的结构有关系，这些都在 babel-types 里面定义。</p><p>比如 if 就定义了有哪些属性可以遍历、别名是什么，每一个属性怎么校验，然后会根据这些规则生成xxx，isXxx，assertXxx等api用于创建、判断AST节点。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/004cb659aeaa4c749cfff6b2187383a4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这一节我们学习了 visitor 模式，通过对象和操作分离的方式使得 AST 和 visitor 可以独立扩展，还可以轻易的结合在一起。</p><p>然后学习了 babel 强大的 path，包括它的属性和操作 AST 的 api，以及作用域 scope 的一些概念和 api。</p><p>path 的 api 比较多，马上消化不太现实，不用着急，后面实战会大量用到。</p>`,70),l=[e];function t(h,k,r,c,d,o){return a(),i("div",null,l)}const y=s(p,[["render",t]]);export{E as __pageData,y as default};
