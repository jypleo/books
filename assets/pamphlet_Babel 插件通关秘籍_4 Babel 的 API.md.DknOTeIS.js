import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.D8Prfz4N.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/Babel 插件通关秘籍/4 Babel 的 API.md","filePath":"pamphlet/Babel 插件通关秘籍/4 Babel 的 API.md"}'),t={name:"pamphlet/Babel 插件通关秘籍/4 Babel 的 API.md"},p=e(`<p>学习了 babel 的编译流程和 AST 之后，我们就大概知道了 babel 做了什么。但还要学习下 babel 的 api，然后通过这些 api 来操作 AST，完成代码的转换。</p><blockquote><p>注意，我们学习的 api 是 babel 7.x 的，babel 6 的 api 还没有按照 scope 来划分，也就是 babel-parser 这种，而 babel 7 变成了@babel/parser 这种。对应的插件也是从 babel-plugin-xxx 变成了 @babel/plugin-xxx。但只是包名变了，api 没啥大的变动，我们学的是一些原理性的东西，这些东西在版本迭代中是不会变的。</p></blockquote><h2 id="babel-的-api-有哪些" tabindex="-1">babel 的 api 有哪些 <a class="header-anchor" href="#babel-的-api-有哪些" aria-label="Permalink to &quot;babel 的 api 有哪些&quot;">​</a></h2><p>我们知道 babel 的编译流程分为三步：parse、transform、generate，每一步都暴露了一些 api 出来。</p><ul><li>parse 阶段有<code>@babel/parser</code>，功能是把源码转成 AST</li><li>transform 阶段有 <code>@babel/traverse</code>，可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等，这时候就需要 <code>@babel/types</code> 了，当需要批量创建 AST 的时候可以使用 <code>@babel/template</code> 来简化 AST 创建逻辑。</li><li>generate 阶段会把 AST 打印为目标代码字符串，同时生成 sourcemap，需要 <code>@babel/generator</code> 包</li><li>中途遇到错误想打印代码位置的时候，使用 <code>@babel/code-frame</code> 包</li><li>babel 的整体功能通过 <code>@babel/core</code> 提供，基于上面的包完成 babel 整体的编译流程，并应用 plugin 和 preset。</li></ul><p>我们主要学习的就是 <code>@babel/parser</code>，<code>@babel/traverse</code>，<code>@babel/generator</code>，<code>@babel/types</code>，<code>@babel/template</code> 这五个包的 api 的使用。</p><p>这些包的 api 都可以在<a href="https://www.babeljs.cn/docs/babel-parser" target="_blank" rel="noreferrer">文档</a>里查看：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecd921de24f401b93672d7c0ad4b81d~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>为了方便理解这里也分别介绍一下。</p><h2 id="babel-parser" tabindex="-1">@babel/parser <a class="header-anchor" href="#babel-parser" aria-label="Permalink to &quot;@babel/parser&quot;">​</a></h2><p>babel parser 叫 babylon，是基于 acorn 实现的，扩展了很多语法，可以支持 es next（现在支持到 es2020）、jsx、flow、typescript 等语法的解析。</p><p>babel parser 默认只能 parse js 代码，jsx、flow、typescript 这些非标准的语法的解析需要指定语法插件。</p><p>它提供了有两个 api：parse 和 parseExpression。两者都是把源码转成 AST，不过 parse 返回的 AST 根节点是 File（整个 AST），parseExpression 返回的 AST 根节点是是 Expression（表达式的 AST），粒度不同。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ParserOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> File</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseExpression</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ParserOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Expression</span></span></code></pre></div><p>详细的 options 可以查看<a href="https://babeljs.io/docs/en/babel-parser#options" target="_blank" rel="noreferrer">文档</a>。其实主要分为两类，一是 parse 的内容是什么，二是以什么方式去 parse</p><p><strong>parse 的内容是什么：</strong></p><ul><li><code>plugins</code>： 指定jsx、typescript、flow 等插件来解析对应的语法</li><li><code>allowXxx</code>： 指定一些语法是否允许，比如函数外的 await、没声明的 export等</li><li><code>sourceType</code>： 指定是否支持解析模块语法，有 module、script、unambiguous 3个取值： <ul><li>module：解析 es module 语法</li><li>script：不解析 es module 语法</li><li>unambiguous：根据内容是否有 import 和 export 来自动设置 module 还是 script</li></ul></li></ul><p>一般我们会指定 sourceType 为 unambiguous。</p><p>比如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  parser</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@babel/parser&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parser.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;代码&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    sourceType: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;unambiguous&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    plugins: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;jsx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><strong>以什么方式 parse</strong></p><ul><li><code>strictMode</code> 是否是严格模式</li><li><code>startLine</code> 从源码哪一行开始 parse</li><li><code>errorRecovery</code> 出错时是否记录错误并继续往下 parse</li><li><code>tokens</code> parse 的时候是否保留 token 信息</li><li><code>ranges</code> 是否在 ast 节点中添加 ranges 属性</li></ul><p>用 <a href="https://astexplorer.net/#/gist/3af72fdd39c4950fd8afbcd488a18f7f/9fef2ce1da52b1698ded918e0c29eb7a1591a05f" target="_blank" rel="noreferrer">astexplorer.net</a> 来查看 AST 的时候，也同样支持 parser options 的设置：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8418549479854741bd8f4410e81acfac~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><h2 id="babel-traverse" tabindex="-1">@babel/traverse <a class="header-anchor" href="#babel-traverse" aria-label="Permalink to &quot;@babel/traverse&quot;">​</a></h2><p>parse 出的 AST 由 <code>@babel/traverse</code> 来遍历和修改，babel traverse 包提供了 traverse 方法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>常用的就前面两个参数，parent 指定要遍历的 AST 节点，opts 指定 visitor 函数。babel 会在遍历 parent 对应的 AST 时调用相应的 visitor 函数。</p><h4 id="遍历过程" tabindex="-1">遍历过程 <a class="header-anchor" href="#遍历过程" aria-label="Permalink to &quot;遍历过程&quot;">​</a></h4><p>visitor 是指定对什么 AST 做什么处理的函数，babel 会在遍历到对应的 AST 时回调它们。</p><p>而且可以指定刚开始遍历（enter）和遍历结束后（exit）两个阶段的回调函数，</p><p>比如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FunctionDeclaration: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      enter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进入节点时调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 离开节点时调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>如果只指定了一个函数，那就是 enter 阶段会调用的：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  FunctionDeclaration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进入节点时调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>enter 时调用是在遍历当前节点的子节点前调用，exit 时调用是遍历完当前节点的子节点后调用。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5768a7c151914586ab2a5b09b698b4d7~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>而且同一个 visitor 函数可以用于多个 AST 节点的处理，方式是指定一系列 AST，用 | 连接：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进入 FunctionDeclaration 和 VariableDeclaration 节点时调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast, {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;FunctionDeclaration|VariableDeclaration&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>此外，AST 还有别名的，比如各种 XxxStatement 有个 Statement 的别名，各种 XxxDeclaration 有个 Declaration 的别名，那自然可以通过别名来指定对这些 AST 的处理：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过别名指定离开各种 Declaration 节点时调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">traverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Declaration: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>具体的别名有哪些在<a href="https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts#L2059" target="_blank" rel="noreferrer">babel-types 的类型定义</a>可以查。</p><p>当然，babel 文档里也有：</p><p><a href="https://www.babeljs.cn/docs/babel-types#aliases" target="_blank" rel="noreferrer">https://www.babeljs.cn/docs/babel-types#aliases</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e50557005e74a7f91530cff9abafee9~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>每个 visitor 都有 path 和 state 的参数，这些是干啥的呢？</p><h4 id="path" tabindex="-1">path <a class="header-anchor" href="#path" aria-label="Permalink to &quot;path&quot;">​</a></h4><p>AST 是棵树，遍历过程中肯定是有个路径的，path 就记录了这个路径：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538aefbdff92426c98c7f1da1feeb246~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>如图，节点 1、节点 2、节点 3 是三层 AST，通过两个 path 关联了起来，</p><p>path1 就关联了节点 1 和 节点 2，记录了节点 1 是父节点，节点 2 是子节点。</p><p>path2 关联了节点 2 和节点 3，记录了节点 2 是父节点，节点 3 是子节点。</p><p>而且 path1 和 path2 还有父子关系。</p><p>通过这样的 path 对象，那不就把遍历的路径串联起来了么。</p><p>而且，最重要的是 path 有很多属性和方法，比如记录父子、兄弟等关系的：</p><ul><li>path.node 指向当前 AST 节点</li><li>path.parent 指向父级 AST 节点</li><li>path.getSibling、path.getNextSibling、path.getPrevSibling 获取兄弟节点</li><li>path.find 从当前节点向上查找节点</li><li>path.get、path.set 获取 / 设置属性的 path</li></ul><p>还有作用域相关的：</p><ul><li>path.scope 获取当前节点的作用域信息</li></ul><p>判断 AST 类型的：</p><ul><li>path.isXxx 判断当前节点是不是 xx 类型</li><li>path.assertXxx 判断当前节点是不是 xx 类型，不是则抛出异常</li></ul><p>增删改 AST 的：</p><ul><li>path.insertBefore、path.insertAfter 插入节点</li><li>path.replaceWith、path.replaceWithMultiple、replaceWithSourceString 替换节点</li><li>path.remove 删除节点</li></ul><p>跳过遍历的：</p><ul><li>path.skip 跳过当前节点的子节点的遍历</li><li>path.stop 结束后续遍历</li></ul><p>可以增删改 AST，可以按照路径查找任意的节点，还有作用域的信息，那怎么转换和分析代码不就呼之欲出了么。</p><p>确实，path 的 api 是学习 babel 插件最核心的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96ed2f4589d341de9b407ef7e58e58a0~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>上面罗列了一些常用的 api，可以通过这些 api 完成对 AST 的操作。当然，path 的 api 不是只有这些，后面实战案例用到了再介绍。</p><h4 id="state" tabindex="-1">state <a class="header-anchor" href="#state" aria-label="Permalink to &quot;state&quot;">​</a></h4><p>第二个参数 state 则是遍历过程中在不同节点之间传递数据的机制，插件会通过 state 传递 options 和 file 信息，我们也可以通过 state 存储一些遍历过程中的共享数据。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee26748e8dd54dcca660e593271411be~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>这个很容易理解，节点之间是有传输数据的需求的。不同状态下可能会做不同的处理，这就是为什么这个参数叫做 state。</p><h2 id="babel-types" tabindex="-1">@babel/types <a class="header-anchor" href="#babel-types" aria-label="Permalink to &quot;@babel/types&quot;">​</a></h2><p>遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型，这时候就需要 <code>@babel/types</code> 包。</p><p>举例来说，如果要创建IfStatement就可以调用</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ifStatement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(test, consequent, alternate);</span></span></code></pre></div><p>而判断节点是否是 IfStatement 就可以调用 isIfStatement 或者 assertIfStatement</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isIfStatement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, opts);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assertIfStatement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, opts);</span></span></code></pre></div><p>opts 可以指定一些属性是什么值，增加更多限制条件，做更精确的判断。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isIdentifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;paths&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>isXxx 和 assertXxx 看起来很像，但是功能不大一样：isXxx 会返回 boolean，而 assertXxx 则会在类型不一致时抛异常。</p><p>所有的 AST 的 build、assert 的 api 可以在 <a href="https://babeljs.io/docs/en/babel-types#api" target="_blank" rel="noreferrer">babel types 文档</a>中查。</p><h2 id="babel-template" tabindex="-1">@babel/template <a class="header-anchor" href="#babel-template" aria-label="Permalink to &quot;@babel/template&quot;">​</a></h2><p>通过 @babel/types 创建 AST 还是比较麻烦的，要一个个的创建然后组装，如果 AST 节点比较多的话需要写很多代码，这时候就可以使用 <code>@babel/template</code> 包来批量创建。</p><p>这个包有这些 api：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code, [opts])(args);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> template.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code, [opts]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> template.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">program</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code, [opts]);</span></span></code></pre></div><p>这些都是传入一段字符串，返回创建好的 AST，区别只是返回的 AST 粒度不大一样：</p><p>template.ast 返回的是整个 AST。</p><p>template.program 返回的是 Program 根节点。</p><p>template.expression 返回创建的 expression 的 AST。</p><p>template.statements 返回创建的 statems 数组的 AST。</p><p>可能有的同学会说，都是创建 AST，搞这么多 api。</p><p>还是有意义的，比如上节说表达式作为语句执行的时候，<a href="https://astexplorer.net/#/gist/3af72fdd39c4950fd8afbcd488a18f7f/9fef2ce1da52b1698ded918e0c29eb7a1591a05f" target="_blank" rel="noreferrer">AST 会有一层 ExpressionStatement 么</a>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c533f7c66391490684f521aeb0ec01fa~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>所以用 template.ast 创建的 Expression 会被包裹一层 ExpressionStatement 节点，而 template.expression 方法创建的 AST 就不会。</p><p>所以，当你明确知道了创建的 AST 的类型的话，用更细粒度的 api 会方便一些。</p><p>模版也支持占位符，可以在模版里设置一些占位符，调用时再传入这些占位符参数对应的 AST 节点。</p><p>比如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`console.log(NAME)\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  NAME: t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;guang&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>或者</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`console.log(%%NAME%%)\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  NAME: t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;guang&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>这样就是通过模版来批量创建 AST，但是其中的占位符是用传入的 AST。</p><p>加不加 %% 都行，当占位符和其他变量名冲突时可以加上。</p><h2 id="babel-generator" tabindex="-1">@babel/generator <a class="header-anchor" href="#babel-generator" aria-label="Permalink to &quot;@babel/generator&quot;">​</a></h2><p>AST 转换完之后就要打印成目标代码字符串，通过 <code>@babel/generator</code> 包的 generate api</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ast</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>第一个参数是要打印的 AST。</p><p>第二个参数是 options，指定打印的一些细节，比如通过 comments 指定是否包含注释，通过 minified 指定是否包含空白字符。</p><p>第三个参数当多个文件合并打印的时候需要用到，这部分直接看<a href="https://babeljs.io/docs/en/babel-generator" target="_blank" rel="noreferrer">文档</a>即可，基本用不到。</p><p>options 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> generate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@babel/generator&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ast, { sourceMaps: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><h2 id="babel-code-frame" tabindex="-1">@babel/code-frame <a class="header-anchor" href="#babel-code-frame" aria-label="Permalink to &quot;@babel/code-frame&quot;">​</a></h2><p>babel 的报错一半都会直接打印错误位置的代码，而且还能高亮，</p><p>我们打印错误信息的时候也可以用，就是 <code>@babel/code-frame</code> 这个包。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> codeFrameColumns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rawLines, location, {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* options */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>options 可以设置 highlighted （是否高亮）、message（展示啥错误信息）。</p><p>比如</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">codeFrameColumns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@babel/code-frame&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;xxx 错误&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">codeFrameColumns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`const name = guang\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      start: { line: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, column: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    highlightCode: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    message: err.message</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>打印的错误就是这样的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e31ce65fd2f644439f2848b0e0e94c1b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>在控制台展示这样的错误，是不是比直接打印个错误堆栈好很多呀～</p><p>这种控制台打印代码格式的功能就叫做 code frame。</p><h2 id="babel-core" tabindex="-1">@babel/core <a class="header-anchor" href="#babel-core" aria-label="Permalink to &quot;@babel/core&quot;">​</a></h2><p>前面讲了 @babel/parser、@babel/traverse、@babel/generaotr、@babel/types、@babel/template 等包，babel 的功能就是通过这些包来实现的。</p><p>babel 基于这些包来实现编译、插件、预设等功能的包就是 @babel/core。</p><p>这个包的功能就是完成整个编译流程，从源码到目标代码，生成 sourcemap。实现 plugin 和 preset 的调用。</p><p>api 也有好几个：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code, options); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; { code, map, ast }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename, options); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; { code, map, ast }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformFromAstSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  parsedAst,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sourceCode,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  options</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; { code, map, ast }</span></span></code></pre></div><p>比如这三个 transformXxx 的 api 分别是从源代码、源代码文件、源代码 AST 开始处理，最终生成目标代码和 sourcemap。</p><p>options 主要配置 plugins 和 presets，指定具体要做什么转换。</p><p>这些 api 也同样提供了异步的版本，异步地进行编译，返回一个 promise</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;code();&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {})</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformFileAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;filename.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {})</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformFromAstAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parsedAst, sourceCode, options).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {})</span></span></code></pre></div><p>注意：不带 sync、async 的 api 已经被标记过时了，也就是 transformXxx 这些，后续会删掉，不建议用，直接用 transformXxxSync 和 transformXxxAsync。也就是明确是同步还是异步。</p><p>@babel/core 支持 plugin 和 preset，一般我们配置的都是对象的格式，其实也有一个 api 来创建，也就是 createConfigItem：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createConfigItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, options) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// configItem</span></span></code></pre></div><p>不过用和不用的没啥区别，常用的还是直接写配置对象。</p><p>除了这些包之外，也可以安装 @types/babel__xx 的包来增加 ts 的提示，比如 @types/babel__parser、@types/babel__traverse 等。</p><p>或者通过 debugger 的方式跑，也可以看到有啥 api 可用。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这一节我们了解了编译过程中各阶段的 api：</p><ul><li><code>@babel/parser</code> 对源码进行 parse，可以通过 plugins、sourceType 等来指定 parse 语法</li><li><code>@babel/traverse</code> 通过 visitor 函数对遍历到的 ast 进行处理，分为 enter 和 exit 两个阶段，具体操作 AST 使用 path 的 api，还可以通过 state 来在遍历过程中传递一些数据</li><li><code>@babel/types</code> 用于创建、判断 AST 节点，提供了 xxx、isXxx、assertXxx 的 api</li><li><code>@babel/template</code> 用于批量创建节点</li><li><code>@babel/code-frame</code> 可以创建友好的报错信息</li><li><code>@babel/generator</code> 打印 AST 成目标代码字符串，支持 comments、minified、sourceMaps 等选项。</li><li><code>@babel/core</code> 基于上面的包来完成 babel 的编译流程，可以从源码字符串、源码文件、AST 开始。</li></ul><p>学完这一节，我们可以用 babel 的 api 来实现一些功能了，下一节开始第一个实战案例。</p>`,142),n=[p];function l(h,k,r,d,o,c){return a(),i("div",null,n)}const b=s(t,[["render",l]]);export{g as __pageData,b as default};
