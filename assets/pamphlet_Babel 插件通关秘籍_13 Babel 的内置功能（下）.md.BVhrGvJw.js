import{_ as s,c as a,o as e,a2 as p}from"./chunks/framework.D8Prfz4N.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/Babel 插件通关秘籍/13 Babel 的内置功能（下）.md","filePath":"pamphlet/Babel 插件通关秘籍/13 Babel 的内置功能（下）.md"}'),n={name:"pamphlet/Babel 插件通关秘籍/13 Babel 的内置功能（下）.md"},i=p(`<p>上一节我们学习了 babel 插件的分类、babel 的 preset、helper、runtime。babel 的功能基本都建立在这些之上。</p><p>我们通过插件完成了各种代码（es next、proposal、typescript/flow/jsx...）到 es5 的转换，然后把不同的转换插件封装到不同的 preset （preset-env、preset-typescript、preset-react...）里，而且还把插件内部的公共逻辑抽成 helper 来复用，并且提供了 runtime 包用于注入运行时的 api。这样已经能够达到不同语法的代码转 es5 同时对 api 进行 polyfill 的目标了。</p><p>平时我们使用 babel 并不需要了解 runtime、helper 都是什么，plugin 怎么写，只需要会用 preset 就行了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db2df27864ce48799ebef97536393c15~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>由 preset 引入一系列 plugin，我们只需要选择不同的 preset 即可。</p><p>那 babel 的 preset 都是怎么设计的呢？</p><h2 id="preset-es20xx-到-preset-env" tabindex="-1">preset-es20xx 到 preset-env <a class="header-anchor" href="#preset-es20xx-到-preset-env" aria-label="Permalink to &quot;preset-es20xx 到 preset-env&quot;">​</a></h2><p>babel6 支持的 preset 是 preset-es2015、preset-es2016、preset-stage-x 等。</p><p>也就是根据目标语言版本来指定一系列插件。</p><p>但是这样的 preset 设计有个问题：</p><p>指定了目标环境支持 es5，但如果目标环境支持了部分 es6（es2015）、es7（es2016）等，那岂不是做了很多没必要的转换？</p><p>还有，reset-es2015、preset-es2016、preset-stage-x 这种 preset 跟随版本走的，那岂不是经常变，得经常改这些 preset 的内容 （当某个提案从 stage 0 进入到 stage 1 就得改下），这样多麻烦啊，而且用户也得经常改配置，stage-x 用到了啥对用户来说也是黑盒。</p><p>怎么解决这些问题呢？</p><p>babel6 到 babel7 的变化给出了答案：</p><p>babel7 废弃了 stage-x 和 es20xx 的 preset，改成 preset-env 和 plugin-proposal-xx 的方式。</p><p>这样就不需要指定用的是 es 几了，默认会全部支持，包含<a href="https://github.com/babel/babel/blob/master/packages/babel-compat-data/scripts/data/plugin-features.js" target="_blank" rel="noreferrer">所有的已经是语言标准特性的 transform plugin</a>。</p><p>而且 stage-x 有哪些不再是黑盒，用户想用啥 proposal 的特性直接显示引入对应的 proposal plugin。</p><p>做了很多无用的转换的问题通过指定目标环境来解决。</p><p>但是目标环境那么多，浏览器版本、node 版本、electron 版本每年都在变，怎么做到精准？</p><h5 id="comat-table" tabindex="-1">comat-table <a class="header-anchor" href="#comat-table" aria-label="Permalink to &quot;comat-table&quot;">​</a></h5><p>答案是 compat-table 的数据，compat-table 提供了每个特性在不同环境中的支持版本。</p><p>比如<a href="https://github.com/kangax/compat-table/blob/gh-pages/data-es6.js#L1864-L1904" target="_blank" rel="noreferrer">默认参数</a>这个 es2015 的特性，可以查到在 babel6 且 corejs2 以上支持，在 chrome 中是 49 以上支持，chrome48 中还是实验特性，在 node6 以上支持，等等。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f1adc5fc56d4ec1ad4cb757eb3356c5~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>光是这些数据还不够，electron 有自己的版本，要支持 electron 得需要 electron 版本和它用的 chromuim 的版本的对应关系。</p><p>万幸有 electron-to-chromium 这个项目，它维护了 <a href="https://github.com/Kilian/electron-to-chromium/blob/master/full-versions.js" target="_blank" rel="noreferrer">electron 版本到 chromium 版本的映射关系</a>。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87e37c9049544f429cd2a48afb434a81~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>也可以反过来查询 <a href="https://github.com/Kilian/electron-to-chromium/blob/master/full-chromium-versions.js" target="_blank" rel="noreferrer">chromium 版本在哪些 electron 版本中使用</a>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d759abbb6a8f422aa791f6ce6e2dd918~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>有了这些数据，我们就能知道每一个特性在哪些环境的什么版本支持。</p><p>babel7 在 @babel/compat-data 这个包里面维护了这种特性到环境支持版本的映射关系，包括 <a href="https://github.com/babel/babel/blob/main/packages/babel-compat-data/data/plugins.json" target="_blank" rel="noreferrer">plugin 实现的特性的版本支持情况</a>（包括 transform 和 proposal ），也包括 <a href="https://github.com/babel/babel/blob/main/packages/babel-compat-data/data/corejs2-built-ins.json" target="_blank" rel="noreferrer">corejs 所 polyfill 的特性的版本支持情况</a>。</p><p>比如：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ed0641db8a4547a8c857306c22e286~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>这样我们就知道每一个特性是在什么环境中支持的了，接下来只要用户指定一个环境，我们就能做到按需转换！</p><h5 id="browserslist" tabindex="-1">browserslist <a class="header-anchor" href="#browserslist" aria-label="Permalink to &quot;browserslist&quot;">​</a></h5><p>那开发者怎么指定环境呢？</p><p>让开发者写每个环境的版本是啥肯定不靠谱，这时候就要借助 browerslist 了，它提供了一个从 query （查询表达式） 到对应环境版本的转换。</p><p>比如我们可以通过 last 1 version 来查询最新的各环境的版本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6aa23bc2102480894c72916418b3eb1~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>也可以通过 supports es6-module 查询所有支持 es module 的环境版本</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1cf4c0f5294a268043e03e0d866327~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>具体查询的语法有很多，可以去 <a href="https://github.com/browserslist/browserslist#queries" target="_blank" rel="noreferrer">browserslist 的 query 文档</a>中学习，这里就不展开了。</p><h5 id="babel-preset-env" tabindex="-1">@babel/preset-env <a class="header-anchor" href="#babel-preset-env" aria-label="Permalink to &quot;@babel/preset-env&quot;">​</a></h5><p>现在有了什么特性在什么环境版本中支持，有了可以通过 query 指定目标环境版本的工具，那么就可以上手改了，从都转成 es5 到根据目标环境确定不支持的特性，只转换这部分特性，这就是 @babel/preset-env 做的事情。</p><p>有了 @babel/compat-data 的数据，那么只要用户指定他的目标环境是啥就可以了，这时候可以用 browserslist 的 query 来写，比如 <code>last 1 version, &gt; 1%</code> 这种字符串，babel 会使用 brwoserslist 来把它们转成目标环境具体版本的数据。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a318db95f7cb4f139981f2f453bdc39e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>有了不同特性支持的环境的最低版本的数据，有了具体的版本，那么过滤出来的就是目标环境不支持的特性，然后引入它们对应的插件即可。这就是 preset-env 做的事情(按照目标环境按需引入插件)。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ccb1144f8924fb99cc6073859289124~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>配置方式比如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;presets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@babel/preset-env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;targets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt; 0.25%, not dead&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }]]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样就通过 preset-env 解决了多转换了目标环境已经支持的特性的问题。</p><p>其实 polyfill 也可以通过 targets 来过滤。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d8df3916feb4da7b445e8771e779353~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>不再手动引入 polyfill，那么怎么引入？ 当然是用 preset-env 自动引入了。但是不是默认就会启用这个功能，需要配置。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;presets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;@babel/preset-env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;targets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt; 0.25%, not dead&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;useBuiltIns&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;usage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// or &quot;entry&quot; or &quot;false&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;corejs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }]]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>配置下 corejs 和 useBuiltIns。</p><ul><li><p>corejs 就是 babel 7 所用的 polyfill，需要指定下版本，corejs 3 才支持实例方法（比如 Array.prototype.fill ）的 polyfill。</p></li><li><p>useBuiltIns 就是使用 polyfill （corejs）的方式，是在入口处全部引入（entry），还是每个文件引入用到的（usage），或者不引入（false）。</p></li></ul><p>配置了这两个 option 就可以自动引入 polyfill 了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ea48ded51f04512bac80b8e4db809cb~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h4 id="babel-preset-env-的配置" tabindex="-1">@babel/preset-env 的配置 <a class="header-anchor" href="#babel-preset-env-的配置" aria-label="Permalink to &quot;@babel/preset-env 的配置&quot;">​</a></h4><p>这个包的配置比较多，首先我们要指定的是 targets，也就是 browserslist 的 query，这个同样可以在 .browserslistrc 的配置文件中指定（别的工具也可能用到）。</p><p>具体有啥配置可以看 <a href="https://www.babeljs.cn/docs/babel-preset-env" target="_blank" rel="noreferrer">@babel/preset-env 的文档</a>，这里简单讲几个：</p><h5 id="targets" tabindex="-1">targets <a class="header-anchor" href="#targets" aria-label="Permalink to &quot;targets&quot;">​</a></h5><p>targets 是指定编译的目标环境的，可以配 query 或者直接指定环境版本（query 的结果也是环境版本）。</p><p>环境有这些：</p><p>chrome, opera, edge, firefox, safari, ie, ios, android, node, electron</p><p>可以指定 query：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;targets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt; 0.25%, not dead&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>也可以直接指定环境版本；</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;targets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;chrome&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;58&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;ie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;11&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="include-exclude" tabindex="-1">include &amp; exclude <a class="header-anchor" href="#include-exclude" aria-label="Permalink to &quot;include &amp; exclude&quot;">​</a></h5><p>通过 targets 的指定，babel 会自动引入<a href="https://github.com/babel/babel/blob/master/packages/babel-compat-data/scripts/data/plugin-features.js" target="_blank" rel="noreferrer">一些插件</a>，但如果觉得自动引入的不大对，也可以手动指定。</p><p>当需要手动指定要 include 或者 exclude 什么插件的时候可以使用这个 option。</p><p>不过这个只是针对 transform plugin，对于 proposal plugin，要在 plugins 的 option 单独引入。</p><p>一般情况下用 preset-env 自动引入的就可以了。</p><h5 id="modules" tabindex="-1">modules <a class="header-anchor" href="#modules" aria-label="Permalink to &quot;modules&quot;">​</a></h5><p>babel 转换代码自然会涉及到模块语法的转换。</p><p>modules 就是指定目标模块规范的，取值有 amd、umd、systemjs、commonjs (cjs)、auto、false。</p><ul><li><p>amd、umd、systemjs、commonjs (cjs) 这四个分别指定不同的目标模块规范</p></li><li><p>false 是不转换模块规范</p></li><li><p>auto 则是自动探测，默认值也是这个。</p></li></ul><p>其实一般这个 option 都是 bundler 来设置的，因为 bundler 负责模块转换，自然知道要转换成什么模块规范。我们平时就用默认值 auto 即可。</p><p>auto 会根据探测到的目标环境支持的模块规范来做转换。依据是在 transform 的时候传入的 caller 数据。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">babel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;example.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  caller: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-custom-tool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    supportsStaticESM: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>比如在调用 transformFile 的 api 的时候传入了 caller 是支持 esm 的，那么在 targets 的 modules 就会自动设置为 esm。</p><h5 id="debug" tabindex="-1">debug <a class="header-anchor" href="#debug" aria-label="Permalink to &quot;debug&quot;">​</a></h5><p>我们知道 preset-env 会根据 targets 支持的特性来引入一系列插件。</p><p>想知道最终使用了啥插件，那就可以把 debug 设为 true，这样在控制台打印这些数据。</p><p>比如</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sourceCode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  import &quot;core-js&quot;;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  new Array(5).fill(&#39;111&#39;);</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> babel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transformSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sourceCode, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a.mjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    targets: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        browsers: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Chrome 45&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    presets: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@babel/env&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            debug: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            useBuiltIns: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;usage&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            corejs: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>设置 debug 为 true，会打印 targets 和根据 tragets 过滤出的的 plugin 和 preset：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@babel/preset-env: \`DEBUG\` option</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Using targets:</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;chrome&quot;: &quot;45&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Using modules transform: auto</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Using plugins:</span></span>
<span class="line"><span>  proposal-numeric-separator { chrome &lt; 75 }</span></span>
<span class="line"><span>  proposal-logical-assignment-operators { chrome &lt; 85 }</span></span>
<span class="line"><span>  proposal-nullish-coalescing-operator { chrome &lt; 80 }</span></span>
<span class="line"><span>  proposal-optional-chaining { chrome }</span></span>
<span class="line"><span>  proposal-json-strings { chrome &lt; 66 }</span></span>
<span class="line"><span>  proposal-optional-catch-binding { chrome &lt; 66 }</span></span>
<span class="line"><span>  transform-parameters { chrome &lt; 49 }</span></span>
<span class="line"><span>  proposal-async-generator-functions { chrome &lt; 63 }</span></span>
<span class="line"><span>  proposal-object-rest-spread { chrome &lt; 60 }</span></span>
<span class="line"><span>  transform-dotall-regex { chrome &lt; 62 }</span></span>
<span class="line"><span>  proposal-unicode-property-regex { chrome &lt; 64 }</span></span>
<span class="line"><span>  transform-named-capturing-groups-regex { chrome &lt; 64 }</span></span>
<span class="line"><span>  transform-async-to-generator { chrome &lt; 55 }</span></span>
<span class="line"><span>  transform-exponentiation-operator { chrome &lt; 52 }</span></span>
<span class="line"><span>  transform-function-name { chrome &lt; 51 }</span></span>
<span class="line"><span>  transform-arrow-functions { chrome &lt; 47 }</span></span>
<span class="line"><span>  transform-classes { chrome &lt; 46 }</span></span>
<span class="line"><span>  transform-object-super { chrome &lt; 46 }</span></span>
<span class="line"><span>  transform-for-of { chrome &lt; 51 }</span></span>
<span class="line"><span>  transform-sticky-regex { chrome &lt; 49 }</span></span>
<span class="line"><span>  transform-unicode-regex { chrome &lt; 50 }</span></span>
<span class="line"><span>  transform-spread { chrome &lt; 46 }</span></span>
<span class="line"><span>  transform-destructuring { chrome &lt; 51 }</span></span>
<span class="line"><span>  transform-block-scoping { chrome &lt; 49 }</span></span>
<span class="line"><span>  transform-new-target { chrome &lt; 46 }</span></span>
<span class="line"><span>  transform-regenerator { chrome &lt; 50 }</span></span>
<span class="line"><span>  proposal-export-namespace-from { chrome &lt; 72 }</span></span>
<span class="line"><span>  transform-modules-commonjs</span></span>
<span class="line"><span>  proposal-dynamic-import</span></span>
<span class="line"><span>corejs3: \`DEBUG\` option</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Using targets: {</span></span>
<span class="line"><span>  &quot;chrome&quot;: &quot;45&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Using polyfills with \`usage-global\` method:</span></span>
<span class="line"><span>regenerator: \`DEBUG\` option</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Using targets: {</span></span>
<span class="line"><span>  &quot;chrome&quot;: &quot;45&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Using polyfills with \`usage-global\` method:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  When setting \`useBuiltIns: &#39;usage&#39;\`, polyfills are automatically imported when needed.</span></span>
<span class="line"><span>  Please remove the direct import of \`core-js\` or use \`useBuiltIns: &#39;entry&#39;\` instead.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[/Users/zhaixuguang/code/research/babel/a.mjs]</span></span>
<span class="line"><span>Based on your code and targets, the corejs3 polyfill did not add any polyfill.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>[/Users/zhaixuguang/code/research/babel/a.mjs]</span></span>
<span class="line"><span>Based on your code and targets, the regenerator polyfill did not add any polyfill.</span></span></code></pre></div><p>用到了哪些插件一目了然，开发时可以开启这个配置项。</p><p>我们知道了 preset-env 能够根据目标环境引入对应的插件，最终会注入 helper 到代码里，但这样还是有问题的：</p><h2 id="从-helper-到-runtime" tabindex="-1">从 helper 到 runtime <a class="header-anchor" href="#从-helper-到-runtime" aria-label="Permalink to &quot;从 helper 到 runtime&quot;">​</a></h2><p>preset-env 会在使用到新特性的地方注入 helper 到 AST 中，并且会引入用到的特性的 polyfill （corejs + regenerator），这样会导致两个问题：</p><ul><li>重复注入 helper 的实现，导致代码冗余</li><li>polyfill 污染全局环境</li></ul><p>解决这两个问题的思路就是抽离出来，然后作为模块引入，这样多个模块复用同一份代码就不会冗余了，而且 polyfill 是模块化引入的也不会污染全局环境。</p><p>使用 transform-runtime 之前：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f378b7119ff4a78921220434520b4a7~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>使用 transform-runtime 之后：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60f091b521a44531b54f11f4d90c621c~tplv-k3u1fbpfcp-watermark.image?" alt=""></p><p>这个逻辑是在 @babel/plugin-transform-runtime 包里实现的。它可以把直接注入全局的方式改成模块化引入。</p><p>比如使用 preset-env 的时候是全局引入的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ea48ded51f04512bac80b8e4db809cb~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>当引入 @babel/plugin-transform-runtime 就可以模块化引入：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64df84f32f6945c19bac48cc7185dee7~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>这样就不再污染全局环境了。</p><p>babel7 通过 preset-env 实现了按需编译和 polyfill，还可以用 plugin-transform-runtime 来变成从 @babel/runtime 包引入的方式。</p><p>但这也不是完美的，还有一些问题：</p><h3 id="babel7-的问题" tabindex="-1">babel7 的问题 <a class="header-anchor" href="#babel7-的问题" aria-label="Permalink to &quot;babel7 的问题&quot;">​</a></h3><p>我们先来试验一下：</p><p>看一下 Array.prototype.fill 的环境支持情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cae7d0873384728a404963eff4861c4~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>可以看到在 Chrome 45 及以上支持这个特性，而在 Chrome 44 就不支持了。</p><p>我们先单独试一下 preset-env：</p><p>当指定 targets 为 Chrome 44 时，应该自动引入polyfill：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d43b57304a4d2f9f64af086f5d6098~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>当指定 targets 为 Chrome 45 时，不需要引入polyfill：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f68b5ad95f644518c8419c1847f7765~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>结果都符合预期，44 引入，45 不引入。</p><p>我们再来试试 @babel/plugin-transform-runtime：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9677f1aaba654728aec933b31e632fe0~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>是不是发现问题了，Chrome 45 不是支持 Array.prototype.fill 方法么，为啥还是引入了 polyfill。</p><p>因为 babel 中插件的应用顺序是：先 plugin 再 preset，plugin 从左到右，preset 从右到左，这样 plugin-transform-runtime 是在 preset-env 前面的。等 @babel/plugin-transform-runtime 转完了之后，再交给 preset-env 这时候已经做了无用的转换了。而 @babel/plugin-transform-runtime 并不支持 targets 的配置，就会做一些多余的转换和 polyfill。</p><p>这个问题在即将到来的 babel8 中得到了解决。</p><h3 id="babel8" tabindex="-1">babel8 <a class="header-anchor" href="#babel8" aria-label="Permalink to &quot;babel8&quot;">​</a></h3><p>babel8 提供了 <a href="https://github.com/babel/babel-polyfills" target="_blank" rel="noreferrer">一系列 babel polyfill 的包 </a> ，解决了 babel7 的 @babel/plugin-transform-runtime 的遗留问题，可以通过 targets 来按需精准引入 polyfill。</p><p>babel8 支持配置一个 polyfill provider，也就是说你可以指定 corejs2、corejs3、es-shims 等 polyfill，还可以自定义 polyfil。</p><p>有了 polyfill 源之后，使用 polyfill 的方式也把之前 transform-runtime 做的事情内置了，从之前的 useBuiltIns: entry、 useBuiltIns: usage 的两种，变成了 3 种：</p><ul><li>entry-global: 这个和之前的 useBuiltIns: entry 对标，就是全局引入 polyfill。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202c38690dfe455b8c033d6e54ede9b2~tplv-k3u1fbpfcp-watermark.image" alt=""></p><ul><li>usage-entry: 这个和 useBuiltIns: usage 对标，就是具体模块引入用到的 polyfill。</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21d206affa374e53a786592e6a0cfa6e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><ul><li>usage-pure：这个就是之前需要 transform-runtime 插件做的事情，使用不污染全局变量的 pure 的方式引入具体模块用到的 polyfill.</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c65f9672d34c04814142bf04ccc8b9~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>其实这三种方式 babel 7 也支持，但是 babel8 不再需要 transform-runtime 插件了，而且还支持了 polyfill provider 的配置。</p><p>babel 的功能都是通过插件完成的，但是直接指定插件太过麻烦，所以设计出了 preset，我们学习 babel 的内置功能基本等价于学习 preset 的使用。主要是 preset-env、preset-typescript 这些。</p><p>但是一些 proposal 的插件需要单独引入，并且 @babel/plugin-transform-runtime也要单独引入。</p><p>学习内置功能的话 preset 是重点，但是最终完成功能的还是通过插件。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>上一节我们基于 plugin 和 preset 已经能够完成 esnext 等代码转目标环境 js 代码的功能，但是还不完美。</p><p>这一节我们介绍了 @babel/preset-env，它基于每种特性的在不同环境的最低支持版本的数据和配置的 targets 来过滤插件，这样能减少很多没必要的转换和 polyfill。</p><p>如果希望把一些公共的 helper、core-js、regenerator 等注入的 runtime 函数抽离出来，并且以模块化的方式引入，那么需要用 @babel/plugin-transform-runtime 这个包。</p><p>@babel/plugin-transform-runtime 不支持根据 targets 的过滤，和 @babel/preset-env 配合时有问题，这个在 babel8 中得到了解决。babel8 提供了很多 babel polyfill 包，支持了 polyfill provider 的配置，而且还可以选择注入方式。不再需要 @babel/plugin-transform-runtime 插件了。</p><p>学完这一节，我们知道了 babel 如何基于 targets 的配置做到精准的转换，我们平时开发主要是使用 preset，了解下 preset 设计和演变还是很有意义的。</p>`,143),t=[i];function l(r,o,h,c,k,b){return e(),a("div",null,t)}const m=s(n,[["render",l]]);export{g as __pageData,m as default};
