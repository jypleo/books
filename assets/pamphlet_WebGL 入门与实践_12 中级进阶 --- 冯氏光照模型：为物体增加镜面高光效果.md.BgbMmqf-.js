import{_ as s,c as i,o as a,a2 as n}from"./chunks/framework.D8Prfz4N.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/WebGL 入门与实践/12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果.md","filePath":"pamphlet/WebGL 入门与实践/12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果.md"}'),l={name:"pamphlet/WebGL 入门与实践/12 中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果.md"},h=n(`<p>前两个章节我们讲述了冯氏光照模型的环境光和漫反射光，本节我们学习组成冯氏光照的最后一个因素：镜面高光。</p><h2 id="镜面高光现象" tabindex="-1">镜面高光现象 <a class="header-anchor" href="#镜面高光现象" aria-label="Permalink to &quot;镜面高光现象&quot;">​</a></h2><p>大家小时候应该都做过这样的恶作剧，上课的时候拿一面镜子，对准某个同学，慢慢调整镜子的角度，直到反射的太阳光照在对方的脸上，然后引起该同学的极度不适。</p><p>有没有想过为什么会有这种现象？</p><p>有的同学答了，这是因为镜子的反射光正好进入了同学的眼睛里。</p><p>说的没错，那假如我拿一件衣服来反射太阳光，能不能达到同样的效果。</p><p>很多同学脱口而出：不能。</p><p>是的，可是大家有没有想过为什么不能？</p><p>也许大家会出于直觉回答，因为衣服不反光，镜子反光。其实也对，但不太严谨。事实上衣服也反光，只是衣服表面过于粗糙，光线被散射到了各个方向，不能集中射向一个方向，导致进入人眼的光线强度大大削弱。镜子就不同了，镜子比较光滑，光线反射方向比较统一，进入人眼的光线强度也就越多，从而产生刺眼的效果。</p><p>冯氏光照模型使用<code>镜面高光分量</code>来模拟这种现象。</p><h2 id="镜面高光的表示与计算" tabindex="-1">镜面高光的表示与计算 <a class="header-anchor" href="#镜面高光的表示与计算" aria-label="Permalink to &quot;镜面高光的表示与计算&quot;">​</a></h2><p>与漫反射分量相同，镜面高光也是根据光线的入射方向向量和法向量来决定的，只不过镜面高光还需要依赖视线的观察方向，也就是眼睛是从什么方向观察的物体。</p><p>视线方向向量与反射光向量的之间的夹角越小，夹角余弦值就会越大，那么人眼感受到的光照就会越强，反之，光照越暗。因此，我们使用夹角的余弦值表示镜面高光因子，然后再用镜面高光因子乘以光线颜色即可求出镜面高光分量：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667c881d9ddb04c~tplv-t2oaga2asx-image.image" alt=""></p><ul><li>1、首先需要求出反射光向量<code>reflectDirection</code>和人眼视线方向向量<code>viewDirection</code>。</li><li>2、归一化两个向量。</li><li>3、求出两个归一化向量的点积，得到镜面高光因子。</li><li>4、将上一步求出的高光因子乘以光线颜色，得到镜面高光分量。</li></ul><p>本节我们使用 GLSL 内置的反射向量算法<code>reflect(inVec, normal)</code>，其中 <code>inVec</code> 为入射向量，方向由光源指向入射点，<code>normal</code> 为入射点的法向量。</p><h2 id="如何实现镜面高光" tabindex="-1">如何实现镜面高光 <a class="header-anchor" href="#如何实现镜面高光" aria-label="Permalink to &quot;如何实现镜面高光&quot;">​</a></h2><p>接下来，我们开始编码实现镜面高光效果。</p><h3 id="计算反射光向量" tabindex="-1">计算反射光向量 <a class="header-anchor" href="#计算反射光向量" aria-label="Permalink to &quot;计算反射光向量&quot;">​</a></h3><p>反射光向量在片元着色器中实现，参照上一节漫反射分量的计算，我们已经有了光源位置<code>u_LightPosition</code>和入射点位置<code>v_Position</code>，所以可以求得入射光向量：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//求出入射光向量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lightDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_LightPosition</span></span></code></pre></div><blockquote><p>切记，在使用GLSL 的reflect 函数计算反射光向量时，一定要确保入射光向量的方向是从光源位置指向入射点位置。</p></blockquote><p>有了入射光向量，我们还需要入射点的法向量<code>v_Normal</code>，这个值已经从顶点着色器中插值化后传到片元着色器了，所以我们可以直接拿来用：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reflectDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reflect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lightDirection), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_Normal));</span></span></code></pre></div><p>这样就求出了反射光向量，接下来我们计算视线观察向量。</p><h3 id="计算视线观察向量" tabindex="-1">计算视线观察向量 <a class="header-anchor" href="#计算视线观察向量" aria-label="Permalink to &quot;计算视线观察向量&quot;">​</a></h3><p>我们将入射点到观察者的方向向量定义为视线观察向量，为了计算这个向量，我们需要知道入射点的位置以及观察者的位置，入射点的位置我们有了，现在需要观察者的位置，我们将人眼在世界坐标系下的坐标作为观察者位置，然后将其用 <code>uniform</code> 变量的形式传递到片元着色器中。</p><p>因此我们的片元着色器要增加一个 <code>uniform</code> 变量接收观察者坐标。</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察者坐标。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uniform</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewPosition;</span></span></code></pre></div><p>有了观察者坐标，我们就可以计算出视线观察向量了。</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 视线观察向量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewPosition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Position;</span></span></code></pre></div><h3 id="计算镜面高光因子" tabindex="-1">计算镜面高光因子 <a class="header-anchor" href="#计算镜面高光因子" aria-label="Permalink to &quot;计算镜面高光因子&quot;">​</a></h3><p>前面求出了视线观察向量和反射光向量，接下来我们就可以计算镜面高光因子了。</p><p>首先，归一化<code>视线观察向量</code>和<code>反射光向量</code></p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">viewDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(viewDirection);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reflectDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectDirection);</span></span></code></pre></div><p>然后计算这两个向量的点积，这里要注意一点，就是如果这两个向量的点积为负数，则说明视线观察向量和反射光向量大于 90 度，是没有反射光进入眼睛的，所以我们使用 <code>max</code>函数取点积和 0 之间的最大值。</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 镜面高光因子</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(viewDirection, reflectDirection);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果为负值，一律设置为 0。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(specialFactor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>完整的片元着色器程序如下：</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    precision mediump </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    varying</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Color;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uniform</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_LightColor;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uniform</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_AmbientFactor;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uniform</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_LightPosition;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    varying</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Position;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    varying</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Normal;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uniform</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_ViewPosition;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 环境光分量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      vec3 ambient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_AmbientFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_LightColor;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //环境光分量</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 光线照射向量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      vec3 lightDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  v_Position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_LightPosition;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 归一化光线照射向量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lightDirection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lightDirection);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 漫反射因子</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> diffuseFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lightDirection), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_Normal));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 如果大于 90 度，则无光线进入人眼，漫反射因子设置为0。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      diffuseFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diffuseFactor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 漫反射光照</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      vec3 diffuseLightColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u_LightColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> diffuseFactor;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 归一化视线观察向量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      vec3 viewDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_Position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_ViewPosition);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		//反射向量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      vec3 reflectDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reflect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lightDirection, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_Normal));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 初始化镜面光照因子</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 如果有光线进入人眼。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diffuseFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       	specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(viewDirection), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectDirection));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(specialFactor,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 计算镜面光照分量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      vec3 specialLightColor  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_LightColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 计算总光照</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      vec3 outColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ambient </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> diffuseLightColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> specialLightColor;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 将物体自身颜色乘以总光照，即人眼看到的物体颜色。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      gl_FragColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vec4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(outColor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><p>加入光照之后，我们的着色器代码就变多了，但其实并不复杂，仅仅是<code>取值</code>、<code>计算</code>、<code>赋值</code>操作而已。</p><h3 id="javascript-部分" tabindex="-1">JavaScript 部分 <a class="header-anchor" href="#javascript-部分" aria-label="Permalink to &quot;JavaScript 部分&quot;">​</a></h3><p>镜面光照我们需要为着色器传递一个人眼观察位置，所以我们的JavaScript 部分需要修改：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取着色器全局变量 \`u_ViewPosition\`</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> u_ViewPosition </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUniformLocation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(program, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;u_ViewPosition&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>将人眼观察位置放置在 z 轴正方向 10 位置，即物体的前面。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uniforms </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	eyeX: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	eyeY: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	eyeZ: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uniform3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u_ViewPosition, uniforms[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;eyeX&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], uniforms[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;eyeY&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], uniforms[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;eyeZ&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span></code></pre></div><p>完整的代码大家可以参见<a href="./.html">这里</a>，我们比较下加入镜面高光前后的效果。</p><p>无镜面高光时：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/16685394ede269fc~tplv-t2oaga2asx-image.image" alt=""></p><p>添加镜面高光后：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166853931eb2c864~tplv-t2oaga2asx-image.image" alt=""></p><p>观察上面两幅图，我们能很直观地看到添加镜面高光后，球体正中央有一个明晃晃的光圈，符合真实世界中的场景。</p><h2 id="反光度" tabindex="-1">反光度 <a class="header-anchor" href="#反光度" aria-label="Permalink to &quot;反光度&quot;">​</a></h2><p>但是，这个刺眼的光圈面积太大了，我们需要给它添加一个称为<code>反光度</code>(shininess)的参数约束光圈的大小，一个物体的反光度越大，反光率就越强，散射的光就越少，我们看到的高光面积就越小。</p><p>我们定义一个<code>u_Shininess</code>的变量表示物体的反光度，然后用前面求得的高光因子乘以 2 的shininess次幂作为最终的高光因子。这样就可以让我们的光圈变得小一些。</p><blockquote><p>求幂计算可以通过GLSL 内置的公式 pow(2, shininess)求得。</p></blockquote><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(specialFactor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(specialFactor, u_Shininess);</span></span></code></pre></div><p>一般情况下，我们设置物体的反光度为 32 就可以了，但是特殊场景下，效果可能不理想，这时候，我们就需要根据实际情况调整反光度了。</p><p>我们将反光度设置成 32，看下增加反光度后的效果：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/17/16682af8af2b40a2~tplv-t2oaga2asx-image.image" alt=""></p><p>这会效果明显好多了，我们可以看到光圈点很小了，大家可以<a href="./.html">点击此处</a>查看我做的 demo，调节反光度看下效果。</p><h3 id="blinn-phong光照模型" tabindex="-1">Blinn-Phong光照模型 <a class="header-anchor" href="#blinn-phong光照模型" aria-label="Permalink to &quot;Blinn-Phong光照模型&quot;">​</a></h3><p>冯氏光照模型不仅能够很好的近似真实光照，而且性能也相当高。但是 这种光照在某些场景下仍然有些缺陷，大家观察前面没有添加反光度时的图片，应该能发现高光光圈边缘有一圈很明显的暗灰色断痕，但大家再看一下增加反光度后的效果，却没发现这种现象。这是为什么呢？</p><p>产生这个问题的原因是，在高光边缘部位，由于人眼视线向量和反射光向量夹角大于90度，那么夹角的余弦值便小于 0，按照冯氏光照模型的镜面光照算法，夹角余弦值小于 0 时， 我们的镜面高光分子系数就会用 0 来代替。所以高光边缘部位及以外的部分就没有了镜面光照分量，试想一下，如果反光度越小，镜面高光区域就越大，那高光区域边缘部位漫反射光的分量所占比重就会比较小，在高光边缘部位就会产生一种较大的亮度差，给人一种暗灰色断痕的感觉。反之，反光度越小，光圈越小，相应地，光圈周围漫反射光的分量所占比重就比较大，所以不会在高光边缘产生过大的亮度差。</p><p>如下图，反射光线和视线观察向量之间的夹角γ 大于90度，所以此时镜面高光分量为 0。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/1668555808c1edac~tplv-t2oaga2asx-image.image" alt=""></p><p>其实，这种观察角度，镜面高光分量还是应该有的，只是值比较小而已。所以，出现了 Blin Phong 光照模型，这种光照模型不再利用反射向量，而是采用了<code>半程向量</code> ，半程向量是视线和反射光之间夹角的一半方向上的单位向量，利用半程向量和法向量之间的夹角余弦来表示镜面高光因子，半程向量和法向量之间的夹角越小，镜面高光分量越大，如下图所示：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166855f7d5303bea~tplv-t2oaga2asx-image.image" alt=""></p><h3 id="实现-blin-phong-光照" tabindex="-1">实现 Blin Phong 光照 <a class="header-anchor" href="#实现-blin-phong-光照" aria-label="Permalink to &quot;实现 Blin Phong 光照&quot;">​</a></h3><p>我们在冯氏光照代码的基础上加以修改，实现 Blin 光照模型。与冯氏光照模型不同的是，我们需要半程向量，半程向量该如何求呢？</p><p>按照向量的计算规则，半程向量只需要我们将视线观察向量和反射向量相加，然后将得出的结果归一化就可以求出了。</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 计算半程向量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> halfVector </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectDirection </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewDirection);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 计算高光因子</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> specialFactor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">normalize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_Nomral), halfVector);</span></span></code></pre></div><p>利用 GLSL 的内置函数，我们就很容易的求出来了。</p><p>从冯氏光照模型进化成 Blin光照模型，我们只需要改动这么一处就可以了，是不是觉得很简单呢？</p><p>算法是很简单，但是我希望大家还是能够把算法背后的原理搞清楚。这才是大家学习的目的。</p><p>好了，我们比较一下反光度同时为 1 的时候，冯氏光照和 Blin 光照之间的差别。</p><p>冯氏光照效果：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166853931eb2c864~tplv-t2oaga2asx-image.image" alt=""></p><p>Blin 光照效果：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166856699653738b~tplv-t2oaga2asx-image.image" alt=""></p><p>可以看到，采用 <code>Blin光照模型</code>后， 镜面高光区域过度的更加自然。</p><h2 id="回顾" tabindex="-1">回顾 <a class="header-anchor" href="#回顾" aria-label="Permalink to &quot;回顾&quot;">​</a></h2><p>至此，我们就讲完了冯氏光照模型，以及为了解决冯氏光照的缺陷而引入的 <code>Blin 光照模型</code>。</p><p>本节也涉及到了许多向量矩阵之间的计算，大家多加练习，不要被这些计算搞晕了。</p><p>接下来我们进入下一个环节的学习，对 GLSL 的语法进行一个总结。</p>`,84),p=[h];function t(e,k,r,d,E,g){return a(),i("div",null,p)}const y=s(l,[["render",t]]);export{c as __pageData,y as default};
