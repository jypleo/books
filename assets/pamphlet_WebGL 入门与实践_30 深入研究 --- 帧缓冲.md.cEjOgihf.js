import{_ as s,c as i,o as a,a2 as h}from"./chunks/framework.D8Prfz4N.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/WebGL 入门与实践/30 深入研究 --- 帧缓冲.md","filePath":"pamphlet/WebGL 入门与实践/30 深入研究 --- 帧缓冲.md"}'),l={name:"pamphlet/WebGL 入门与实践/30 深入研究 --- 帧缓冲.md"},n=h(`<p>在之前的章节中，我们已经接触过缓冲的概念了，比如顶点的坐标、颜色、法向量、纹理坐标等，今天我们学习一个新的缓冲概念：帧缓冲。</p><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p>顾名思义，帧缓冲（Frame Buffer Object）也是一个缓冲对象，不同于之前的缓冲，它相当于一个存在于内存中的不可见画布，我们可以先将即将绘制的内容绘制到帧缓冲中，然后对其做一些处理，之后，再将其绘制到画布上，这种方式让我们能够针对场景进行后处理，实现一些场景特效。</p><p>在之前的绘制过程中，渲染操作也是有帧缓冲的，只不过使用的是系统默认的帧缓冲。</p><p>显然，帧缓冲既然也是一块画布，那么它经常要和颜色打交道。因此，帧缓冲通常至少包含一个颜色缓冲区，除此之外，我们还需要一个图像载体，将图像绘制到载体上，载体分为两种，<code>纹理</code>和<code>渲染缓冲对象</code>。</p><p>纹理的优势是，我们可以在着色器中使用这个纹理，然后对其像素做后期处理。</p><p>渲染缓冲对象不能在着色器中使用，但是它有纹理不支持的特性，最大优点就是渲染缓冲所包含的各种数据是已经优化过的。</p><p>简单来说，帧缓冲就像提供给我们一个渲染前的画板，我们先在该画板上画好要显示的图像，满意之后再将它输出到屏幕上。</p><h2 id="实战" tabindex="-1">实战 <a class="header-anchor" href="#实战" aria-label="Permalink to &quot;实战&quot;">​</a></h2><p>我们将一幅图像用 2D 纹理渲染到自定义帧缓冲，同时将该自定义缓冲渲染到一个2D纹理，接下来再将帧缓冲对象绑定到默认帧缓冲，在默认帧缓冲上将上一步的纹理映射到一个立方体上，并在屏幕显示出来。</p><h3 id="创建帧缓冲对象" tabindex="-1">创建帧缓冲对象 <a class="header-anchor" href="#创建帧缓冲对象" aria-label="Permalink to &quot;创建帧缓冲对象&quot;">​</a></h3><p>首先创建帧缓冲对象，然后将该对象设置为绑定到<code>帧缓冲绑定点</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frameBuffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createFrameBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindFrameBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FRAMEBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, frameBuffer);</span></span></code></pre></div><h3 id="创建帧缓冲图像的写入纹理" tabindex="-1">创建帧缓冲图像的写入纹理 <a class="header-anchor" href="#创建帧缓冲图像的写入纹理" aria-label="Permalink to &quot;创建帧缓冲图像的写入纹理&quot;">​</a></h3><p>接下来，我们创建一个纹理对象，并设置帧缓冲向纹理写入数据时的参数，最后将帧缓冲和纹理进行关联。</p><p>创建帧缓冲纹理</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frameTexture </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, frameTexture);</span></span></code></pre></div><p>设置帧缓冲向纹理写入数据时的参数：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定到第一个颜色附加区。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> attachmentPoint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_ATTACHMENT0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 写入数据，注意初始化时应为 null。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 绑定帧缓冲纹理作为当前纹理操作对象。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, frameTexture);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置写入参数，256 代表纹理的宽和高。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">texImage2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UNSIGNED_BYTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置放大或者缩小时的算法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">texParameteri</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_MIN_FILTER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LINEAR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置超出边界时的算法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">texParameteri</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_WRAP_S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLAMP_TO_EDGE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">texParameteri</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_WRAP_T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CLAMP_TO_EDGE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将纹理和帧缓冲绑定。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framebufferTexture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FRAMEBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_ATTACHMENT0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, targetTexture, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>做完这几步，当我们执行完drawArrays等渲染操作之后，帧缓冲中的数据就渲染到该纹理对象上了。</p><h3 id="绘制帧缓冲" tabindex="-1">绘制帧缓冲 <a class="header-anchor" href="#绘制帧缓冲" aria-label="Permalink to &quot;绘制帧缓冲&quot;">​</a></h3><p>接下来，我们创建一个专门向帧缓冲纹理进行绘制的方法，该方法将向自定义缓冲渲染两个立方体。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> drawFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindFramebuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FRAMEBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, frameBuffer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearColor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_BUFFER_BIT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_BUFFER_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">viewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">绘制立方体，此处略。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你会发现，我们的每一个操作步骤都是有目的的：</p><ul><li>首先将自定义帧缓冲对象绑定到帧缓冲绑定点上。</li><li>之后设置清屏颜色，进行颜色和深度信息的清除处理，主要是为了和画布的绘制进行区分。</li><li>最后还需要重新设置绘图区域大小，这步也很关键，不然你会发现渲染到纹理上的图像和我们期待的不一样。</li></ul><h3 id="绘制到画布" tabindex="-1">绘制到画布 <a class="header-anchor" href="#绘制到画布" aria-label="Permalink to &quot;绘制到画布&quot;">​</a></h3><p>我们在默认缓冲绘制一个立方体，立方体每个面使用的纹理采用自定义缓冲渲染到的纹理。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindFramebuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FRAMEBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, frameTexture);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uniform1i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(useTexture, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearColor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_BUFFER_BIT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_BUFFER_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">viewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.canvas.width, gl.canvas.height);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uniform1i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u_Skybox, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">绘制立方体，此处略</span></span></code></pre></div><p>你会发现，我们的步骤和渲染到纹理步骤有所区别：</p><ul><li>首先将帧缓冲绑定到默认缓冲上。</li><li>其次绑定纹理对象为帧缓冲纹理，因为我们要将自定义帧缓冲渲染到立方体的每一个面上。</li><li>接着设置常量useTexture 为true，设置它为true是时才使用纹理。</li><li>设置清屏颜色，并进行清屏。</li><li>重新设置绘图区域。</li><li>将零号纹理传到着色器里。</li></ul><h3 id="效果" tabindex="-1">效果 <a class="header-anchor" href="#效果" aria-label="Permalink to &quot;效果&quot;">​</a></h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/30/1676035df672709d~tplv-t2oaga2asx-image.image" alt=""></p><p>这就是最终渲染的效果，立方体的每个面上被自定义帧缓冲上的对象所填充。</p><h3 id="加入深度缓冲" tabindex="-1">加入深度缓冲 <a class="header-anchor" href="#加入深度缓冲" aria-label="Permalink to &quot;加入深度缓冲&quot;">​</a></h3><p>上面的例子，我们只为帧缓冲附加了颜色缓冲信息，事实上，帧缓冲还可以附加深度缓冲、模板缓冲。接下来，我们为帧缓冲加入深度缓冲信息。 我们用渲染缓冲对象保存深度缓冲信息，那么首先要创建渲染缓冲对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个深度缓冲</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> renderBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createRenderbuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindRenderbuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RENDERBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, renderBuffer);</span></span></code></pre></div><p>接下来，设置渲染缓冲对象的大小，这里和前面创建的纹理大小保持一致。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置深度缓冲的大小和帧缓冲纹理一致。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">renderbufferStorage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RENDERBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_COMPONENT16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>最后，将渲染缓冲对象和帧缓冲对象进行关联。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">framebufferRenderbuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FRAMEBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DEPTH_ATTACHMENT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RENDERBUFFER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, renderBuffer);</span></span></code></pre></div><h4 id="效果-1" tabindex="-1">效果 <a class="header-anchor" href="#效果-1" aria-label="Permalink to &quot;效果&quot;">​</a></h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/30/167603d58b51e1f8~tplv-t2oaga2asx-image.image" alt=""></p><p>可以看到，两个立方体的深度信息显现出来了。</p><h2 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h2><p>那么，帧缓冲有什么好处呢？做了这个例子，大家心里也许已经有一些想法了。</p><p>在做一些赛车游戏时，如果玩家想从反光镜中看车后面的景色，这时候，帧缓冲就派上用场了。</p><p>再有，当我们需要对场景进行后期处理时，我们就可以 用帧缓冲渲染到纹理的方式，对纹理像素进行处理，实现某些特效，比如反向、模糊、黑白处理等。</p><h2 id="回顾" tabindex="-1">回顾 <a class="header-anchor" href="#回顾" aria-label="Permalink to &quot;回顾&quot;">​</a></h2><p>以上就是帧缓冲的内容，概念有些抽象，但是大家可以通过一些例子来感受它的存在。</p><p>至此，小册内容就结束了，下一节，我会对所学内容做一个总结。</p>`,50),k=[n];function t(p,e,E,r,d,g){return a(),i("div",null,k)}const c=s(l,[["render",t]]);export{F as __pageData,c as default};
