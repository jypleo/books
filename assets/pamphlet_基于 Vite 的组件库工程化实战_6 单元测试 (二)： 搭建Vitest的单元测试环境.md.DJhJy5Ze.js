import{_ as s,c as a,o as i,a2 as n}from"./chunks/framework.D8Prfz4N.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/基于 Vite 的组件库工程化实战/6 单元测试 (二)： 搭建Vitest的单元测试环境.md","filePath":"pamphlet/基于 Vite 的组件库工程化实战/6 单元测试 (二)： 搭建Vitest的单元测试环境.md"}'),t={name:"pamphlet/基于 Vite 的组件库工程化实战/6 单元测试 (二)： 搭建Vitest的单元测试环境.md"},p=n(`<p>这节课，我们来学习如何给组件库添加单元测试。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c002eb89adf24cfbafdbf56f88baa82c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在 Vite 栈的项目中，我首推 Vitest 作为测试框架。</p><h2 id="为什么要选择-vitest" tabindex="-1">为什么要选择 Vitest？ <a class="header-anchor" href="#为什么要选择-vitest" aria-label="Permalink to &quot;为什么要选择 Vitest？&quot;">​</a></h2><p>在 Vitest 之前，前端普遍的测试框架是 Jest。Jest 是由 Facebook 开源的一款测试框架，它本身集成了断言库、mock、快照测试、覆盖率报告等功能。比如 Vue3.0 还有流行的 ElementUI 组件库都是使用 Jest 完成的单元测试。</p><p>Vitest 是一个基于 Vite 的测试框架，它可以做到与 Vite 通用配置。也就是说，如果你在 Vite 中使用插件支持了JSX语法，做单元测试的时候就无需再配置一遍了，这点非常重要。并且 Vite 兼容了大部分 Jest 的使用方法，这样以往 Jest 的使用经验依然可以用在 Vitest 中使用，没有太多的重复学习过程。另外 Vitest 更加注重性能，尽可能多地使用 Worker 线程并发执行，可以提高测试的运行效率。</p><p>总结一下 Vitest 的优点：</p><ul><li><p>Vite 同配置；</p></li><li><p>大量兼容 JestAPI；</p></li><li><p>高执行效率。</p></li></ul><p>本章节代码分支： <a href="https://github.com/smarty-team/smarty-admin/tree/chapter06/packages/smarty-ui-vite" target="_blank" rel="noreferrer">https://github.com/smarty-team/smarty-admin/tree/chapter06/packages/smarty-ui-vite</a></p><h2 id="用户故事-userstory" tabindex="-1">用户故事(UserStory) <a class="header-anchor" href="#用户故事-userstory" aria-label="Permalink to &quot;用户故事(UserStory)&quot;">​</a></h2><p>通过VItest实现对组件的单元测试。</p><h2 id="任务分解-task" tabindex="-1">任务分解(Task) <a class="header-anchor" href="#任务分解-task" aria-label="Permalink to &quot;任务分解(Task)&quot;">​</a></h2><ul><li>搭建Vitest单元测试环境。</li></ul><h2 id="任务实现" tabindex="-1">任务实现 <a class="header-anchor" href="#任务实现" aria-label="Permalink to &quot;任务实现&quot;">​</a></h2><h3 id="搭建测试环境" tabindex="-1">搭建测试环境 <a class="header-anchor" href="#搭建测试环境" aria-label="Permalink to &quot;搭建测试环境&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pnpm i -D vitest@&quot;0.21.1&quot; happy-dom@&quot;6.0.4&quot; @vue/test-utils@&quot;2.0.2&quot;</span></span></code></pre></div><p>配置 Vitest 测试组件库需要以下三个库：</p><ul><li><p>vitest ：测试框架，用于执行整个测试过程并提供断言库、mock、覆盖率；</p></li><li><p>happy-dom：是用于提供在 Node 环境中的 Dom 仿真模型；</p></li><li><p>@vue/test-utils 工具库： Vue推荐的测试工具库。</p></li></ul><p>@vue/test-utils 工具库是为了简化vue的测试过程而设计的。实际上使用 jest 或者 vitest 也可以直接对 vue 的进行测试。但是如果每次都需要编写初始化vue实例、渲染组件等操作，并且对Dom 断言也比较繁琐。比较好的办法是将这些针对 vue 测试的过程进程封装。当然这些封装是针对虽有vue项目通用的。这也就是 @vue/test-utils 的来历。</p><p><a href="https://v1.test-utils.vuejs.org/zh/installation/choosing-a-test-runner.html" target="_blank" rel="noreferrer">@vue/test-utils 的文档地址</a></p><p>首先、需要在vite.config.ts 中增加Vitest配置。</p><p>vite.config.ts</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import { defineConfig } from &#39;vite&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export default defineConfig({</span></span>
<span class="line"><span>  // ...</span></span>
<span class="line"><span>  test: {</span></span>
<span class="line"><span>    // enable jest-like global test APIs</span></span>
<span class="line"><span>    globals: true,</span></span>
<span class="line"><span>    // simulate DOM with happy-dom</span></span>
<span class="line"><span>    // (requires installing happy-dom as a peer dependency)</span></span>
<span class="line"><span>    environment: &#39;happy-dom&#39;,</span></span>
<span class="line"><span>    // 支持tsx组件，很关键</span></span>
<span class="line"><span>    transformMode: {</span></span>
<span class="line"><span>      web: [/.[tj]sx$/]</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>})</span></span></code></pre></div><p>其中的重要属性，我们需要讲解一下。</p><p>enviroment属性中配置了 happy-dom，用于提供测试所需要的 Dom 仿真。测试是在 node 环境中运行的，而不是浏览器中，需要提供一个 Dom 对象的仿真。然后就是 transformMode，由于代码中使用的 TSX 语法，所以需要设置转换处理。</p><p>在配置时，我们发现 ts文件会报错。这是由于 test 属性属于 Vitest 的扩展属性，vite 原生配置中并没有定义这个属性。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f7622da5a5d4c359a80122622e15bd8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>解决的办法就是在 vite.config.ts 中增加一个类型定义声明</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faa418d172df45b7a4d2111f5a2fc281~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>代码如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/// &lt;reference types=&quot;vitest&quot; /&gt;</span></span>
<span class="line"><span>import { defineConfig } from &#39;vite&#39;</span></span>
<span class="line"><span>import vue from &#39;@vitejs/plugin-vue&#39;</span></span>
<span class="line"><span>import vueJsx from &#39;@vitejs/plugin-vue-jsx&#39;</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>// https://vitejs.dev/config/</span></span>
<span class="line"><span>export default defineConfig({</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>})</span></span></code></pre></div><p>这样的话报警就可以取消了。</p><h3 id="代码的小重构" tabindex="-1">代码的小重构 <a class="header-anchor" href="#代码的小重构" aria-label="Permalink to &quot;代码的小重构&quot;">​</a></h3><p>测试之前做一个代码的小重构。就是给每一个组件添加一个入口 index.ts。 将原来的 index.tsx =&gt; Button.tsx 新建一个 index.ts</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Button </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./Button&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导出Button组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Button ;</span></span></code></pre></div><h3 id="编写测试用例" tabindex="-1">编写测试用例 <a class="header-anchor" href="#编写测试用例" aria-label="Permalink to &quot;编写测试用例&quot;">​</a></h3><p>在 /src/button/<strong>test</strong> 中添加 Button.spec.ts：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a3a4d1847394b089680a65f801ec554~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>Button.spec.ts</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Button </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;../Button&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { shallowMount } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@vue/test-utils&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { describe, expect, test } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vitest&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 测试分组</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">describe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Button&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // mount</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mount  @vue/test-utils&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // @vue/test-utils</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wrapper</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shallowMount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Button, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   slots: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    default: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Button&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 断言</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  expect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wrapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toBe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Button&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span></code></pre></div><p>在测试文件中创建一个 describe 分组。在第一个参数中输入【Button】，表明是针对 Button 的测试。编写测试用例 test ，使用 shallowMount 初始化组件，测试按钮是否工作正常，只需要断言判断按钮中的字符串是否正确就可以了。</p><p>下面增加测试运行脚本。</p><p>package.json</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          &quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vitest&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>启动单元测试：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461a9488b98b4433bbedfe4b750cd3c4~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>上面的测试只是测试了按钮的默认状态。对于按钮组件来讲，它的主要逻辑是根据不同的 props 属性来定制不同的样式。下面我们针对这些逻辑继续编写测试。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54b28a93f8504e26aaa4ee8dcc254035~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>比如： color 属性是根据传入的不同条件定义不同的颜色，只需要让断言判断是否加载不同的属性就行了。</p><ul><li>Color: default</li></ul><table tabindex="0"><thead><tr><th>输入：color</th><th>输出：css</th></tr></thead><tbody><tr><td>空(默认)</td><td>bg-blue-500</td></tr><tr><td>red</td><td>bg-red-500</td></tr></tbody></table><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  describe(&#39;color&#39;, () =&gt; {</span></span>
<span class="line"><span>    test(&quot;default&quot;, () =&gt; {</span></span>
<span class="line"><span>      const wrapper = shallowMount(Button, {</span></span>
<span class="line"><span>        slots: {</span></span>
<span class="line"><span>          default: &#39;Button&#39;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      });</span></span>
<span class="line"><span>      expect(wrapper.classes().map(v =&gt; v.replace(&#39;\\n&#39;,&#39;&#39;)).includes(&#39;bg-blue-500&#39;)).toBe(true)</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>    test(&quot;red&quot;, () =&gt; {</span></span>
<span class="line"><span>      const wrapper = shallowMount(Button, {</span></span>
<span class="line"><span>        slots: {</span></span>
<span class="line"><span>          default: &#39;Button&#39;</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        props: {</span></span>
<span class="line"><span>          color: &#39;red&#39;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      });</span></span>
<span class="line"><span>      expect(wrapper.classes().map(v =&gt; v.replace(&#39;\\n&#39;,&#39;&#39;)).includes(&#39;bg-red-500&#39;)).toBe(true)</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>  })</span></span></code></pre></div><p>编写测试的时候，使用 describe 创建一个子分组，用于测试 color 属性。然后设置不同的 color 属性值，用断言来判断是否输出对应的 css 样式。</p><p>剩余的属性测试和 color 的测试非常类似，我们就不再赘述。<strong>在代码编写阶段，建议只对重点功能进行测试，没必要一定追求过高的测试覆盖率</strong>，因为前期过度地测试也会提高开发成本，拖慢开发进度。关于测试覆盖率的问题，我们会在后续章节介绍。</p><p>到目前为止，已经把组件库的测试框架搭好了。</p><p>本章节代码分支： <a href="https://github.com/smarty-team/smarty-admin/tree/chapter06/packages/smarty-ui-vite" target="_blank" rel="noreferrer">https://github.com/smarty-team/smarty-admin/tree/chapter06/packages/smarty-ui-vite</a></p><h2 id="复盘" tabindex="-1">复盘 <a class="header-anchor" href="#复盘" aria-label="Permalink to &quot;复盘&quot;">​</a></h2><p>这节课我们主要讲了组件库添加测试环境，引入Vitest 实现，整体上 Vitest 和 Jest 风格非常类似。基本上可以 0 学习成本切换。而且得益于通属于 Vite 生态，可以做到通用配置和更好的执行效率。</p><p>对于 Vue 框架开发代码的测试，当然可以使用原始的的测试框架进行测试。但是，为了简化测试，也会有人将执行过程和测试断言做进一步的封装， 比如 Vue Test Unit 这样的工具库，利用工具库封装了执行过程可以简化单元测试的编写。</p><p>最会要总结的就是，要认真编写描述字符串和合理的使用 describe 测试分组。描述字符串会在测试不通过的时候直接显示到命令行中，直接告诉你哪个组件的什么功能没有通过测试。而更好的测试分组可以有效提高测试的可读性。</p><p>最后留一些思考题帮助大家复习，也欢迎在留言区讨论。</p><ul><li>如何配置 Vitest 环境？</li><li>如何使用 @vue/test-utils 完成 Vue3 项目的测试？</li></ul><p>下节课，我们将给大家讲解如何配置自动化检查工具，下节课见。</p>`,64),e=[p];function l(h,o,r,k,c,d){return i(),a("div",null,e)}const E=s(t,[["render",l]]);export{g as __pageData,E as default};
