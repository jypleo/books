import{_ as s,c as i,o as a,a2 as p}from"./chunks/framework.D8Prfz4N.js";const E=JSON.parse('{"title":"品质保证：发布覆盖率测试报告","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/基于 Vite 的组件库工程化实战/16 品质保证：覆盖率测试报告.md","filePath":"pamphlet/基于 Vite 的组件库工程化实战/16 品质保证：覆盖率测试报告.md"}'),n={name:"pamphlet/基于 Vite 的组件库工程化实战/16 品质保证：覆盖率测试报告.md"},t=p(`<h1 id="品质保证-发布覆盖率测试报告" tabindex="-1">品质保证：发布覆盖率测试报告 <a class="header-anchor" href="#品质保证-发布覆盖率测试报告" aria-label="Permalink to &quot;品质保证：发布覆盖率测试报告&quot;">​</a></h1><p>代码覆盖率才是评价一个项目品质的标准。在挑选一个项目的时候，有经验的使用者都会根据代码覆盖率来确定代码的可靠性。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c93ce8ab39f448e8dfb20aff694b66c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>虽然自动化测试工具可以自动验证代码的正确性，但是如果只有部分代码经过了测试，或者只是简单地跑通了代码，也不能说是一个合格的代码。比如组件库只测试一部分的组件，或者每个组件只测试了默认设置。譬如，按钮中某个属性或者某几个属性间的排列组合并没有得到测试，这样的测试还不能保证组件库的功能完全正确。</p><p>那么如何来客观评价这个测试的完备程度呢？<strong>答案就是代码覆盖率。</strong></p><h3 id="覆盖率概念" tabindex="-1">覆盖率概念 <a class="header-anchor" href="#覆盖率概念" aria-label="Permalink to &quot;覆盖率概念&quot;">​</a></h3><p>代码覆盖率（Code coverage）是软件测试中的一种度量指标，描述测试过程中（运行时）被执行的源代码占全部源代码的比例。</p><h3 id="覆盖率指标种类" tabindex="-1">覆盖率指标种类 <a class="header-anchor" href="#覆盖率指标种类" aria-label="Permalink to &quot;覆盖率指标种类&quot;">​</a></h3><p>只是简单地做到行级覆盖还远远不够，可以看看下面的例子。</p><div class="language-JavaScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Jane&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Tony&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以上代码只需要两个 Case，就可以将所有语句都跑一遍：</p><ul><li><p>Case01: a = true ; b = true; 期待：Jane</p></li><li><p>Case02: a =false ; b= true; 期待：Tony</p></li></ul><p>但是，显然这样测试甚至不能确定代码中 b 是否参与条件判断。比如下面代码可能也会出现相同的结果。</p><div class="language-JavaScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Jane&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Tony&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>所以假设覆盖率只有简单的代码行覆盖还远远不够。</p><p>在软件工程理论中会把覆盖率分为：</p><ul><li><p>语句覆盖（statement coverage）</p></li><li><p>判定覆盖（decision coverage）</p></li><li><p>条件覆盖（condition coverage）</p></li><li><p>条件判定组合覆盖（condition decision coverage）</p></li><li><p>路径覆盖（path coverage）</p></li><li><p>多条件覆盖（multi-condition coverage）</p></li><li><p>修正条件判定覆盖（modified condition / decision coverage）</p></li></ul><p>覆盖深度的提高显然会让代码功能验证更加全面，但是相应的实施成本也会明显提高。</p><p>理论的覆盖虽然全面但是实际生产很多指标的指导价值并不是很大。在实际生产中会将它进行简化。</p><p>在Javascript语言中，代码覆盖率通常会分为四级覆盖。</p><ul><li><p>Function coverage 函数覆盖 - 每个函数是否被执行；</p></li><li><p>Line coverage 行覆盖 -- 每行是否被执行；</p></li><li><p>Statement coverage 语句覆盖 - 每个语句是否被执行；</p></li><li><p>Branch coverage 分支覆盖 - 每个 if 节点是否都被执行。</p></li></ul><p>这是结合了函数式语言的特点和指标的实用程度的经验之谈，也是 JavaScript 世界比较受认可的标准。</p><h2 id="用户故事-userstory" tabindex="-1">用户故事(UserStory) <a class="header-anchor" href="#用户故事-userstory" aria-label="Permalink to &quot;用户故事(UserStory)&quot;">​</a></h2><p>为组件库发布覆盖率报告，使测试覆盖率可视化。</p><h2 id="任务分解-task" tabindex="-1">任务分解(Task) <a class="header-anchor" href="#任务分解-task" aria-label="Permalink to &quot;任务分解(Task)&quot;">​</a></h2><ul><li><p>生成覆盖率报告；</p></li><li><p>将覆盖率报告任务加入到 CI；</p></li><li><p>上传覆盖率展示平台 Codecov；</p></li><li><p>获取覆盖率徽章。</p></li></ul><h3 id="istanbul-代码覆盖率工具" tabindex="-1">Istanbul 代码覆盖率工具 <a class="header-anchor" href="#istanbul-代码覆盖率工具" aria-label="Permalink to &quot;Istanbul 代码覆盖率工具&quot;">​</a></h3><p>代码覆盖率需要专用的工具生成。在 JavaScript 程序中的代码覆盖率通常都是通过 Istanbul 生成的。Istanbul 的来历是伊斯坦布尔的地毯，覆盖率报告其实就是用颜色来表示代码的运行情况，好像给代码铺上了地毯。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/136d83153d154f9fb399f09a2fbf0fd3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>我们熟悉的 Jest 和组件库使用的 Vitest 测试框架，都是使用的 Istanbul。Istanbul 的实现原理是通过编译期代码插桩方式实现的。有兴趣的同学可以研究一下。咱们这里面只讲如何使用。</p><p><a href="http://www.alloyteam.com/2019/07/13481/" target="_blank" rel="noreferrer">覆盖率原理介绍</a></p><h3 id="生成覆盖率报告" tabindex="-1">生成覆盖率报告 <a class="header-anchor" href="#生成覆盖率报告" aria-label="Permalink to &quot;生成覆盖率报告&quot;">​</a></h3><p>在 Vitest 只需要在命令行中添加参数 --coverage 就可以生成覆盖率报告了。</p><p>package.json</p><div class="language-Bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;scripts&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    &quot;coverage&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vitest run --coverage&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span></code></pre></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db99b6c528194bc6b4b3b8ca8be272cb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b869a23aac1741c5b38778b028a3db61~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>默认报告形式是一个静态网站。</p><p>如果想对报告进行进一步调整，可以在 vite.config.ts 中进行。</p><div class="language-TypeScript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">TypeScript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    coverage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;istanbul&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// or &#39;c8&#39;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      reporter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;html&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span></code></pre></div><p>我调整的两项是：</p><ul><li><p>指定覆盖率引擎 istanbul；</p></li><li><p>指定输出格式，默认是没有 json 格式的。这个和后面的覆盖率展示有关，务必要加。</p></li></ul><h3 id="公布覆盖率报告" tabindex="-1">公布覆盖率报告 <a class="header-anchor" href="#公布覆盖率报告" aria-label="Permalink to &quot;公布覆盖率报告&quot;">​</a></h3><p>覆盖率报告放在本地只能给自己的单元测试提供依据，更大的用途在于将覆盖率报告公布展示出来，让使用者可以看到。通常会选用覆盖率展示平台，常用的有 Codecov 和 Coveralls。</p><p>Codecov 是一个开源的测试结果展示平台，将测试结果可视化。Github 上许多开源项目都使用了 Codecov 来展示单测结果。Codecov 跟 Travis CI 一样都支持 Github 账号登录，同样会同步 Github 中的项目。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/002489c3b9694e628f074a9e34411c31~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>还会自动的生成徽章。这个徽章是会根据报告结果动态变化的，属于客观的第三方数据，具有公信力。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7e29147a7d8454a89c060064bc698e8~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>首先需要登录 <a href="https://codecov.io/" target="_blank" rel="noreferrer">Codecov 网站</a>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/916b40c4fdab41ef8d101de6dc09ec17~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><strong>一定要使用 Github 账号进行登录</strong>**，**这样它可以直接读取你的 Github 中的项目。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54fa963f55314b9eac8fccf2be2a7f18~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fab030df9e354e9d80b6dae48c38d019~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>然后是添加访问授权，如果你的项目在你名下的组织下，也需要访问授权。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7f8724305248dea6e5c6e8d9c81562~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这时候你就可以在网站上找到所有 Github 中的项目。选择 【Not yet setup 】，选择需要展示覆盖率报告的网站后的【 setup repo】链接，就可以看到安装指南。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acd2265cd42b4270b0ce5646b9b92e26~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>它这个安装指南是针对所有语言项目的。这里面我们只需要得到它的上传 Token 就好了。</p><h3 id="持续集成自动更新覆盖率报告" tabindex="-1">持续集成自动更新覆盖率报告 <a class="header-anchor" href="#持续集成自动更新覆盖率报告" aria-label="Permalink to &quot;持续集成自动更新覆盖率报告&quot;">​</a></h3><p>覆盖率报告最好能够自动按照最新版本持续更新，而不是自己手动上传。所以这个时候就需要使用 CI 工具来帮忙了。首先需要编写一个 Action。</p><p>.github/wokflows/codecov.yml</p><div class="language-YAML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">YAML</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># .github/workflows/main.yml</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># This is a basic workflow to help you get started with Actions</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Code Coverage</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Controls when the action will run. Triggers the workflow on push or pull request</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># events but only for the master branch</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    branches</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  pull_request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    branches</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">jobs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  CodeCov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # The type of runner that the job will run on</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    runs-on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">ubuntu-latest</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Steps represent a sequence of tasks that will be executed as part of the job</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    steps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">uses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">actions/checkout@v2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">uses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pnpm/action-setup@v2.1.0</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7.2.1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Install modules</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pnpm install</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Run Test Coverage</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cd packages/smarty-ui-vite &amp;&amp; pnpm coverage</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Upload coverage to Codecov</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        uses</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">codecov/codecov-action@v3</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          directory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">packages/smarty-ui-vite/coverage</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\${{ secrets.CODECOV_TOKEN }}</span></span></code></pre></div><p>上传报告环节同样使用现成的 Action 。这里面需要添加 Token，把上面 codecov 安装指南中得到的 Token 放入 Secrets 中。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68f97f6f17ce41fb97284e52d0ae5668~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>提交代码就可以自动生成覆盖率报告了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8efba2895c5947e2ba16c071a97560f0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>Codecov Action 会自动识别语言与测试框架的覆盖率报告种类，然后上传相应的数据。这里面要特别说明，对于 Vitest ，是上传的 json 格式的报告，所以需要确定你确实生成了 json 报告。如何生成可以看上文介绍。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d3e16744bf74dbdb73ffe5925a802c0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h3 id="添加覆盖率徽章" tabindex="-1">添加覆盖率徽章 <a class="header-anchor" href="#添加覆盖率徽章" aria-label="Permalink to &quot;添加覆盖率徽章&quot;">​</a></h3><p>最后就是富有仪式感的一步。Codecov 网站可以将测试结果生成为徽章。你可以把徽章直接放到 Github 中展示出来。</p><p>在项目的【 Settings 】中找到对应的徽章。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aebac1af71e4ac8adcb3368854b9217~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc997f9d61cc48649ddbed58b20e586f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="复盘" tabindex="-1">复盘 <a class="header-anchor" href="#复盘" aria-label="Permalink to &quot;复盘&quot;">​</a></h2><p>这节课的主要内容是介绍覆盖率概念和发布测试覆盖率报告。</p><p>覆盖率报告是项目品质的重要指标，成熟的项目都会把项目展示在显眼的位置，大家通常都会拿代码覆盖率指标评价开源代码的成熟度。当然过高的覆盖率也会带来成本的提高，和拉低项目进步速率。</p><p>品质、进度、成本是每一个项目管理中都需要均衡的东西。所以一味追求代码覆盖率也未必是好事。这个大家要客观看待。</p><p>最后留一些思考题帮助大家复习，也欢迎在留言区讨论。</p><ul><li><p>分支覆盖和行覆盖间的关系？</p></li><li><p>如何用 Codecov 完成覆盖率展示 ？</p></li></ul><p>下节课，我们将给大家讲解如何使用 PullRequest，下节课见。</p>`,80),e=[t];function l(h,k,r,c,o,d){return a(),i("div",null,e)}const u=s(n,[["render",l]]);export{E as __pageData,u as default};
