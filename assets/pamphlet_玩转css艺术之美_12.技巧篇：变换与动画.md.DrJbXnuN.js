import{_ as n,c as s,o as a,a2 as e}from"./chunks/framework.D8Prfz4N.js";const h=JSON.parse('{"title":"12.技巧篇：变换与动画","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/玩转css艺术之美/12.技巧篇：变换与动画.md","filePath":"pamphlet/玩转css艺术之美/12.技巧篇：变换与动画.md"}'),p={name:"pamphlet/玩转css艺术之美/12.技巧篇：变换与动画.md"},l=e(`<h1 id="_12-技巧篇-变换与动画" tabindex="-1">12.技巧篇：变换与动画 <a class="header-anchor" href="#_12-技巧篇-变换与动画" aria-label="Permalink to &quot;12.技巧篇：变换与动画&quot;">​</a></h1><h3 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h3><p>曾经简单的交互都需使用JS才能完成，经历过<code>jQuery时代</code>的同学应该很清楚，使用原生JS写交互很艰难，但是使用<code>jQuery</code>封装好的交互函数那就很简单了。</p><p>如今CSS3增加了<code>transform</code>、<code>transition</code>和<code>animation</code>三大交互属性，为CSS的单调性增加了很多趣味，也为交互开发增加了新的可能。</p><h3 id="变换" tabindex="-1">变换 <a class="header-anchor" href="#变换" aria-label="Permalink to &quot;变换&quot;">​</a></h3><p>变换分为<code>2D变换</code>和<code>3D变换</code>。2D变换在平面上操作，3D变换在空间上操作，2D和3D的概念相信很多同学都会了吧。变换可理解成将节点复制一份并生成新的图层，原节点隐藏，使用新节点进行变换操作。</p><p>声明<code>transform-style</code>可实现<code>2D变换</code>和<code>3D变换</code>间的切换，不同变换空间需使用对应的变换函数。当然<code>transform-style</code>需声明在父节点中，即需发生变换的节点的父节点。</p><ul><li><strong>flat</strong>：所有变换效果在平面上呈现(<code>默认</code>)</li><li><strong>preserve-3d</strong>：所有变换效果在空间上呈现</li></ul><p>笔者已将<code>2D变换函数</code>和<code>3D变换函数</code>整理好，在不同变换空间使用对应的变换函数即可。</p><ul><li><p><strong>translate()</strong>：位移</p></li><li><ul><li><strong>translate(x,y)</strong>：2D位移</li><li><strong>translate3d(x,y,z)</strong>：3D位移</li></ul></li><li><ul><li><strong>translateX(x)</strong>：X轴位移，等同于<code>translate(x,0)</code>或<code>translate3d(x,0,0)</code></li><li><strong>translateY(y)</strong>：Y轴位移，等同于<code>translate(0,y)</code>或<code>translate3d(0,y,0)</code></li></ul></li><li><ul><li><strong>translateZ(z)</strong>：Z轴位移，等同于<code>translate3d(0,0,z)</code></li><li>描述</li></ul></li><li><ul><li><ul><li>单位：<code>Length</code>长度，可用任何长度单位，允许负值</li><li>默认：XYZ轴不声明默认是<code>0</code></li></ul></li></ul></li><li><ul><li><ul><li>正值：沿X轴向右位移/沿Y轴向上位移/沿Z轴向外位移</li><li>负值：沿X轴向左位移/沿Y轴向下位移/沿Z轴向内位移</li></ul></li></ul></li><li><p><strong>scale()</strong>：缩放</p></li><li><ul><li><strong>scale(x,y)</strong>：2D缩放</li><li><strong>scale3d(x,y,z)</strong>：3D缩放</li></ul></li><li><ul><li><strong>scaleX(x)</strong>：X轴缩放，等同于<code>scale(x,1)</code>或<code>scale3d(x,1,1)</code></li><li><strong>scaleY(y)</strong>：Y轴缩放，等同于<code>scale(1,y)</code>或<code>scale3d(1,y,1)</code></li></ul></li><li><ul><li><strong>scaleZ(z)</strong>：Z轴缩放，等同于<code>scale3d(1,1,z)</code></li><li>描述</li></ul></li><li><ul><li><ul><li>单位：<code>Number</code>数值或<code>Percentage</code>百分比，允许负值</li><li>默认：XYZ轴不声明默认是<code>1</code>或<code>100%</code></li></ul></li></ul></li><li><ul><li><ul><li>正值：<code>0&lt;(x,y,z)&lt;1</code>沿X轴缩小/沿Y轴缩小/沿Z轴变厚，<code>(x,y,z)&gt;1</code>沿X轴放大/沿Y轴放大/沿Z轴变薄</li><li>负值：<code>-1&lt;(x,y,z)&lt;0</code>翻转沿X轴缩小/沿Y轴缩小/沿Z轴变厚，<code>(x,y,z)&lt;-1</code>翻转沿X轴放大/沿Y轴放大/沿Z轴变薄</li></ul></li></ul></li><li><p><strong>skew()</strong>：扭曲</p></li><li><ul><li><strong>skew(x,y)</strong>：2D扭曲</li><li><strong>skewX(x)</strong>：X轴扭曲，等同于<code>skew(x,0)</code></li></ul></li><li><ul><li><strong>skewY(y)</strong>：Y轴扭曲，等同于<code>skew(0,y)</code></li><li>描述</li></ul></li><li><ul><li><ul><li>单位：<code>Angle</code>角度或<code>Turn</code>周</li><li>默认：XY轴不声明默认是<code>0</code></li></ul></li></ul></li><li><ul><li><ul><li>正值：沿X轴向左扭曲/沿Y轴向下扭曲</li><li>负值：沿X轴向右扭曲/沿Y轴向上扭曲</li></ul></li></ul></li><li><p><strong>rotate()</strong>：旋转</p></li><li><ul><li><strong>rotate()</strong>：2D旋转</li><li><strong>rotate3d(x,y,z,a)</strong>：3D旋转，<code>[x,y,z]</code>是一个向量，数值都是<code>0~1</code></li></ul></li><li><ul><li><strong>rotateX(a)</strong>：X轴旋转，等同于<code>rotate(1,0,0,a)</code>，正值时沿X轴向上逆时针旋转，负值时沿X轴向下顺时针旋转</li><li><strong>rotateY(a)</strong>：3D Y轴旋转，等同于<code>rotate(0,1,0,a)</code>，正值时沿Y轴向右逆时针旋转，负值时沿Y轴向左顺时针旋转</li></ul></li><li><ul><li><strong>rotateZ(a)</strong>：3D Z轴旋转，等同于<code>rotate(0,0,1,a)</code>，正值时沿Z轴顺时针旋转，负值时沿Z轴逆时针旋转</li><li>描述</li></ul></li><li><ul><li><ul><li>单位：<code>Angle</code>角度或<code>Turn</code>周</li><li>正值：2D旋转时顺时针旋转</li></ul></li></ul></li><li><ul><li><ul><li>负值：2D旋转时逆时针旋转</li></ul></li></ul></li><li><p><strong>matrix()</strong>：矩阵(<code>太过复杂，可放弃</code>)</p></li><li><ul><li><strong>matrix(a,b,c,d,e,f)</strong>：2D矩阵(位移、缩放、扭曲、旋转的综合函数)</li><li><strong>matrix(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)</strong>：3D矩阵(位移、缩放、扭曲、旋转的综合函数)</li></ul></li><li><p><strong>perspective()</strong>：视距</p></li><li><ul><li><code>Length</code>：长度，可用任何长度单位</li></ul></li></ul><p><code>transform</code>的使用场景很多，不局限于某种特定场景，若结合<code>transition</code>和<code>animation</code>使用还必须注意性能问题。</p><p>多值执行顺序</p><p>与<code>backgound</code>和<code>mask</code>一致可声明多重效果，使用<code>逗号</code>隔开。网上很多结论说<code>transform</code>多值执行顺序是<code>从左到右</code>或<code>从右到左</code>，其实这样的结论都是比较笼统的。正确来说并无执行上的先后顺序, 而是由多个变换对应的矩阵相乘, 再拿该矩阵去乘以坐标，最终得出变换效果。</p><p>例如<code>transform:translate(150px,0),rotate(45deg)</code>和<code>transform:rotate(45deg),translate(150px,0)</code>，最终的变换效果就有所不同。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2985494/1607321423385-a36ba44c-564d-44b4-ace4-d745568293b2.png" alt="img"></p><ul><li>第一种：先往右位移<code>150px</code>，坐标轴不变；再顺时针旋转<code>45deg</code>，坐标轴顺时针旋转<code>45deg</code></li><li>第二种：先顺时针旋转<code>45deg</code>，坐标轴顺时针旋转<code>45deg</code>；再往右位移<code>150px</code>，坐标轴不变</li></ul><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.elem {</span></span>
<span class="line"><span>    display: flex;</span></span>
<span class="line"><span>    justify-content: center;</span></span>
<span class="line"><span>    align-items: center;</span></span>
<span class="line"><span>    position: absolute;</span></span>
<span class="line"><span>    left: 50px;</span></span>
<span class="line"><span>    top: 50px;</span></span>
<span class="line"><span>    width: 100px;</span></span>
<span class="line"><span>    height: 100px;</span></span>
<span class="line"><span>    background-color: #f66;</span></span>
<span class="line"><span>    font-size: 20px;</span></span>
<span class="line"><span>    color: #fff;</span></span>
<span class="line"><span>    &amp;.transform-1 {</span></span>
<span class="line"><span>        transform: translate(150px, 0) rotate(45deg);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    &amp;.transform-2 {</span></span>
<span class="line"><span>        transform: rotate(45deg) translate(150px, 0);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>正确的理解是<code>从左到右</code>，但是还得注意坐标轴是否发生了变化，若坐标轴发生了变化，会影响到后续的变换效果。<strong>优先考虑坐标轴的变化，先分析出前后</strong><code>**缩放旋转**</code><strong>的变化，再分析出前后</strong><code>**位移扭曲**</code><strong>的变化</strong>。</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>缩放和旋转都能让坐标轴发生变化，这个必须谨记</span></span></code></pre></div><p>视距效果</p><p><code>transform:perspective()</code>也可通过<code>perspective</code>声明，这个属性在开启3D变换后最好声明上，否则有些3D变换效果可能无法得到更好的展现。</p><ul><li>值越小，用户与空间Z轴距离越近，视觉效果越强</li><li>值越大，用户与空间Z轴距离越远，视觉效果越弱</li></ul><p>perspective/perspective()区别</p><p><code>perspective</code>和<code>transform:perspective()</code>都能声明视距，那为何要存在两种声明方式呢？当然是有它们的区别所以才能存在呀。</p><ul><li><code>perspective</code>与<code>transform:perspective()</code>的作用相同</li><li><code>perspective</code>在<code>舞台节点</code>(变换节点的父节点)上使用，<code>transform:perspective()</code>在<code>当前变换节点</code>上使用，也可与其他变换函数一起使用</li></ul><p>GPU硬件加速模式</p><p>有无发现即使很简单的动画，有时都能引起卡顿，特别是在移动端上尤其明显。在此介绍一种Hack方法，为节点声明<code>transform:transition3d()</code>或<code>transform:translateZ()</code>，这两个声明都会开启<strong>GPU硬件加速模式</strong>，从而让浏览器在渲染动画时从CPU转向GPU，实现硬件加速。</p><p><code>transform:transition3d()</code>和<code>transform:translateZ()</code>其实是为了渲染3D样式，但声明为<code>0</code>后并无真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。在<code>Webkit内核</code>下使用<code>transform:translate3d()</code>加速效果会更明显。</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.elem {</span></span>
<span class="line"><span>    transform: transition3d(0, 0, 0);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>/* 或 */</span></span>
<span class="line"><span>.elem {</span></span>
<span class="line"><span>    transform: translateZ(0);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>在使用该方案时可能会出现诡异的缺陷。当有多个绝对定位的节点声明<code>transform:transition3d()</code>开启GPU硬件加速模式后会有几个节点凭空消失，是不是很诡异。这种现象不能完全解决，只能尽量避免。</p><ul><li><p>尽量不要对节点及其父节点声明<code>position:absolute/fixed</code>，当然这个很难避免不使用</p></li><li><p>减少声明<code>transform:transition3d()</code>的节点数量，减少至6个以下即可</p></li><li><p>声明<code>will-change</code>代替<code>transform:transition3d()</code>，详情请戳<a href="https://segmentfault.com/a/1190000020926189" target="_blank" rel="noreferrer">这里</a></p></li></ul><p>笔者比较推荐第二种方法，节点的数量可通过JS动态控制，保持在6个以下。而<code>will-change</code>会存在另一些问题，大量使用还是会引发更严重的性能问题，笔者后续会在本章更新详细的分析。</p><h5 id="动感心形" tabindex="-1">动感心形 <a class="header-anchor" href="#动感心形" aria-label="Permalink to &quot;动感心形&quot;">​</a></h5><p><code>transform</code>有一个很实用的场景，就是通过<code>transform:translate()</code>补位。<strong>补位</strong>指实现效果的最终位置还差一点距离就能完成，通过<code>margin</code>或<code>transform:translate()</code>将该距离补充完整，将节点调整到最终位置。</p><p>还记得第6章<strong>布局方式</strong>的居中布局吗？有一种方式就是通过<code>transform:translate(-50%,-50%)</code>将节点拉回最中央，节点无需声明位移的距离是宽高的二分之一，使用<code>50%</code>自动计算其距离为宽高的二分之一即可。</p><p>描绘一个心形虽然不是一个很常用的场景，作为一名雄性程序猿，<code>214</code>和<code>520</code>等具有示爱性质的节日，当然少不了用纯CSS描绘一个动感心形啦。</p><p>使用单个<code>&lt;div&gt;</code>结合两个伪元素<code>::before</code>和<code>::after</code>通过错位叠加的方式合并成一个心形。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2985494/1607321423494-1a4268c5-8d59-4f04-9bb5-3146d9fb419e.png" alt="img"></p><ul><li><p>声明<code>&lt;div&gt;</code>的尺寸为一个<code>正方形</code>并以中心顺时针旋转<code>45deg</code></p></li><li><p>声明两个伪元素继承<code>&lt;div&gt;</code>的尺寸并实行绝对定位</p></li><li><p>声明两个伪元素的圆角率为<code>100%</code>并平移到相应位置</p></li></ul><p>巧妙利用了<code>transform</code>将两个伪元素平移到相应位置产生叠加错觉。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2985494/1607321423453-98339233-b400-4827-b784-84ef514e8e1b.png" alt="img"></p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;div class=&quot;heart-shape&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span>.heart-shape {</span></span>
<span class="line"><span>    position: relative;</span></span>
<span class="line"><span>    width: 200px;</span></span>
<span class="line"><span>    height: 200px;</span></span>
<span class="line"><span>    background-color: #f66;</span></span>
<span class="line"><span>    transform: rotate(45deg);</span></span>
<span class="line"><span>    &amp;::before,</span></span>
<span class="line"><span>    &amp;::after {</span></span>
<span class="line"><span>        position: absolute;</span></span>
<span class="line"><span>        left: 0;</span></span>
<span class="line"><span>        top: 0;</span></span>
<span class="line"><span>        border-radius: 100%;</span></span>
<span class="line"><span>        width: 100%;</span></span>
<span class="line"><span>        height: 100%;</span></span>
<span class="line"><span>        background-color: #f66;</span></span>
<span class="line"><span>        content: &quot;&quot;;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    &amp;::before {</span></span>
<span class="line"><span>        transform: translateX(-50%);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    &amp;::after {</span></span>
<span class="line"><span>        transform: translateY(-50%);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><hr><ul><li>在线演示：<a href="https://codepen.io/JowayYoung/pen/QWNdZRg" target="_blank" rel="noreferrer">Here</a></li><li>在线源码：<a href="https://github.com/JowayYoung/idea-css/blob/master/icss/src/components/figure/%E4%BD%BF%E7%94%A8transform%E6%8F%8F%E7%BB%98%E5%8A%A8%E6%84%9F%E5%BF%83%E5%BD%A2.vue" target="_blank" rel="noreferrer">Here</a></li></ul><h5 id="像素边框" tabindex="-1">像素边框 <a class="header-anchor" href="#像素边框" aria-label="Permalink to &quot;像素边框&quot;">​</a></h5><p><code>1px边框</code>在桌面端网站看上去没什么大问题，但在移动端网站看上去却觉得很粗。由于大部分移动端都具有细腻的屏幕，像iPhone的<code>Retina屏幕</code>，一个像素可由4个点或9个点组成，在接近视网膜极限的情况下，<code>1px边框</code>看起来确实会有点粗。</p><p>那么可声明<code>0.5px边框</code>吗。答案是可行的，即使声明成功，但有些浏览器还是按照<code>1px</code>的值去渲染，这样就导致不同设备的边框参差不齐了。</p><p>换个思路，使用一个伪元素的边框去当作节点边框，声明<code>border</code>为<code>1px</code>并将其宽高声明成<code>200%</code>，最终效果是该节点的2倍大小，再通过声明<code>transform:scale(.5)</code>将该伪元素缩小到原来的<code>0.5倍</code>，现在和节点尺寸一致了，而<code>border</code>也通过浏览器自动计算成<code>0.5px</code>了，最终实现<code>0.5px边框</code>。其实现原理就是将边框宽度计算交由浏览器处理。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2985494/1607321423376-837de869-107f-4382-9d11-a050c142ab5c.png" alt="img"></p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;div class=&quot;onepx-border normal&quot;&gt;1px&lt;/div&gt;</span></span>
<span class="line"><span>&lt;div class=&quot;onepx-border thin&quot;&gt;0.5px&lt;/div&gt;</span></span>
<span class="line"><span>.onepx-border {</span></span>
<span class="line"><span>    width: 200px;</span></span>
<span class="line"><span>    height: 80px;</span></span>
<span class="line"><span>    cursor: pointer;</span></span>
<span class="line"><span>    line-height: 80px;</span></span>
<span class="line"><span>    text-align: center;</span></span>
<span class="line"><span>    font-weight: bold;</span></span>
<span class="line"><span>    font-size: 50px;</span></span>
<span class="line"><span>    color: #f66;</span></span>
<span class="line"><span>    &amp; + .onepx-border {</span></span>
<span class="line"><span>        margin-top: 10px;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    &amp;.normal {</span></span>
<span class="line"><span>        border: 1px solid #f66;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    &amp;.thin {</span></span>
<span class="line"><span>        position: relative;</span></span>
<span class="line"><span>        &amp;::after {</span></span>
<span class="line"><span>            position: absolute;</span></span>
<span class="line"><span>            left: 0;</span></span>
<span class="line"><span>            top: 0;</span></span>
<span class="line"><span>            border: 1px solid #f66;</span></span>
<span class="line"><span>            width: 200%;</span></span>
<span class="line"><span>            height: 200%;</span></span>
<span class="line"><span>            content: &quot;&quot;;</span></span>
<span class="line"><span>            transform: scale(.5);</span></span>
<span class="line"><span>            transform-origin: left top;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><hr><ul><li>在线演示：<a href="https://codepen.io/JowayYoung/pen/YzKqMVO" target="_blank" rel="noreferrer">Here</a></li><li>在线源码：<a href="https://github.com/JowayYoung/idea-css/blob/master/icss/src/components/layout/%E4%BD%BF%E7%94%A8transform%E6%8F%8F%E7%BB%98%E5%83%8F%E7%B4%A0%E8%BE%B9%E6%A1%86.vue" target="_blank" rel="noreferrer">Here</a></li></ul><h5 id="内容翻转" tabindex="-1">内容翻转 <a class="header-anchor" href="#内容翻转" aria-label="Permalink to &quot;内容翻转&quot;">​</a></h5><p>遇到一些内容翻转的场景，有些同学可能会声明<code>transform:rotate3d()</code>将内容沿着Y轴旋转<code>180deg</code>水平翻转。</p><p>其实可声明<code>transform:scale()</code>为负值将内容直接翻转，细心的同学应该注意到上述有谈到。</p><ul><li><p>水平翻转：<code>transform:scale(1,-1)</code></p></li><li><p>垂直翻转：<code>transform:scale(-1,1)</code></p></li><li><p>倒序翻转：<code>transform:scale(-1,-1)</code></p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/2985494/1607321423494-861660bb-29e3-478e-8b53-d19dba54b082.png" alt="img"></p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;ul class=&quot;flip-content&quot;&gt;</span></span>
<span class="line"><span>    &lt;li&gt;正常文本&lt;/li&gt;</span></span>
<span class="line"><span>    &lt;li class=&quot;x-axis&quot;&gt;水平翻转&lt;/li&gt;</span></span>
<span class="line"><span>    &lt;li class=&quot;y-axis&quot;&gt;垂直翻转&lt;/li&gt;</span></span>
<span class="line"><span>    &lt;li class=&quot;reverse&quot;&gt;倒序翻转&lt;/li&gt;</span></span>
<span class="line"><span>&lt;/ul&gt;</span></span>
<span class="line"><span>.flip-content {</span></span>
<span class="line"><span>    li {</span></span>
<span class="line"><span>        position: relative;</span></span>
<span class="line"><span>        width: 121px;</span></span>
<span class="line"><span>        height: 51px;</span></span>
<span class="line"><span>        line-height: 51px;</span></span>
<span class="line"><span>        text-align: center;</span></span>
<span class="line"><span>        font-weight: bold;</span></span>
<span class="line"><span>        font-size: 30px;</span></span>
<span class="line"><span>        color: #f66;</span></span>
<span class="line"><span>        &amp;::before,</span></span>
<span class="line"><span>        &amp;::after {</span></span>
<span class="line"><span>            position: absolute;</span></span>
<span class="line"><span>            background-color: #66f;</span></span>
<span class="line"><span>            content: &quot;&quot;;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        &amp; + li {</span></span>
<span class="line"><span>            margin-top: 10px;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        &amp;.x-axis {</span></span>
<span class="line"><span>            transform: scale(1, -1);</span></span>
<span class="line"><span>            &amp;::after {</span></span>
<span class="line"><span>                left: 0;</span></span>
<span class="line"><span>                top: 25px;</span></span>
<span class="line"><span>                width: 100%;</span></span>
<span class="line"><span>                height: 1px;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        &amp;.y-axis {</span></span>
<span class="line"><span>            transform: scale(-1, 1);</span></span>
<span class="line"><span>            &amp;::after {</span></span>
<span class="line"><span>                left: 60px;</span></span>
<span class="line"><span>                top: 0;</span></span>
<span class="line"><span>                width: 1px;</span></span>
<span class="line"><span>                height: 100%;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        &amp;.reverse {</span></span>
<span class="line"><span>            transform: scale(-1, -1);</span></span>
<span class="line"><span>            &amp;::before {</span></span>
<span class="line"><span>                left: 0;</span></span>
<span class="line"><span>                top: 25px;</span></span>
<span class="line"><span>                width: 100%;</span></span>
<span class="line"><span>                height: 1px;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            &amp;::after {</span></span>
<span class="line"><span>                left: 60px;</span></span>
<span class="line"><span>                top: 0;</span></span>
<span class="line"><span>                width: 1px;</span></span>
<span class="line"><span>                height: 100%;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>在线演示：<a href="https://codepen.io/JowayYoung/pen/NWKNZwO" target="_blank" rel="noreferrer">Here</a></li><li>在线源码：<a href="https://github.com/JowayYoung/idea-css/blob/master/icss/src/components/layout/%E4%BD%BF%E7%94%A8transform%E7%BF%BB%E8%BD%AC%E5%AE%B9%E5%99%A8%E5%86%85%E5%AE%B9.vue" target="_blank" rel="noreferrer">Here</a></li></ul><h3 id="过渡" tabindex="-1">过渡 <a class="header-anchor" href="#过渡" aria-label="Permalink to &quot;过渡&quot;">​</a></h3><p>有时在不同状态间切换属性可能会显得很生硬，此时<code>transition</code>就派上用场了，它能让状态间的切换变得更丝滑。</p><ul><li><p><strong>transition-property</strong>：属性</p></li><li><ul><li><code>all</code>：全部属性过渡(<code>默认</code>)</li><li><code>none</code>：无属性过渡</li></ul></li><li><ul><li><code>String</code>：某个属性过渡</li></ul></li><li><p><strong>transition-duration</strong>：时间</p></li><li><ul><li><code>Time</code>：秒或毫秒(默认<code>0</code>)</li></ul></li><li><p><strong>transition-timing-function</strong>：缓动函数</p></li><li><ul><li><code>ease</code>：逐渐变慢，等同于<code>cubic-bezier(.25,.1,.25,1)</code>(<code>默认</code>)</li><li><code>linear</code>：匀速，等同于<code>cubic-bezier(0,0,1,1)</code></li></ul></li><li><ul><li><code>ease-in</code>：加速，等同于<code>cubic-bezier(.42,0,1,1)</code></li><li><code>ease-out</code>：减速，等同于<code>cubic-bezier(0,0,.58,1)</code></li></ul></li><li><ul><li><code>ease-in-out</code>：先加速后减速，等同于<code>cubic-bezier(.42,0,.58,1)</code></li><li><code>cubic-bezier</code>：贝塞尔曲线，<code>(x1,y1,x2,y2)</code>四个值特定于曲线上的点<code>P1</code>和<code>P2</code>，所有值需在<code>[0,1]</code>区域内</li></ul></li><li><p><strong>transition-delay</strong>：时延</p></li><li><ul><li><code>Time</code>：秒或毫秒(默认<code>0</code>)</li></ul></li></ul><p>总体来说，<code>transition</code>可用到所有可能发生属性变更的节点上，但有一些情况是绝对不能使用的。<code>transition</code>延缓某些属性的变更过程，若通过<code>鼠标事件</code>给某个节点属性赋值，会导致属性在变更过程中发生卡顿。</p><p>例如通过鼠标的<code>mousemove</code>事件将<code>top</code>从<code>10px</code>变更到<code>20px</code>。由于声明了<code>transition:300ms</code>，那么从<code>10px</code>变更到<code>11px</code>时会将该过程延缓<code>300ms</code>，导致了该过程的执行时长是<code>300ms</code>，而此刻想要的效果是瞬间从<code>10px</code>变更到<code>11px</code>，再依次变更到<code>20px</code>。整个过程是鼠标移动就立刻赋值，这样才能实时显示<code>top</code>的变化，而声明了<code>transition</code>反而起到副作用导致看上去很卡顿。</p><p>由于<code>duration</code>和<code>delay</code>的取值都是时间，所以可能会发生混淆。</p><ul><li><p><code>duration</code>和<code>delay</code>作用于所有节点，包括自身的<code>::before</code>和<code>::after</code></p></li><li><p><code>transition</code>中出现两个时间值时，第一个解析为<code>duration</code>，第二个解析为<code>delay</code></p></li><li><p><code>transition</code>中出现一个时间值时，解析为<code>duration</code></p></li></ul><p>缓动函数其实就是<strong>贝塞尔曲线</strong>，相关原理可自行百度。推荐一个设置缓动函数形状的网站<a href="https://cubic-bezier.com/" target="_blank" rel="noreferrer">CubicBezier</a>，可根据需求设置想要的缓动函数。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/2985494/1607321423743-9e8c962e-3fa1-4a6b-a25a-0511ab92f2e8.jpeg" alt="img"></p><p>还记得第9章<strong>选择器</strong>的切换按钮的刹车动画吗？点击按钮后，圆点从左到右有一个细微的刹车动画，这个不是通过JS捣鼓出来的，而是笔者细心地调制了一个缓动函数<a href="https://cubic-bezier.com/#.4,.4,.25,1.35" target="_blank" rel="noreferrer">cubic-bezier(.4,.4,.25,1.35)</a>实现的。具体实现可通过笔者推荐的网站自行调制喔。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/2985494/1607321423592-36b93a34-db2e-45f9-9c19-3618f0da45f8.gif" alt="img"></p><h3 id="动画" tabindex="-1">动画 <a class="header-anchor" href="#动画" aria-label="Permalink to &quot;动画&quot;">​</a></h3><p>上述<code>transform</code>能让节点拥有更多形态，而<code>animation</code>能让节点拥有更多状态。正是有了<code>animation</code>，所以才让交互效果更精彩。</p><p>CSS动画可通过设置多个点精确控制一个或一组动画，用来实现复杂的动画效果。</p><p>动画由多个点组成，每个点拥有独立的状态，这些状态通过浏览器处理成过渡效果，点与点间的过渡效果串联起来就是一个完整的动画。</p><p><code>animation</code>可声明的两种动画，每种动画各有自身特点。</p><ul><li><strong>关键帧动画</strong>：在时间轴的关键帧上绘制关键状态并使之有效过渡组成动画</li><li><strong>逐帧动画</strong>：在时间轴的每一帧上绘制不同内容并使之连续播放组成动画</li></ul><p><code>关键帧动画</code>可看作是一个连续的动画片段，<code>逐帧动画</code>可看作是一个断续的动画片段，两种动画都是通过时间流逝将多个动画片段串联在一起。浏览器可将关键帧动画的关键帧自动过渡成片段，而将逐帧动画的每一帧按顺序播放成片段，可认为逐帧动画是一个<code>GIF</code>。</p><ul><li><p><strong>animation-name</strong>：名称</p></li><li><ul><li><code>none</code>：无动画(<code>默认</code>)</li><li><code>String</code>：动画名称</li></ul></li><li><p><strong>animation-duration</strong>：时间</p></li><li><ul><li><code>Time</code>：秒或毫秒(默认<code>0</code>)</li></ul></li><li><p><strong>animation-timing-function</strong>：缓动函数</p></li><li><ul><li><code>ease</code>：逐渐变慢，等同于<code>cubic-bezier(.25,.1,.25,1)</code>(<code>默认</code>)</li><li><code>linear</code>：匀速，等同于<code>cubic-bezier(0,0,1,1)</code></li></ul></li><li><ul><li><code>ease-in</code>：加速，等同于<code>cubic-bezier(.42,0,1,1)</code></li><li><code>ease-out</code>：减速，等同于<code>cubic-bezier(0,0,.58,1)</code></li></ul></li><li><ul><li><code>ease-in-out</code>：先加速后减速，等同于<code>cubic-bezier(.42,0,.58,1)</code></li><li><code>cubic-bezier</code>：贝塞尔曲线，<code>(x1,y1,x2,y2)</code>四个值特定于曲线上的点<code>P1</code>和<code>P2</code>，所有值需在<code>[0,1]</code>区域内</li></ul></li><li><ul><li><code>steps([,[start|end]]?)</code>：把动画平均划分成<code>n等分</code>，直到平均走完该动画</li><li><code>step-start</code>：等同于<code>steps(1,start)</code>，把动画分成一步，动画执行时以左侧端点<code>0%</code>为开始</li></ul></li><li><ul><li><code>step-end</code>：等同于<code>steps(1,end)</code>，把动画分成一步，动画执行时以右侧端点<code>100%</code>为开始</li></ul></li><li><p><strong>animation-delay</strong>：时延</p></li><li><ul><li><code>Time</code>：秒或毫秒(默认<code>0</code>)</li></ul></li><li><p><strong>animation-iteration-count</strong>：播放次数</p></li><li><ul><li><code>Number</code>：数值(默认<code>1</code>)</li><li><code>infinite</code>：无限次</li></ul></li><li><p><strong>animation-direction</strong>：轮流反向播放(播放次数为一次则该属性无效果)</p></li><li><ul><li><code>normal</code>：正常播放(<code>默认</code>)</li><li><code>alternate</code>：轮流反向播放，奇数次数正常播放，偶数次数反向播放</li></ul></li><li><p><strong>animation-play-state</strong>：播放状态</p></li><li><ul><li><code>running</code>：正在播放(<code>默认</code>)</li><li><code>paused</code>：暂停播放</li></ul></li><li><p><strong>animation-fill-mode</strong>：播放前后其效果是否可见</p></li><li><ul><li><code>none</code>：不改变默认行为(<code>默认</code>)</li><li><code>backwards</code>：在时延所指定时间内或在动画开始前应用开始属性(<code>在第一个关键帧中定义</code>)</li></ul></li><li><ul><li><code>forwards</code>：在动画结束后保持最后一个属性(<code>在最后一个关键帧中定义</code>)</li><li><code>both</code>：向前和向后填充模式都被应用</li></ul></li></ul><p>关键帧动画必须通过<code>animation</code>和<code>@keyframes</code>声明，逐帧动画只能通过<code>animation-timing-function:steps()</code>声明。总体来说，逐帧动画的声明比较简单，可用一张<code>逐帧长图</code>完成整个动画效果，而关键帧动画需结合<code>@keyframes</code>为每个关键帧声明当前对应的状态，若涉及的点较多，可能比较繁琐。</p><p>关键帧动画声明步骤</p><ul><li><p>在<code>@keyframes</code>里声明动画名称和动画每个关键帧的状态</p></li><li><p>动画名称不能重复否则会被覆盖，关键帧通过百分比分割出每个关键帧并声明对应的状态</p></li><li><p>在指定节点中声明<code>animation</code>调用动画</p></li></ul><p>逐帧动画声明步骤</p><ul><li><p>准备一张<code>逐帧长图</code>，该图像包含动画效果的每一帧且每帧宽高必须一致</p></li><li><p>在<code>steps()</code>里声明逐帧长图及其展示方式</p></li><li><p>在指定节点中声明<code>animation</code>调用动画</p></li></ul><p>@keyframes注意事项</p><p>关键帧动画的声明通过<code>@keyframes</code>完成，编写形式如下。</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@keyframes animation-name {</span></span>
<span class="line"><span>    from {}</span></span>
<span class="line"><span>    to {}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>/* 或 */</span></span>
<span class="line"><span>@keyframes animation-name {</span></span>
<span class="line"><span>    p1 {}</span></span>
<span class="line"><span>    p2 {}</span></span>
<span class="line"><span>    p3 {}</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>关键帧的取值必须是<code>from</code>、<code>to</code>或<code>Percentage</code>。<code>from</code>可用<code>0%</code>代替，<code>to</code>可用<code>100%</code>代替，若开始或结束的关键帧无对应的状态，可不用声明<code>from</code>或<code>to</code>。<code>0%</code>的<code>%</code>不能省略，否则关键帧解析会失败。</p><p>后面声明的关键帧状态会覆盖前面声明的关键帧状态，动画结束后会回到<code>animation-fill-mode</code>声明的状态。</p><h5 id="自动打字器" tabindex="-1">自动打字器 <a class="header-anchor" href="#自动打字器" aria-label="Permalink to &quot;自动打字器&quot;">​</a></h5><p>很多在线编辑器网站都有一些自动打字的效果，例如<a href="https://codepen.io/JowayYoung" target="_blank" rel="noreferrer">CodePen</a>。很多同学都以为是JS实现的效果，其实查看<code>Chrome Devtools</code>发现是纯CSS实现的。观察多几次自动打字器，可发现其存在以下特点。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/2985494/1607321423544-7a47d490-4a3a-43d0-8cc2-1d6182eb58e7.gif" alt="img"></p><ul><li><p>字体都是等宽字体，等宽字体可保证每次打字时光标的移动距离都是一致的</p></li><li><p>打字器的宽度由最初的<code>0px</code>逐渐增加内容后变成最终固定字数的宽度，宽度以等宽字体的个数为准</p></li><li><p>光标随着每打一个字就闪烁一次，打字速度均匀，打字完成后再次重复打字</p></li><li><p>整个打字过程存在两个动画，一个是打字器自增宽度，一个是光标闪烁</p></li><li><p>整个打字过程一闪一闪地完成，根据其断断续续的特点可判断该动画为逐帧动画</p></li></ul><p>还记得第5章<strong>样式计算</strong>的长度单位吗？有一个叫做<code>ch</code>的长度单位，它是一个等宽字体的特有长度单位，准确宽度为<code>0</code>的宽度。因此一个等宽字体就是<code>1ch</code>，两个等宽字体就是<code>2ch</code>。通过等宽字体个数定制打字器长度最合适不过了，而常用的设备自带等宽字体有<code>Consolas</code>、<code>Monaco</code>和<code>Monospace</code>三种。</p><p><code>打字器自增宽度</code>可用<code>0px</code>到等宽字体指定个数的宽度<code>nch</code>为一个自增周期，使用动画完成其自增过程即可。</p><p><code>光标闪烁</code>可用<code>border-right</code>模拟，具体形象现在可脑补一下，有无想出什么效果？节点里包含文本，在最右边声明<code>border-right</code>，那不就是一个具有静态光标的输入状态吗？文本右边就是光标，很符合常理，为<code>border-right</code>声明一个闪烁动画即可。</p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;div class=&quot;auto-typing&quot;&gt;Do You Want To Know More About CSS Development Skill&lt;/div&gt;</span></span>
<span class="line"><span>@mixin typing($count: 0, $duration: 0, $delay: 0) {</span></span>
<span class="line"><span>    overflow: hidden;</span></span>
<span class="line"><span>    border-right: 1px solid transparent;</span></span>
<span class="line"><span>    width: #{$count + 1}ch;</span></span>
<span class="line"><span>    font-family: Consolas, Monaco, monospace;</span></span>
<span class="line"><span>    white-space: nowrap;</span></span>
<span class="line"><span>    animation: typing #{$duration}s steps($count + 1) #{$delay}s infinite backwards,</span></span>
<span class="line"><span>        caret 500ms steps(1) #{$delay}s infinite forwards;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>.auto-typing {</span></span>
<span class="line"><span>    font-weight: bold;</span></span>
<span class="line"><span>    font-size: 30px;</span></span>
<span class="line"><span>    color: #09f;</span></span>
<span class="line"><span>    @include typing(52, 5);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>@keyframes caret {</span></span>
<span class="line"><span>    50% {</span></span>
<span class="line"><span>        border-right-color: currentColor;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>@keyframes typing {</span></span>
<span class="line"><span>    from {</span></span>
<span class="line"><span>        width: 0;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li>在线演示：<a href="https://codepen.io/JowayYoung/pen/ZEzKQEx" target="_blank" rel="noreferrer">Here</a></li><li>在线源码：<a href="https://github.com/JowayYoung/idea-css/blob/master/icss/src/components/component/%E8%87%AA%E5%8A%A8%E6%89%93%E5%AD%97%E5%99%A8.vue" target="_blank" rel="noreferrer">Here</a></li></ul>`,97),o=[l];function i(c,t,d,r,u,g){return a(),s("div",null,o)}const f=n(p,[["render",i]]);export{h as __pageData,f as default};
