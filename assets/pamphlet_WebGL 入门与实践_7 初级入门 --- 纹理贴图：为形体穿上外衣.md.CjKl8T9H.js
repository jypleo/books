import{_ as i,c as s,o as a,a2 as l}from"./chunks/framework.D8Prfz4N.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pamphlet/WebGL 入门与实践/7 初级入门 --- 纹理贴图：为形体穿上外衣.md","filePath":"pamphlet/WebGL 入门与实践/7 初级入门 --- 纹理贴图：为形体穿上外衣.md"}'),t={name:"pamphlet/WebGL 入门与实践/7 初级入门 --- 纹理贴图：为形体穿上外衣.md"},h=l(`<p>之前章节我们学习了绘制单一和渐变颜色的三角形，但是在实际的建模中（游戏居多），模型表面往往都是丰富生动的图片。这就需要有一种机制，能够让我们把图片素材渲染到模型的一个或者多个表面上，这种机制叫做<code>纹理贴图</code>，本节我们学习如何使用 WebGL 进行纹理贴图。</p><h2 id="目标" tabindex="-1">目标 <a class="header-anchor" href="#目标" aria-label="Permalink to &quot;目标&quot;">​</a></h2><p>本节我们的目标是要学会纹理贴图的步骤以及注意事项。</p><ul><li><a href="http://ifanqi.top/webgl/pages/lesson13.html" target="_blank" rel="noreferrer">演示地址</a></li><li><a href="https://github.com/lucefer/webgl/blob/master/pages/lesson13.html" target="_blank" rel="noreferrer">源码地址</a></li></ul><p>通过本节学习，你将掌握如下内容：</p><ul><li>为什么需要贴图？</li><li>贴图的步骤？</li><li>注意事项。</li></ul><h2 id="为什么我们需要贴图" tabindex="-1">为什么我们需要贴图？ <a class="header-anchor" href="#为什么我们需要贴图" aria-label="Permalink to &quot;为什么我们需要贴图？&quot;">​</a></h2><p>之前章节的示例中，为图形增加色彩仅仅是用了简单的单色和渐变色，但是实际应用中往往需要一些丰富多彩的图案，我们不可能用代码来生成这些图案，费时费力，效果也不好。通常我们会借助一些图形软硬件（比如照相机、手机、PS等）准备好图片素材，然后在 WebGL 中把图片应用到图形表面。</p><h2 id="纹理图片格式" tabindex="-1">纹理图片格式 <a class="header-anchor" href="#纹理图片格式" aria-label="Permalink to &quot;纹理图片格式&quot;">​</a></h2><p>WebGL 对图片素材是有严格要求的，图片的宽度和高度必须是 2 的 N 次幂，比如 16 x 16，32 x 32，64 x 64 等。实际上，不是这个尺寸的图片也能进行贴图，但是这样会使得贴图过程更复杂，从而影响性能，所以我们在提供图片素材的时候最好参照这个规范。</p><h2 id="纹理坐标系统" tabindex="-1">纹理坐标系统 <a class="header-anchor" href="#纹理坐标系统" aria-label="Permalink to &quot;纹理坐标系统&quot;">​</a></h2><p>纹理也有一套自己的坐标系统，为了和顶点坐标加以区分，通常把纹理坐标称为 <code>UV</code>，<code>U</code> 代表横轴坐标，<code>V</code> 代表纵轴坐标。</p><ul><li><p>图片坐标系统的特点是：</p><ul><li>左上角为原点(0, 0)。</li><li>向右为横轴正方向，横轴最大值为 1，即横轴坐标范围【1，0】。</li><li>向下为纵轴正方向，纵轴最大值为 1，即纵轴坐标范围【0，1】。</li></ul></li><li><p>纹理坐标系统不同于图片坐标系统，它的特点是：</p><ul><li>左下角为原点(0, 0)。</li><li>向右为横轴正方向，横轴最大值为 1，即横轴坐标范围【1，0】。</li><li>向上为纵轴正方向，纵轴最大值为 1，即纵轴坐标范围【0，1】。</li></ul></li></ul><p>如下图所示：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/25/1688415c89af299b~tplv-t2oaga2asx-image.image" alt=""></p><p>纹理坐标系统可以理解为一个边长为 1 的正方形。</p><h3 id="贴图练习" tabindex="-1">贴图练习 <a class="header-anchor" href="#贴图练习" aria-label="Permalink to &quot;贴图练习&quot;">​</a></h3><p>接下来，我们学习一下贴图过程。</p><h4 id="准备图片" tabindex="-1">准备图片 <a class="header-anchor" href="#准备图片" aria-label="Permalink to &quot;准备图片&quot;">​</a></h4><p>按照规范所讲，我们首先准备一张符合要求的图片，这里自己制作一个尺寸为宽高分别是 2 的 7 次方，即 128 x 128 的图片。</p><h4 id="着色器" tabindex="-1">着色器 <a class="header-anchor" href="#着色器" aria-label="Permalink to &quot;着色器&quot;">​</a></h4><p>本节片元着色器中，不再是接收单纯的颜色了，而是接收纹理图片对应坐标的颜色值，所以我们的着色器要能够做到如下几点：</p><ul><li>顶点着色器接收顶点的 <code>UV</code> 坐标，并将<code>UV</code>坐标传递给片元着色器。</li><li>片元着色器要能够接收顶点插值后的<code>UV</code>坐标，同时能够在纹理资源找到对应坐标的颜色值。</li></ul><p>我们看下如何修改才能满足这两点：</p><ul><li>顶点着色器</li></ul><p>首先，增加一个名为 v_Uv 的 attribute 变量，接收 JavaScript 传递过来的 UV 坐标。<br> 其次，增加一个 varying 变量 v_Uv，将 UV 坐标插值化，并传递给片元着色器。</p><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    precision mediump </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 接收顶点坐标 (x, y)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   attribute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a_Position;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 接收 canvas 尺寸(width, height)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   attribute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a_Screen_Size;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 接收JavaScript传递过来的顶点 uv 坐标。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   attribute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a_Uv;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 将接收的uv坐标传递给片元着色器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   varying</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Uv;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     vec2 position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a_Position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a_Screen_Size) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     gl_Position </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> vec4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 将接收到的uv坐标传递给片元着色器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     v_Uv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a_Uv;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span></code></pre></div><ul><li>片元着色器 首先，增加一个 <code>varying</code> 变量 <code>v_Uv</code>，接收顶点着色器插值过来的 <code>UV</code> 坐标。<br> 其次，增加一个 <code>sampler2D</code> 类型的全局变量 <code>texture</code>，用来接收 JavaScript 传递过来的纹理资源（图片数据）。</li></ul><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	precision mediump </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 接收顶点着色器传递过来的 uv 值。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	varying</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v_Uv;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 接收 JavaScript 传递过来的纹理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	uniform</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sampler2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> texture;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 提取纹理对应uv坐标上的颜色，赋值给当前片元（像素）。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  		gl_FragColor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> texture2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(texture, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v_Uv.x, v_Uv.y));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span></code></pre></div><h4 id="javascript-部分" tabindex="-1">JavaScript 部分 <a class="header-anchor" href="#javascript-部分" aria-label="Permalink to &quot;JavaScript 部分&quot;">​</a></h4><p>我们首先要将纹理图片加载到内存中：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    img.onload </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textureLoadedCallback;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    img.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>图片加载完成之后才能执行纹理的操作，我们将纹理操作放在图片加载完成后的回调函数中，即<code>textureLoadedCallback</code>。</p><p>需要注意的是，我们使用 canvas 读取图片数据是受浏览器跨域限制的，所以首先要解决跨域问题。</p><p>那么，针对图片跨域问题我们可以采用三种方式来解决：</p><p><strong>第一种方法：设置允许 Chrome 跨域加载资源</strong></p><p>在本地开发阶段，我们可以设置 Chrome 浏览器允许加载跨域资源，这样就可以使用磁盘地址来访问页面了。</p><p>mac 设置方法如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /Applications/Google</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Chrome.app/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --args</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --disable-web-security</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --user-data-dir(指定目录,例如</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /user/Documents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>第二种方法：图片资源和页面资源放在同一个域名下</strong></p><p>除了设置 Chrome，我们还可以将图片资源和页面资源部署在同一域名下，这样就不存在跨域问题了。</p><p><strong>第三种方法：为图片资源设置跨域响应头</strong></p><p>实际生产环境中，图片资源往往部署在 CDN 上，图片和页面分属不同域，这种情况的跨域访问我们就需要正面解决了。</p><p>假设我们的图片资源所属域名为：<code>https://cdn-pic.com</code>，页面所属域名为 <code>https://test.com</code>。</p><p>解决方法如下：</p><ul><li>首先：为图片资源设置跨域响应头：</li></ul><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Access</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Allow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Origin：\`https:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//test.com\`</span></span></code></pre></div><ul><li>其次：在图片加载时，为 img 设置 crossOrigin 属性。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> img </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img.crossOrigin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">img.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;https://cdn-pic.com/test.jpg&#39;</span></span></code></pre></div><p>做完这两步，我们就可以真正的加载跨域图片了。 解决了图片加载跨域问题，我们就可以开始纹理贴图了。</p><p>我们定义六个顶点，这六个顶点能够组成一个矩形，并为顶点指定纹理坐标。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> positions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//V0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//V1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//V2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//V0</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//V2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //V3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span></code></pre></div><p>按照惯例，我们该为着色器传递数据了。</p><blockquote><p>经历过前面几个小节的练习，相信大家对操作 WebGL 的代码已经很熟悉了。</p></blockquote><p>加载图片</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> img  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	img.onload </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textureLoadedCallback;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	img.src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><blockquote><p>您或许看到我并没有为 img 设置 <code>crossOrigin</code> 属性，原因是在我本地，图片和页面在同一个域名下，所以不需要额外设置。</p></blockquote><p>图片加载完成后，我们进行如下操作：</p><p>首先：激活 0 号纹理通道<code>gl.TEXTURE0</code>，0 号纹理通道是默认值，本例也可以不设置。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">activeTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>然后创建一个纹理对象：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> texture </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>之后将创建好的纹理对象<code>texture</code>绑定 到<code>当前纹理绑定点</code>上，即 <code>gl.TEXTURE_2D</code>。绑定完之后对当前纹理对象的所有操作，都将基于 <code>texture</code> 对象，直到重新绑定。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindTexture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, texture);</span></span></code></pre></div><p>为片元着色器传递图片数据：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">texImage2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UNSIGNED_BYTE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, img);</span></span></code></pre></div><p>gl.texImage2D 方法是一个重载方法，其中有一些参数可以省略：</p><blockquote><p>glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, glsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);</p></blockquote><table tabindex="0"><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>target</td><td>纹理类型，TEXTURE_2D代表2维纹理</td></tr><tr><td>level</td><td>表示多级分辨率的纹理图像的级数，若只有一种分辨率，则 level 设为 0，通常我们使用一种分辨率</td></tr><tr><td>components</td><td>纹理通道数，通常我们使用 RGBA 和 RGB 两种通道</td></tr><tr><td>width</td><td>纹理宽度，可省略</td></tr><tr><td>height</td><td>纹理高度，可省略</td></tr><tr><td>border</td><td>边框，通常设置为0，可省略</td></tr><tr><td>format</td><td>纹理映射的格式</td></tr><tr><td>type</td><td>纹理映射的数据类型</td></tr><tr><td>pixels</td><td>纹理图像的数据</td></tr></tbody></table><p>上面这段代码的意思是，我们将 img 变量指向的图片数据传递给片元着色器，取对应纹理坐标的 RGBA 四个通道值，赋给片元，每个通道的数据格式是无符号单字节整数。</p><p>接下来，我们设置图片在放大或者缩小时采用的算法<code>gl.LINEAR</code>。</p><blockquote><p>gl.LINEAR 代表采用最靠近象素中心的四个象素的加权平均值，这种效果表现的更加平滑自然。 gl.NEAREST 采用最靠近象素中心的纹素，该算法可能使图像走样，但是执行效率高，不需要额外的计算。</p></blockquote><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">texParameterf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_MAG_FILTER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LINEAR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">texParameterf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TEXTURE_MIN_FILTER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gl.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LINEAR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>之后为片元着色器传递 0 号纹理单元：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uniform1i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uniformTexture, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><blockquote><p>这里，我们为片元着色器的 texture 属性传递 0，此处应该与激活纹理时的通道值保持一致。</p></blockquote><p>图片作为纹理的渲染效果如下：</p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/25/1688422a4034bef1~tplv-t2oaga2asx-image.image" width="80%"><p>可以看到，我们绘制的矩形表面贴上了纹理。</p><p>您或许有疑问，为什么我只是指定了三角形的顶点对应的 UV 坐标，GPU 就能够将纹理图片的其他坐标的颜色贴到三角形表面呢？</p><p>这其实，就回归到了<code>渲染管线</code>这个概念上，在第一节我画了个图，大致阐述了渲染管线的工作方式，但其实在光栅化环节上有些细节没有说到。 在光栅化阶段，GPU 处理两件事情：</p><ul><li>计算图元覆盖了哪些像素。</li><li>根据顶点着色器的顶点位置计算每个像素的纹理坐标的插值。</li></ul><blockquote><p>注：片元可以理解为像素。</p></blockquote><p>光栅化结束后，来到片元着色器，片元着色器此时知道每个像素对应的 <code>UV</code> 坐标，根据当前像素的 <code>UV</code> 坐标，找到纹理资源对应坐标的颜色信息，赋值给当前像素，从而能够为图元表面的每个像素贴上正确的纹理颜色。</p><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><p>我们总结一下贴图的注意点：</p><ul><li>图片最好满足 2^m x 2^n 的尺寸要求。</li><li>图片数据首先加载到内存中，才能够在纹理中使用。</li><li>图片资源加载前要先解决跨域问题。</li></ul><h2 id="回顾" tabindex="-1">回顾 <a class="header-anchor" href="#回顾" aria-label="Permalink to &quot;回顾&quot;">​</a></h2><p>至此，我们使用 WebGL 绘制平面的课程就结束了，总结一下之前章节所学的知识点：</p><ul><li>GLSL：着色器 <ul><li>数据类型 <ul><li>vec2：2 维向量容器。</li><li>vec4：4 维向量容器。</li><li>运算法则：向量与向量、向量与浮点数的运算法则。</li></ul></li><li>修饰符 <ul><li>attribute：属性修饰符。</li><li>uniform：全局变量修饰符。</li><li>varying：顶点着色器传递给片元着色器的属性修饰符。</li></ul></li><li>precision：设置精度 <ul><li>highp：高精度。</li><li>mediump：中等精度。</li><li>lowp：低精度。</li></ul></li><li>内置变量 <ul><li>gl_Position：顶点坐标。</li><li>gl_FragColor：片元颜色。</li><li>gl_PointSize：顶点大小。</li></ul></li><li>屏幕坐标系到设备坐标系的转换。 <ul><li>屏幕坐标系左上角为原点，X 轴坐标向右为正，Y 轴坐标向下为正。</li><li>坐标范围： <ul><li>X轴：【0, canvas.width】</li><li>Y轴：【0, canvas.height】</li></ul></li><li>设备坐标系以屏幕中心为原点，X 轴坐标向右为正，Y 轴向上为正。</li><li>坐标范围是 <ul><li>X轴：【-1, 1】。</li><li>Y轴：【-1, 1】。</li></ul></li></ul></li></ul></li><li>WebGL API <ul><li>shader：着色器对象 <ul><li>gl.createShader：创建着色器。</li><li>gl.shaderSource：指定着色器源码。</li><li>gl.compileShader：编译着色器。</li></ul></li><li>program：着色器程序 <ul><li>gl.createProgram：创建着色器程序。</li><li>gl.attachShader：链接着色器对象。</li><li>gl.linkProgram：链接着色器程序。</li><li>gl.useProgram：使用着色器程序。</li></ul></li><li>attribute：着色器属性 <ul><li>gl.getAttribLocation：获取顶点着色器中的属性位置。</li><li>gl.enableVertexAttribArray：启用着色器属性。</li><li>gl.vertexAttribPointer：设置着色器属性读取 buffer 的方式。</li><li>gl.vertexAttrib2f：给着色器属性赋值，值为两个浮点数。</li><li>gl.vertexAttrib3f：给着色器属性赋值，值为三个浮点数。</li></ul></li><li>uniform：着色器全局属性 <ul><li>gl.getUniformLocation：获取全局变量位置。</li><li>gl.uniform4f：给全局变量赋值 4 个浮点数。</li><li>gl.uniform1i：给全局变量赋值 1 个整数。</li></ul></li><li>buffer：缓冲区 <ul><li>gl.createBuffer：创建缓冲区对象。</li><li>gl.bindBuffer：将缓冲区对象设置为当前缓冲。</li><li>gl.bufferData：向当前缓冲对象复制数据。</li></ul></li><li>clear：清屏 <ul><li>gl.clearColor：设置清除屏幕的背景色。</li><li>gl.clear：清除屏幕。</li></ul></li><li>draw：绘制 <ul><li>gl.drawArrays：数组绘制方式。</li><li>gl.drawElements：索引绘制方式。</li></ul></li><li>图元 <ul><li>gl.POINTS：点。</li><li>gl.LINE：基本线段。</li><li>gl.LINE_STRIP：连续线段。</li><li>gl.LINE_LOOP：闭合线段。</li><li>gl.TRIANGLES：基本三角形。</li><li>gl.TRIANGLE_STRIP：三角带。</li><li>gl.TRIANGLE_FAN：三角扇。</li></ul></li><li>纹理 <ul><li>gl.createTexture：创建纹理对象。</li><li>gl.activeTexture：激活纹理单元。</li><li>gl.bindTexture：绑定纹理对象到当前纹理。</li><li>gl.texImage2D：将图片数据传递给 GPU。</li><li>gl.texParameterf：设置图片放大缩小时的过滤算法。</li></ul></li></ul></li></ul><p>以上是截止到目前所涉及的知识点，大家可以按照自己的想法做些小例子，熟练掌握它们。</p><p>接下来我们开始学习如何使用基本图元构建 3D 模型。</p>`,92),p=[h];function n(e,k,r,d,E,g){return a(),s("div",null,p)}const y=i(t,[["render",n]]);export{c as __pageData,y as default};
